
declare namespace lcjs {
/**
 * Event handler for mouse event that is 'abrupt'.
 * Meaning that the event can be triggered as a side-effect of something totally unrelated, without an actual mouse-event.
 * ( Designed for making sure that mouse-leave is handled when hovered entity is disposed )
 * @param obj - Object
 * @param event - Browser MouseEvent that triggered the event of undefined if event is abrupt
 * @public
 */
export declare type AbruptMouseEventHandler<T> = (obj: T, event?: MouseEvent) => void;
/**
 * @public
 */
declare interface AbstractAxisStrategy {
}
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare class _AbstractAxisTick implements Disposable {
    /**
     * **Permanently** destroy the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @returns  Object itself for fluent interface
     * @public
     */
    dispose(): this;
}
/**
 * End user managed Tick. Custom ticks are just like default ticks, except they can be completely controlled by the end user.
 *
 * For example, their position, text, text fill style, gridline style, etc. everything can be customized.
 * They can be created whenever and destroyed whenever.
 *
 * This definition of Custom Tick is abstract, meaning that it is not tied to any specific chart type.
 * See specific implementations:
 *
 * - {@link CustomTick}
 * - {@link CustomTick3D}
 *
 * @public
 */
export declare interface AbstractCustomTick extends Disposable, DisposableEvents, Hideable, HideableEvents {
    /**
     * Set location of custom tick on its Axis.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setValue(5)
     * ```
     *
     * @param   value - Location on axis.
     * @returns         Object itself
     * @public
     */
    setValue(value: number): this;
    /**
     * Get location of custom tick on its Axis.
     * @returns         Location on axis.
     * @public
     */
    getValue(): number;
    /**
     * Set style of custom ticks tickline.
     * This line connects the text to its Axis, generally a very short line (6 pixels, or so).
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  CustomTick.setTickStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  CustomTick.setTickStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * ```ts
     *  // Example syntax, disable stroke
     *  CustomTick.setTickStyle(emptyLine)
     * ```
     *
     * @param   value   -   LineStyle or function which returns a LineStyle based on previous value.
     * @returns             Object itself.
     * @public
     */
    setTickStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of custom ticks tickline.
     * @returns         LineStyle
     * @public
     */
    getTickStyle(): LineStyle;
    /**
     * Set tickline length as pixels.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setTickLength(5)
     * ```
     *
     * @param   length -    Tickline length as pixels
     * @returns         Object itself
     * @public
     */
    setTickLength(length: number): this;
    /**
     * Get tickline length as pixels.
     * @returns         Tickline length as pixels.
     * @public
     */
    getTickLength(): number;
    /**
     * Set style of custom ticks gridline.
     * This line highlights the tick location under the series area.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  CustomTick.setGridStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  CustomTick.setGridStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * ```ts
     *  // Example syntax, disable stroke
     *  CustomTick.setGridStrokeStyle(emptyLine)
     * ```
     *
     * @param   value   -   LineStyle or function which returns a LineStyle based on previous value.
     * @returns             Object itself.
     * @public
     */
    setGridStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of custom ticks gridline.
     * @returns         LineStyle
     * @public
     */
    getGridStrokeStyle(): LineStyle;
    /**
     * Set padding between CustomTick tickline and text.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setTextPadding(5)
     * ```
     *
     * @param   padding - Padding as pixels
     * @returns         Object itself
     * @public
     */
    setTextPadding(padding: number): this;
    /**
     * Get padding between CustomTick tickline and text.
     * @returns         Padding as pixels
     * @public
     */
    getTextPadding(): number;
    /**
     * Set custom tick text rotation as degrees.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setTextRotation(90)
     * ```
     *
     * @param   value - Rotation as degrees.
     * @returns         Object itself
     * @public
     */
    setTextRotation(value: number): this;
    /**
     * Get custom tick text rotation as degrees.
     * @returns         Rotation as degrees.
     * @public
     */
    getTextRotation(): number;
    /**
     * Set fill style of custom ticks text.
     *
     * ```ts
     *  // Example syntax, red fill
     *  CustomTick.setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * ```ts
     *  // Example syntax, disable fill
     *  CustomTick.setTextFillStyle(emptyFill)
     * ```
     *
     * @param   value   -   FillStyle or function which returns a FillStyle based on previous value.
     * @returns             Object itself.
     * @public
     */
    setTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of custom ticks text.
     * @returns         FillStyle
     * @public
     */
    getTextFillStyle(): FillStyle;
    /**
     * Set font of custom ticks text.
     *
     * ```ts
     *  // Example syntax, specify FontSettings
     *  CustomTick.setTextFont(new FontSettings({
     *      size: 14,
     *      family: 'Arial',
     *      weight: 'normal',
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change to italic
     *  CustomTick.setTextFont(font => font.setStyle('italic'))
     * ```
     *
     * To remove custom tick text, use {@link setTextFillStyle}
     *
     * @param   value   -   FontSettings or function which returns a FontSettings based on previous value.
     * @returns             Object itself.
     * @public
     */
    setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of custom ticks text.
     * @returns         FontSettings
     * @public
     */
    getTextFont(): FontSettings;
    /**
     * Set text formatting of custom tick as a callback function.
     *
     * ```ts
     *  // Example usage
     *  CustomTick.setTextFormatter((value) => `Custom tick at ${value.toFixed(1)}`)
     * ```
     *
     * The supplied callback function is called with the current axis location of the custom tick.
     * To provide hard defined text, just ignore the `value`.
     *
     * ```ts
     *  // Example, hard defined custom tick text.
     *  CustomTick.setTextFormatter(() => `My tick text`)
     * ```
     *
     * @param   textFormatter   -   Callback function which returns custom tick text as string.
     * @returns         Object itself
     * @public
     */
    setTextFormatter(textFormatter: (value: number) => string): this;
    /**
     * Subscribe to value change event.
     * This event is triggered when {@link setValue} is called.
     *
     * **Example usage:**
     *
     *```javascript
     * // Set onValueChange event
     * CustomTick.onValueChange((_, num) => {
     *  console.log(num)
     * })
     *
     * // Set customTick value
     * CustomTick.setValue(20)
     *
     * ```
     * @param handler - Function that is called when event is triggered.
     * @param value - Position of CustomTick.
     * @returns Token that can be used to unsubscribe from the event.
     * @public
     */
    onValueChange(handler: (customTick: this, value: number) => unknown): Token;
    /**
     * Unsubscribe from value change event.
     *
     * This event is called whenever the position of the *CustomTick* is changed via  **CustomTick.setValue**.
     * @param token - Token that was received when the subscription was created.
     * @returns True if unsubscription was successful.
     * @public
     */
    offValueChange(token: Token): boolean;
}
/**
 * An abstract event subscription interface.
 *
 * Can be used just like Eventer, but without the need to specify the event identifier. This is useful, when
 * the event interface is injected into a component, and the component doesn't really need to know about the implementation specifics.
 * @public
 */
declare interface AbstractEventInterface<T extends any[] = any[]> {
    /**
     * Subscribe to the abstract event.
     * @param listener - Callback function that is called when the event is triggered.
     * @returns Token that can be used to unsubscribe from the event.
     */
    on: (listener: (args: T) => void) => Token;
    /**
     * Unsubscribe from the abstract event.
     * @param token - Token that was received when **on()** was called.
     * @returns True if the listener is successfully removed and false if it is not found.
     */
    off: (token: Token) => boolean;
}
/**
 * Abstract base class for Point Series 3D implementations.
 *
 * Implements full series logic except for Point Style API and segment length.
 * @public
 */
declare abstract class AbstractPointSeries3D<Style extends TriangulatedPoints3D | PixelatedPoints3D> extends Series3D implements XYZDataInput {
    /**
     * Append a single `XYZ` coordinate or list of coordinates into the *series*.
     *
     * ```ts
     *  // Example, add single data point.
     *  pointSeries.add({ x: 0, y: 0, z: 0 })
     *
     *  // Example, add list of data points.
     *  pointSeries.add([
     *      { x: 0, y: 100, z: 50 },
     *      { x: 10, y: 50, z: 150 },
     *      { x: 20, y: 75, z: 100 },
     *  ])
     * ```
     *
     * Performance-wise, it is more efficient to call `add` just 1 time with an Array of points, instead of calling `add` several times with 1 point at a time.
     *
     * Data points can also be grouped with extra optional properties:
     * - `size` | Point size.
     * - `color` | Point color.
     * - `value` | Point value for dynamic coloring.
     *
     * {@link setPointStyle} method documentation contains detailed information about each of these features and how to use them.
     *
     * @param points - Single XYZ coordinate or list of coordinates.
     * @returns Object itself for fluent interface.
     * @public
     */
    add(data: Point3D | Point3D[]): this;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  pointSeries.clear()
     * ```
     *
     * @returns Object itself for fluent interface.
     * @public
     */
    clear(): this;
    /**
     * Get amount of points that series currently has.
     * @returns Number of points
     * @public
     */
    getPointAmount(): number;
    /**
     * Attach object to an legendBox entry
     * @param entry         -    Object which has to be attached
     * @param toggleVisibilityOnClick     -  Flag that indicates whether the Attachable should be hidden or not,
     *                          when its respective Entry is clicked.
     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
     * @returns Object itself for fluent interface
     * @public
     */
    attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
}
/**
 * Minimum interface for implementation specific values necessary for tick plotting.
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _AbstractTickPlottingVariables {
    /**
     * Physical (visible) axis size as pixels.
     */
    physicalAxisSize: number;
}
/**
 * Angular interval object defines the minimum and maximum interval in degrees.
 * @public
 */
export declare type AngleInterval = SliceInterval;
/**
 * Class for animation handling
 * @param delta - Delta time from start of animation
 * @param eases - Array of Eases animation functions
 * @param nextAnimations - Queue of future animations
 * @param action - Function for handling of interframe modification
 * @param duration - Animation duration in milliseconds
 * @param easing - Ease animation function factory
 * @public
 */
declare class Animation_2 {
    /**
     * @public
     */
    delta: number;
    /**
     * @public
     */
    eases: Array<Ease>;
    /**
     * @public
     */
    readonly nextAnimations: Animation_2[];
    /**
     * @public
     */
    readonly values: Array<[number, number]>;
    /**
     * @public
     */
    readonly action: AnimationFrameCallback;
    /**
     * @public
     */
    readonly duration: number;
    /**
     * @public
     */
    readonly easing: AnimationEasing;
    /**
     * Starts an animation
     * @returns Object itself for fluent interface
     * @public
     */
    start(): this;
    /**
     * Add animations which has to be executed subsequently
     * @param animations - Subsequent Animation or Array of them
     * @returns Object itself for fluent interface
     * @public
     */
    addNextAnimations(animations: Animation_2 | Array<Animation_2>): this;
    /**
     * Add and create animation which has to be executed subsequently
     * @param values - Array of start and end animation values
     * @param action - Function for handling of interframe modification
     * @returns new Animation
     * @public
     */
    NextAnimation(values: Array<[number, number]>, action: AnimationFrameCallback, duration?: number, easing?: AnimationEasing): Animation_2;
    /**
     * Subscribe on current animation start event
     * @param action - Event listener
     * @returns Token of the event listener
     * @public
     */
    onAnimationStart(action: () => void, token?: Token): Token;
    /**
     * Subscribe on current animation end event
     * @param action - Event listener
     * @returns Token of the event listener
     * @public
     */
    onAnimationEnd(action: (nextAnimation?: Animation_2) => void, token?: Token): Token;
    /**
     * Subscribe on every subsequent animations end event
     * @param action - Event listener
     * @returns Token of the event listener
     * @public
     */
    onEveryAnimationEnd(action: (nextAnimation?: Animation_2) => void, token?: Token): Token;
    /**
     * Subscribe on all subsequent animations end event
     * @param action - Event listener
     * @returns Token of the event listener
     * @public
     */
    onAllAnimationEnd(action: VoidFunction, token?: Token): Token;
    /**
     * Remove all listeners from Animation End Event
     * @returns Object itself for fluent interface
     * @public
     */
    allOffAnimationEnd(): this;
    /**
     * Remove all listeners from Every Animation End Event
     * @returns Object itself for fluent interface
     * @public
     */
    allOffEveryAnimationEnd(): this;
    /**
     * Remove all listeners from All Animation End Event
     * @returns Object itself for fluent interface
     * @public
     */
    allOffAllAnimationEnd(): this;
    /**
     * Remove a listener from Animation End Event
     * @param token - Token of the listener
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAnimationEnd(token: Token): boolean;
    /**
     * Remove a listener from Every Animation End Event
     * @param token - Token of the listener
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offEveryAnimationEnd(token: Token): boolean;
    /**
     * Remove a listener from All Animation End Event
     * @param token - Token of the listener
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAllAnimationEnd(token: Token): boolean;
    /**
     * Finish current animation and start the next one on the sequence
     * @param emitEvents - Flag that tells whether the function should emit any events
     * @returns Future animations or undefined
     * @public
     */
    finish(emitEvents?: boolean): Animation_2 | undefined;
    /**
     * Finish all animations
     * @param emitEvents - Flag that tells whether the function should emit any events
     * @public
     */
    finishAll(emitEvents?: boolean): void;
    /**
     * Get is animation over and there are no queued animations
     * @public
     */
    isOver: () => boolean;
    /**
     * Get final value of queued animations
     * @returns Final values of the animations
     * @public
     */
    getFinalValues(): number[];
    /**
     * Get time until all queued animations will finish
     * @public
     */
    getTimeUntilFinish(): number;
}
export { Animation_2 as Animation }
/**
 * Interface for {@link AnimationEasing}.
 *
 * See  {@link AnimationEasings} for a collection of default options.
 * @param start - Starting value of the animation
 * @param end - End value of the animation
 * @param duration - Animation Duration in milliseconds
 * @public
 */
export declare type AnimationEasing = (start: number, end: number, duration: number) => Ease;
/**
 * {@link AnimationEasing} collection to use with {@link Animator}.
 * @public
 */
export declare const AnimationEasings: {
    linear: (start: number, end: number, duration: number) => Ease;
    easeIn: (start: number, end: number, duration: number) => Ease;
    easeOut: (start: number, end: number, duration: number) => Ease;
    ease: (start: number, end: number, duration: number) => Ease;
    /**
     * Scroll easing factory for logarithmic axes.
     */
    logarithmic: (base: number) => AnimationEasing;
};
/**
 * Type of Animation Factory
 * @param values - Array of start and end animation values
 * @param action - Function for handling of interframe modification
 * @param customDuration - Override default duration of animation
 * @public
 */
export declare type AnimationFactory = (values: Array<[number, number]>, action: AnimationFrameCallback, customDuration?: number) => Animation_2;
/**
 * Function for handling of interframe modification
 * @param values - Values calculated by Ease function
 * @public
 */
export declare type AnimationFrameCallback = (values: Array<number>) => void;
/**
 * Animator factory.
 *
 * **Unpolished API, usage can be copied from Examples set but it is not further encouraged**.
 * @param afterUpdate - After all animation update callback
 * @param fps - Desirable frame rate for all animations (Limited to around 60fps by browser)
 * @public
 */
export declare const Animator: (afterUpdate: () => void, fps?: number) => (duration?: number, easing?: AnimationEasing) => AnimationFactory;
/**
 * Application deployment license information.
 * @public
 */
export declare interface AppDeploymentLicenseInformation {
    /**
     * Company name
     */
    company: string;
    /**
     * Application title
     */
    appTitle: string;
    [key: string]: string;
}
/**
 * Rectangular area in cartesian coordinates
 * @param x - X position of the area
 * @param y - Y position of the area
 * @param width - Width of the area
 * @param height - Height of the area
 */
declare interface Area {
    x: number;
    y: number;
    width: number;
    height: number;
}
/**
 * Interface for a data-structure which represents a 2-dimensional location, but with one of the planes
 * having two values instead of just one to create an area in the given location.
 *
 * Used to supply points to AreaRangeSeries.
 * @public
 */
export declare interface AreaPoint {
    /**
     * Position of Point.
     */
    readonly position: number;
    /**
     * High value of Point in the given position.
     */
    readonly high: number;
    /**
     * Low value of Point in the given position.
     */
    readonly low: number;
}
/**
 * Implementation of *SeriesXY* for visualizing a collection of progressive *AreaPoints*
 * (which consist of one *X*-value, and two *Y*-values) by filling the area between the points two *Y*-values.
 *
 * Composed of the areas *fill* and *border*, both of which have two possible styles:
 * - **High**
 * - **Low**. This is used for *AreaPoints* whose *high*-value is **lower** than the *low*-value.
 *
 * *AreaRangeSeries* are created with {@link ChartXY.addAreaRangeSeries}.
 * @public
 */
export declare class AreaRangeSeries extends RangeSeries implements ObservableXYData<AreaPoint>, DataInputHighLow {
    /**
     * Add point or array of points to the dataset.
     *
     * ```ts
     *  // Example syntax
     *  AreaRangeSeries.add({ position: 0, low: 10, high: 100 })
     *
     *  AreaRangeSeries.add([
     *      { position: 0, low: 100, high: 200 },
     *      { position: 10, low: 50, high: 220 },
     *      { position: 20, low: 75, high: 250 },
     *  ])
     * ```
     *
     * **Data gaps**
     *
     * When using {@link LineSeries}, {@link AreaSeries}, {@link AreaRangeSeries} or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  AreaRangeSeries.add([
     *      { position: 0, low: 10, high: 30 },
     *      { position: 1, low: 12, high: 32 },
     *      { position: 2, low: Number.NaN, high: Number.NaN },
     *      { position: 10, low: 15, high: 38 },
     *      { position: 11, low: 20, high: 35 },
     *      { position: 12, low: 18, high: 30 }
     *  ])
     * ```
     * @param points - Single new point or an array of new points.
     * @returns Series itself for fluent interface.
     * @public
     */
    add(data: AreaPoint | AreaPoint[]): this;
    /**
     * Add two individual Arrays, one for high values, and another for low values.
     * @param arrayHigh - Array of High values.
     * @param arrayLow - Array of Low values. Length should be equal to length of *array1*.
     * @returns Object itself for fluent interface.
     * @public
     */
    addArraysHighLow(arrayHigh: number[] | TypedArray, arrayLow: number[] | TypedArray, step?: number, start?: number): this;
    /**
     * Set fill style of high area of the Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaRangeSeries.setHighFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaRangeSeries.setHighFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * AreaRangeSeries.setHighFillStyle(emptyFill)
     * ```
     *
     * Supports following styles:
     * - {@link SolidFill}
     * - {@link LinearGradientFill}
     * - {@link RadialGradientFill}
     * - {@link PalettedFill} (x and y lookup modes)
     * - {@link emptyFill}
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setHighFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set fill style of low area of the Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaRangeSeries.setLowFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaRangeSeries.setLowFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * AreaRangeSeries.setLowFillStyle(emptyFill)
     * ```
     *
     * Supports following styles:
     * - {@link SolidFill}
     * - {@link LinearGradientFill}
     * - {@link RadialGradientFill}
     * - {@link PalettedFill} (x and y lookup modes)
     * - {@link emptyFill}
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setLowFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set style of the Series high stroke.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * AreaRangeSeries.setHighStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaRangeSeries.setHighStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaRangeSeries.setHighStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setHighStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Set style of the Series low stroke.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * AreaRangeSeries.setLowStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaRangeSeries.setLowStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaRangeSeries.setLowStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setLowStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get a current fill style used for the coloring of the high area in the series.
     * @returns Current fill style used for the coloring of the high area in the series.
     * @public
     */
    getHighFillStyle(): FillStyle;
    /**
     * Get a current fill style used for the coloring of the low area in the series.
     * @returns Current fill style used for the coloring of the low area in the series.
     * @public
     */
    getLowFillStyle(): FillStyle;
    /**
     * Get a current line style of a stroke used for the coloring of the high border in the series.
     * @returns Current line style of a stroke used for the coloring of the high border.
     * @public
     */
    getHighStrokeStyle(): LineStyle;
    /**
     * Get a current line style of a border used for the coloring of the low border in the series.
     * @returns Current line style of a border used for the coloring of the low border.
     * @public
     */
    getLowStrokeStyle(): LineStyle;
    /**
     * Attach object to an legendBox entry
     * @param entry - Object which has to be attached
     * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
     *                          when its respective Entry is clicked.
     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
     * @returns Series itself for fluent interface
     * @public
     */
    attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
}
/**
 * Interface for supplying readonly configurations to a {@link AreaRangeSeries}.
 * @public
 */
export declare interface AreaRangeSeriesOptions extends SeriesOptionsXY {
}
/**
 * Abstract super class for following series types:
 *
 * - {@link AreaSeriesPositive}
 * - {@link AreaSeriesNegative}
 * - {@link AreaSeriesBipolar}
 * @public
 */
export declare abstract class AreaSeries extends RangeSeries implements ObservableXYData<Point>, DataInputY {
    /**
     * Append a single `XY` coordinate or list of `XY` coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  AreaSeries.add({ x: 0, y: 100 })
     *
     *  AreaSeries.add([
     *      { x: 0, y: 100 },
     *      { x: 10, y: 50 },
     *      { x: 20, y: 75 },
     *  ])
     * ```
     *
     * For more methods of appending data into series, see:
     *
     * - {@link addArrayY} | Append only Y coordinates.
     *
     * **Data gaps**
     *
     * When using {@link LineSeries}, {@link AreaSeries} or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN` as either X or Y coordinate.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  AreaSeries.add([
     *      { x: 0, y: 10 },
     *      { x: 1, y: 12 },
     *      { x: 2, y: Number.NaN },
     *      { x: 3, y: 15 },
     *      { x: 4, y: 20 }
     *  ])
     * ```
     *
     * @param points - Single XY coordinate or list of coordinates.
     * @returns Object itself for fluent interface.
     * @public
     */
    add(points: Point | Point[]): this;
    /**
     * Append new data points into the series by only supplying Y coordinates.
     *
     * ```ts
     *  // Example syntax, number array
     *  AreaSeries.addArrayY([ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  AreaSeries.addArrayY(float32Array)
     * ```
     *
     * Each Y coordinate will be paired with an automatically generated X coordinate.
     *
     * By default, this continues from the last data point in the series.
     * However, the behavior of assigning X coordinates can be controlled with the optional `step` and `start` parameters.
     *
     * For more methods of appending data into series, see:
     *
     * - {@link add} | Append XY coordinates.
     *
     * **Data gaps**
     *
     * When using {@link LineSeries}, {@link AreaSeries} or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  AreaSeries.addArrayY([ 10, 12, Number.NaN, 15, 20 ])
     * ```
     *
     * @param arrayY - Array of Y-values.
     * @param step - Optional step between each X coordinate. Defaults to 1.
     * @param start - Optional value for first generated X-value. If undefined, will continue after last point's X value in series,
     *                  or 0 if there are no points in series.
     * @returns Object itself for fluent interface.
     * @public
     */
    addArrayY(arrayY: number[], step?: number, start?: number): this;
}
/**
 * Implementation of *SeriesXY* for visualizing a collection of progressive *Points* by
 * filling the area between the points *Y*-values and a static *baseline* value.
 *
 * This type of *AreaSeries* shows data on both sides of the *baseline*, and it has individual styles for each side:
 * *positive* and *negative*. Each side is also composed of the areas *fill* and *border*.
 *
 * *AreaSeriesBipolar* are created with {@link ChartXY.addAreaSeries} and selecting *AreaSeriesTypes.Bipolar*.
 * @public
 */
export declare class AreaSeriesBipolar extends AreaSeries {
    /**
     * Stores the last processed data-point.
     * It is required for construction of junction points to handle intersections with the baseline accurately.
     */
    private _lastHandledPoint?;
    /**
     * Set positive area style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesBipolar.setPositiveFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesBipolar.setPositiveFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * AreaSeriesBipolar.setPositiveFillStyle(emptyFill)
     * ```
     *
     * Supports following styles:
     * - {@link SolidFill}
     * - {@link LinearGradientFill}
     * - {@link RadialGradientFill}
     * - {@link PalettedFill} (x and y lookup modes)
     * - {@link emptyFill}
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setPositiveFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set negative area style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesBipolar.setNegativeFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesBipolar.setNegativeFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * AreaSeriesBipolar.setNegativeFillStyle(emptyFill)
     * ```
     *
     * Supports following styles:
     * - {@link SolidFill}
     * - {@link LinearGradientFill}
     * - {@link RadialGradientFill}
     * - {@link PalettedFill} (x and y lookup modes)
     * - {@link emptyFill}
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setNegativeFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set positive stroke style of Series.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * AreaSeriesBipolar.setPositiveStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaSeriesBipolar.setPositiveStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaSeriesBipolar.setPositiveStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setPositiveStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Set negative stroke style of Series.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * AreaSeriesBipolar.setNegativeStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaSeriesBipolar.setNegativeStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaSeriesBipolar.setNegativeStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setNegativeStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get a current fill style used for the coloring of the positive area in the series.
     * @returns Current fill style used for the coloring of the positive area in the series.
     * @public
     */
    getPositiveFillStyle(): FillStyle;
    /**
     * Get a current fill style used for the coloring of the negative area in the series.
     * @returns Current fill style used for the coloring of the negative area in the series.
     * @public
     */
    getNegativeFillStyle(): FillStyle;
    /**
     * Get a current line style of a stroke used for the coloring of the positive stroke in the series.
     * @returns Current line style of a stroke used for the coloring of the positive stroke.
     * @public
     */
    getPositiveStrokeStyle(): LineStyle;
    /**
     * Get a current line style of a border used for the coloring of the negative border in the series.
     * @returns Current line style of a border used for the coloring of the negative border.
     * @public
     */
    getNegativeStrokeStyle(): LineStyle;
    /**
     * Attach object to an legendBox entry
     * @param entry - Object which has to be attached
     * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
     *                          when its respective Entry is clicked.
     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
     * @returns Series itself for fluent interface
     * @public
     */
    attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
}
/**
 * The abstract class implements the most part of general logic for specific area series types.
 * These series use only one fill style and only one border.
 * All the derivative series implements their own logic for processing incoming data.
 * @public
 */
export declare abstract class AreaSeriesMonopolar extends AreaSeries {
    /**
     * Set fill style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesMonopolar.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesMonopolar.setFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * AreaSeriesMonopolar.setFillStyle(emptyFill)
     * ```
     *
     * Supports following styles:
     * - {@link SolidFill}
     * - {@link LinearGradientFill}
     * - {@link RadialGradientFill}
     * - {@link PalettedFill} (x and y lookup modes)
     * - {@link emptyFill}
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    abstract setFillStyle(fill: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set stroke style of Series.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * - {@link emptyLine}
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * AreaSeriesMonopolar.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * AreaSeriesMonopolar.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * AreaSeriesMonopolar.setStrokeStyle(transparentLine)
     * ```
     * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get a current fill style used for the coloring of an area in the series.
     * @returns Current fill style used for the coloring of an area in the series.
     * @public
     */
    abstract getFillStyle(): FillStyle;
    /**
     * Get a current style of a stroke used for the coloring of a series border.
     * @returns Current style of a stroke used for the coloring of a border.
     * @public
     */
    getStrokeStyle(): LineStyle;
}
/**
 * Implementation of *SeriesXY* for visualizing a collection of progressive *Points* by
 * filling the area between the points *Y*-values and a static *baseline* value.
 * This type of *AreaSeries* only shows data that is **below the baseline**.
 *
 * Composed of the areas *fill* and *border*.
 *
 * *AreaSeriesNegative* are created with {@link ChartXY.addAreaSeries} and selecting *AreaSeriesTypes.Negative*.
 * @public
 */
export declare class AreaSeriesNegative extends AreaSeriesMonopolar {
    /**
     * Set fill style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesNegative.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesNegative.setFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * AreaSeriesNegative.setFillStyle(emptyFill)
     * ```
     *
     * Supports following styles:
     * - {@link SolidFill}
     * - {@link LinearGradientFill}
     * - {@link RadialGradientFill}
     * - {@link PalettedFill} (x and y lookup modes)
     * - {@link emptyFill}
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get a current fill style used for the coloring of an area in the series.
     * @returns Current fill style used for the coloring of an area in the series.
     * @public
     */
    getFillStyle(): FillStyle;
    /**
     * Attach object to an legendBox entry
     * @param entry - Object which has to be attached
     * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
     *                          when its respective Entry is clicked.
     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
     * @returns Series itself for fluent interface
     * @public
     */
    attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
}
/**
 * Interface can be used to define the X and Y Axis that a series should be attached to,
 * a reference number used for comparison and type of area series.
 * @public
 */
export declare interface AreaSeriesOptions<AreaType extends AreaSeriesTypes> extends SeriesOptionsXY {
    /**
     * A fixed reference number.
     */
    baseline?: number;
    /**
     * Defines the type of area series. Selected option can enable/disable specific APIs!
     *
     * See {@link AreaSeriesTypes} for a collection of options.
     */
    type?: AreaType;
}
/**
 * Implementation of *SeriesXY* for visualizing a collection of progressive *Points* by
 * filling the area between the points *Y*-values and a static *baseline* value.
 * This type of *AreaSeries* only shows data that is **above the baseline**.
 *
 * Composed of the areas *fill* and *border*.
 *
 * *AreaSeriesPositive* are created with {@link ChartXY.addAreaSeries} and selecting *AreaSeriesTypes.Positive*.
 * @public
 */
export declare class AreaSeriesPositive extends AreaSeriesMonopolar {
    /**
     * Set fill style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * AreaSeriesPositive.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * AreaSeriesPositive.setFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden
     * AreaSeriesPositive.setFillStyle(emptyFill)
     * ```
     *
     * Supports following styles:
     * - {@link SolidFill}
     * - {@link LinearGradientFill}
     * - {@link RadialGradientFill}
     * - {@link PalettedFill} (x and y lookup modes)
     * - {@link emptyFill}
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Series itself for fluent interface.
     * @public
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get a current fill style used for the coloring of an area in the series.
     * @returns Current fill style used for the coloring of an area in the series.
     * @public
     */
    getFillStyle(): FillStyle;
    /**
     * Attach object to an legendBox entry
     * @param entry - Object which has to be attached
     * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
     *                          when its respective Entry is clicked.
     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
     * @returns Series itself for fluent interface
     * @public
     */
    attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
}
/**
 * Collection of *AreaSeries* implementations.
 *
 * Used when creating an *AreaSeries* with {@link ChartXY.addAreaSeries}.
 * Selected option tells what the returned *Series* type will be - different *Series* types can have different *API*s !
 *
 * - Select AreaSeriesTypes.Positive to show only area above the baseline.
 * - Select AreaSeriesTypes.Negative to show only area below the baseline.
 * - Select AreaSeriesTypes.Both to show both areas from both sides of the baseline.
 * @public
 */
export declare const AreaSeriesTypes: {
    /**
     * Type of *AreaSeries* that only shows data that is **above the baseline**.
     */
    Positive: typeof AreaSeriesPositive;
    /**
     * Type of *AreaSeries* that only shows data that is **below the baseline**.
     */
    Negative: typeof AreaSeriesNegative;
    /**
     * Type of *AreaSeries* that shows data on both sides of baseline.
     *
     * Has individual styles for positive/negative areas.
     */
    Bipolar: typeof AreaSeriesBipolar;
};
/**
 * Available Area Series types
 * @public
 */
export declare type AreaSeriesTypes = typeof AreaSeriesTypes[keyof typeof AreaSeriesTypes];
/**
 * Object which can be attached to a LegendBox
 * @public
 */
export declare interface Attachable {
    /**
     * Attach object to an legendBox entry
     * @param entry - Object which has to be attached
     * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
     *                          when its respective Entry is clicked.
     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
     * @public
     */
    attach(entry: LegendBoxEntry, toggleVisibilityOnClick: boolean, matchStyleExactly: boolean): this;
}
/**
 * Interface for extra type safety with Attachables that have LUT.
 * @public
 */
export declare interface AttachableWithLUT extends Attachable {
}
/**
 * Data structure of a territory of Australia.
 * @public
 */
export declare interface AustraliaTerritory {
    /**
     * Name of the territory. Eq. 'Queensland'. This is case insensitive.
     */
    name: string;
}
/**
 * DynamicCursors can change their positioning scale whenever.
 * @public
 */
export declare interface AutoCursor<ResultTableBackgroundType extends UIBackground = UIBackground> extends Cursor<ResultTableBackgroundType> {
    /**
     * Set is ResultTable auto text fill style enabled.
     * When enabled, text of ResultTable will be automatically filled based on pointed data.
     * @param enabled - Boolean flag
     * @returns Object itself
     * @remarks          When enabled, any fill style set operation on ResultTable might get overridden
     * @public
     */
    setResultTableAutoTextStyle(enabled: boolean): this;
    /**
     * Get is ResultTable auto text fill style enabled.
     * When enabled, text of ResultTable will be automatically filled based on pointed data.
     * @returns Boolean flag
     * @public
     */
    getResultTableAutoTextStyle(): boolean;
}
/**
 * Builder for auto-cursors without axes.
 * @public
 */
export declare class AutoCursor2DBuilder<ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorBuilder<ResultTableBackgroundType, AutoCursor<ResultTableBackgroundType>> implements AutoCursorBuilder<AutoCursor<ResultTableBackgroundType>> {
    /**
     * Create new CursorBuilder with an additional styler.
     * @param cursorStyler - Cursor styler function
     * @returns CursorBuilder of same type
     * @public
     */
    addStyler: (cursorStyler: CursorStyler<AutoCursor<ResultTableBackgroundType>>) => AutoCursor2DBuilder<ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different ResultTable Background.
     * @param resultTableBackgroundConstructor - Constructor for Background
     * @returns CursorBuilder of same type
     * @public
     */
    setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => AutoCursor2DBuilder<T>;
}
/**
 * Builder for auto cursors
 * @public
 */
declare interface AutoCursorBuilder<CursorType extends Cursor> {
}
/**
 * Collection of *AutoCursorBuilders*.
 *
 * *AutoCursorBuilder*s are used to modify structure of *AutoCursor*s of *Chart*s, by passing one when the *Chart* is created.
 *
 * Each item is associated with a specific *Chart*-type, that it can only be used with.
 * @public
 */
export declare const AutoCursorBuilders: {
    /**
     * *AutoCursorBuilder* for {@link ChartXY}.
     *
     * Used to modify structure of *AutoCursor*, by passing one when creating a {@link ChartXY}.
     */
    XY: AutoCursorXYBuilder;
    /**
     * *AutoCursorBuilder* for {@link SpiderChart}.
     *
     * Used to modify structure of *AutoCursor*, by passing one when creating a {@link SpiderChart}.
     */
    Spider: AutoCursor2DBuilder;
    /**
     * *AutoCursorBuilder* for {@link BarChart}.
     *
     * Used to modify structure of *AutoCursor*, by passing one when creating a {@link BarChart}.
     */
    BarChart: AutoCursor2DBuilder;
    /**
     * *AutoCursorBuilder* for {@link MapChart}.
     *
     * Used to modify structure of *AutoCursor*, by passing one when creating a {@link MapChart}.
     */
    Map: StaticCursor2DBuilder;
    /**
     * *AutoCursorBuilder* for {@link PolarChart}.
     *
     * Used to modify structure of *AutoCursor*, by passing one when creating a {@link PolarChart}.
     */
    Polar: AutoCursor2DBuilder;
};
/**
 * Collection of preset options for behavior of *chart AutoCursor*.
 *
 * Use with {@link ChartXY.setAutoCursorMode | `setAutoCursorMode`} method.
 *
 * ```typescript
 *  // Example, disable AutoCursor
 *  ChartXY.setAutoCursorMode(AutoCursorModes.disabled)
 * ```
 * @public
 */
export declare enum AutoCursorModes {
    /**
     * *AutoCursor* should be disabled.
     */
    disabled = 0,
    /**
     * *AutoCursor* will be active whenever users mouse is inside the *Chart*.
     *
     * It will snap to point at the closest data-point of a *Series* inside the *Chart*.
     */
    snapToClosest = 1,
    /**
     * *AutoCursor* will only be active when users mouse is directly pointing at a *Series* inside the *Chart*.
     */
    onHover = 2
}
/**
 * A type of CursorXY that can be plotted dynamically between different axes.
 * @public
 */
export declare interface AutoCursorXY<ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorXY<ResultTableBackgroundType>, AutoCursor<ResultTableBackgroundType> {
    /**
     * Set is TickMarkerX auto text fill style enabled.
     * When enabled, text of TickMarkerX will be automatically filled based on pointed data.
     * @param enabled - Boolean flag
     * @returns Object itself
     * @remarks          When enabled, any fill style set operation on TickMarkerX might get overridden
     * @public
     */
    setTickMarkerXAutoTextStyle(enabled: boolean): this;
    /**
     * Get is TickMarkerX auto text fill style enabled.
     * When enabled, text of TickMarkerX will be automatically filled based on pointed data.
     * @returns Boolean flag
     * @public
     */
    getTickMarkerXAutoTextStyle(): boolean;
    /**
     * Set is TickMarkerY auto text fill style enabled.
     * When enabled, text of TickMarkerY will be automatically filled based on pointed data.
     * @param enabled - Boolean flag
     * @returns Object itself
     * @remarks          When enabled, any fill style set operation on TickMarkerY might get overridden
     * @public
     */
    setTickMarkerYAutoTextStyle(enabled: boolean): this;
    /**
     * Get is TickMarkerY auto text fill style enabled.
     * When enabled, text of TickMarkerY will be automatically filled based on pointed data.
     * @returns Boolean flag
     * @public
     */
    getTickMarkerYAutoTextStyle(): boolean;
}
/**
 * Builder for *AutoCursor* of {@link ChartXY}.
 *
 * Used to modify structure of *AutoCursor*, by passing one when creating a {@link ChartXY}.
 * Reference from {@link AutoCursorBuilders | AutoCursorBuilders.XY}
 * @public
 */
export declare class AutoCursorXYBuilder<ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorBuilderXY<ResultTableBackgroundType, AutoCursorXY<ResultTableBackgroundType>> implements AutoCursorBuilder<CursorXY<ResultTableBackgroundType>> {
    /**
     * Create new CursorBuilder with an additional styler.
     * @param cursorStyler - Cursor styler function
     * @returns New builder with extended style
     * @public
     */
    addStyler: (cursorStyler: CursorStyler<AutoCursorXY<ResultTableBackgroundType>>) => AutoCursorXYBuilder<ResultTableBackgroundType>;
    /**
     * Create new CursorBuilder with a different ResultTable Background.
     * @param resultTableBackground - Constructor for Background
     * @returns New builder with different resultTable background
     * @public
     */
    setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackground: BackgroundConstructor<T>) => AutoCursorXYBuilder<T>;
}
/**
 * Interface for describing *auto dispose mode* of an UI element.
 *
 * Can be used to set a condition, where the UI element is automatically *disposed*, removing it from view.
 * Use with {@link UIElement.setAutoDispose}.
 *
 * ```ts
 *  // Example, remove UI element when it is larger than 20% of viewport.
 *  UIElement.setAutoDispose({
 *      type: 'max-width',
 *      maxWidth: 0.20,
 *  })
 * ```
 * @public
 */
export declare type AutoDisposeMode = undefined | {
    type: 'max-width';
    maxWidth: number;
} | {
    type: 'max-height';
    maxHeight: number;
};
/**
 * Collection of *AutoFitStrategyFactories*.
 *
 * Used with *AutoCursor*s and *Marker*s **setAutoFitStrategy()** to customize logic for keeping *ResultTable* in view.
 * @public
 */
export declare const AutoFitStrategies: AutoFitStrategiesCollection;
/**
 * @public
 */
declare interface AutoFitStrategiesCollection {
    Flip: <ResultTableBackgroundType extends UIBackground>(resultTable: InternalResultTable<ResultTableBackgroundType>, scale: ScaleXY) => Flip<ResultTableBackgroundType>;
    FontSize: (minimumFontSize: number, stepCount: number) => (resultTable: InternalResultTable, scale: ScaleXY) => FontSize<UIBackground>;
}
/**
 * Strategy that tries to automatically fit the ResultTable of Cursors into an arbitrary scale somehow.
 * AutoFitStrategy keeps track of its changes to the ResultTable and as such is aware if user has modified some relevant trait of it.
 * @public
 */
export declare abstract class AutoFitStrategy<ResultTableBackgroundType extends UIBackground> {
    /**
     * Attempt to auto-fit ResultTable to scale.
     * @returns True, when ResultTable fits the scale after auto-fit
     * @public
     */
    update(): boolean;
    /**
     * revert any changes that strategy has made to ResultTable.
     * @public
     */
    resetTable(): this;
}
/**
 * Type of factory for AutoFitStrategy.
 *
 * This is the type passed to Cursors to set auto-fitting strategy.
 * @param resultTable - ResultTable object to operate with
 * @param scale - Scale that ResultTable should fit inside
 * @public
 */
export declare type AutoFitStrategyFactory<ResultTableBackgroundType extends UIBackground> = (resultTable: ResultTable<ResultTableBackgroundType>, scale: ScaleXY) => AutoFitStrategy<ResultTableBackgroundType>;
/**
 * *Axis* is a child component of *ChartXY*. It defines a numeric range on a single plane (*X* or *Y*),
 * that will be used to scale attached *Series* to the *ChartXY*s viewport.
 *
 * The default `Axis` can be referenced with {@link ChartXY.getDefaultAxisX} and {@link ChartXY.getDefaultAxisY}.
 *
 * `ChartXY` doesn't have a limit on number of *axes*. Additional *axes* can be created with {@link ChartXY.addAxisX} and {@link ChartXY.addAxisY}.
 * Multiple *Axes* can be stacked on top of another, and *axes* can be positioned on either side of the *chart* (left, right, top, bottom, see {@link AxisOptions}).
 *
 * The visual components of *axis* are:
 * - Title. By default *axis* has no title. It can be enabled with {@link Axis.setTitle}.
 * - Axis line. A single horizontal line for *X axes*, and vertical line for *Y axes*. It can be styled with {@link Axis.setStrokeStyle}.
 * - [Ticks](#axis-ticks). Labels that help understand the data visualized along an axis.
 *   - [Numeric ticks](#numeric-ticks)
 *   - [Datetime ticks](#datetime-ticks)
 *   - [Custom ticks](#custom-ticks)
 *
 * - [Highlighters](#axis-highlighters). Can be used to highlight positions or areas on an *axis*.
 *
 * See [Scrolling and interval configuration](#axis-automatic-scrolling-and-axis-intervals-configuration) for detailed information about management of *axis interval*.
 *
 * #### Axis Ticks
 *
 * Ticks are labels attached to the *axis line* that visualize the progression of values along the *axis*. A tick consists of three individually stylable parts:
 * - Label (text)
 * - Tick line.
 * - Grid line.
 *
 * There are currently three different ways of managing axis ticks:
 * 1. Automatic numeric ticks (default).
 * 3. Automatic time ticks.
 * 2. Automatic datetime ticks.
 * 4. Custom ticks.
 *
 * ##### Numeric ticks
 *
 * Numeric ticks are enabled by default for all *axes*.
 * They are designed for depicting numeric values of all magnitudes.
 *
 * Configuring the ticks is done with {@link Axis.setTickStrategy}.
 *
 * ```typescript
 * Axis.setTickStrategy(AxisTickStrategies.Numeric, (strategy) => strategy
 *   // Configure NumericTickStrategy
 *   .setMinorFormattingFunction((tickPosition) => `X: ${tickPosition}`)
 *   .setMinorTickStyle((tickStyle: TickStyle) => tickStyle
 *     .setTickLength(12)
 *     .setTickPadding(2)
 *   )
 * )
 * ```
 *
 * Frequently used API:
 *
 * - {@link NumericTickStrategy.setMajorFormattingFunction} | set formatting of major ticks labels text.
 * - {@link NumericTickStrategy.setMinorFormattingFunction} | set formatting of minor ticks labels text.
 * - {@link NumericTickStrategy.setMajorTickStyle} | set style of major ticks.
 * - {@link NumericTickStrategy.setMinorTickStyle} | set style of minor ticks.
 *
 * For full list of configuration API, see {@link NumericTickStrategy}.
 *
 * Examples showcasing *numeric axes*:
 * - [Shared Axis example](https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0007-sharedAxis.html)
 *
 * ##### Time ticks
 *
 * Time ticks are designed for depicting time ranges between hundreds of hours to individual nanoseconds.
 *
 * They are enabled, as well as configured, with {@link Axis.setTickStrategy}.
 *
 * ```typescript
 * Axis.setTickStrategy(AxisTickStrategies.Time, (strategy) => strategy
 *   // Configure TimeTickStrategy
 *   .setMinorFormattingFunction((tickPosition) => `X: ${tickPosition}`)
 *   .setMinorTickStyle((tickStyle: TickStyle) => tickStyle
 *     .setTickLength(12)
 *     .setTickPadding(2)
 *   )
 * )
 * ```
 *
 * Frequently used API:
 *
 * - {@link TimeTickStrategy.setMajorTickStyle} | set style of major ticks.
 * - {@link TimeTickStrategy.setMinorTickStyle} | set style of minor ticks.
 *
 * For full list of configuration API, see {@link TimeTickStrategy}.
 *
 * Examples showcasing `TimeTickStrategy`:
 * - No listed examples as of yet.
 *
 * ##### Datetime ticks
 *
 * DateTime ticks are enabled, as well as configured, with {@link Axis.setTickStrategy}.
 *
 * ```typescript
 * Axis.setTickStrategy(AxisTickStrategies.DateTime, (strategy) => strategy
 *   // Configure DateTimeTickStrategy
 *   .setMinorTickStyle((tickStyle: TickStyle) => tickStyle
 *     .setTickLength(12)
 *     .setTickPadding(2)
 *   )
 * )
 * ```
 *
 * Frequently used API:
 * - {@link DateTimeTickStrategy.setMajorTickStyle} | set style of major ticks.
 * - {@link DateTimeTickStrategy.setMinorTickStyle} | set style of minor ticks.
 * - {@link DateTimeTickStrategy.setDateOrigin} | set date origin (required for most applications with zooming enabled).
 *
 * For full list of configuration API, see {@link DateTimeTickStrategy}.
 *
 * Examples showcasing *datetime axes*:
 * - [Datetime Axis example](https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0020-dateTimeAxis.html)
 *
 * ##### Custom ticks
 *
 * Automatic creation of ticks can be disabled with {@link Axis.setTickStrategy}:
 *
 * ```typescript
 * // Disable automatic axis ticks.
 * Axis.setTickStrategy(AxisTickStrategies.Empty)
 * ```
 *
 * *Custom ticks* can be created with {@link Axis.addCustomTick}:
 *
 * ```typescript
 * // Create custom ticks.
 * for (let x = 0; x < 100; x += 10) {
 *   const tick = Axis.addCustomTick(UIElementBuilders.AxisTickMajor)
 * }
 * ```
 *
 * Frequently used `CustomTick` API:
 * - {@link CustomTick.setValue} | configure position of tick on *axis*.
 * - {@link CustomTick.setTextFormatter} | configure text displayed by tick label using a callback function.
 * - {@link CustomTick.setTickLength} | configure length of tick line.
 * - {@link CustomTick.setGridStrokeStyle} | style tick grid line.
 * - {@link CustomTick.setMarker} | style tick label and/or tick line.
 * - {@link CustomTick.dispose} | destroy tick permanently
 *
 * Examples showcasing *custom axis ticks*:
 * - [Custom Axis Ticks example](https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0011-customTicksScrolling.html)
 *
 * #### Axis automatic scrolling and Axis intervals configuration
 *
 * *Axis interval* is the range of data values that are visible on the *Axis*, they are referred to as *start* and *end*.
 *
 * By default, all *axes* fit the interval automatically to reveal all attached *series*. This behavior is called *fitting scroll strategy*.
 *
 * Automatic scrolling behavior can be controlled by selecting the *scroll strategy*, with {@link Axis.setScrollStrategy}:
 *
 * ```typescript
 * // Select progressive scroll strategy.
 * Axis.setScrollStrategy(AxisScrollStrategies.progressive)
 * ```
 *
 * Following *scroll strategies* are supported:
 * - {@link AxisScrollStrategies | `AxisScrollStrategies.fitting`} (default) | axis will automatically scroll to contain the boundaries of all attached *series*.
 * - {@link AxisScrollStrategies | `AxisScrollStrategies.expansion`} | same as 'fitting', but will never decrease axis interval.
 * - {@link AxisScrollStrategies | `AxisScrollStrategies.progressive`} | axis will keep distance between *start* and *end* constant, and scroll to reveal series boundaries that go higher than active axis interval.
 * - {@link AxisScrollStrategies | `AxisScrollStrategies.regressive`} | axis will keep distance between *start* and *end* constant, and scroll to reveal series boundaries that go lower than active axis interval.
 * - `undefined` | automatic scrolling is disabled.
 *
 * Axis interval can be manually set with {@link Axis.setInterval}:
 *
 * ```typescript
 * // Axis start = 0, end = 100.
 * Axis.setInterval({ start: 0, end: 100 })
 * ```
 *
 * Setting Axis interval stops axis scrolling by default. To specify axis interval and keep auto scrolling enabled, use the optional `stopAxisAfter` parameter:
 * ```typescript
 * Axis.setInterval({ start: 0, end: 100, stopAxisAfter: false })
 * ```
 *
 * Frequently used methods:
 * - {@link Axis.setScrollStrategy} | configure automatic scrolling behavior.
 * - {@link Axis.setInterval} | configure active axis interval.
 * - {@link Axis.getInterval} | get active axis interval.
 * - {@link Axis.fit} | fit axis interval to contain all attached series boundaries.
 * - {@link Axis.stop} | stop automatic scrolling momentarily.
 * - {@link Axis.onIntervalChange} | trigger a custom action whenever axis scale changes.
 * - {@link Axis.setAnimationScroll} | Enable/disable automatic scrolling animation.
 *
 * ##### Axis interval limitations
 *
 * *LightningChart JS* is easily the market leader in zooming interactions and visualization resolution, and contrary to most chart libraries, we are open about axis zooming limits;
 *
 * "Axis zooming limits" refer to constraints on the magnitude of Axis interval, which is calculated as `Math.abs(end - start)`.
 * When the limit is reached, the Axis will not be able to zoom in and out further by programmatic calls ({@link Axis.setInterval}) or user interactions.
 *
 * The constraints are primarily affected by two factors:
 * - Active *Tick Strategy*.
 * - Axis type.
 *
 * Both of these factors have their own definition of support minimum and maximum Axis interval, and when combined the lesser values are used.
 * For example, if *Tick Strategy* would allow min interval of `0.001` and *Axis type* `0.005`, effectively the min interval would be `0.001`.
 *
 * The Axis interval limits imposed by each available *Tick Strategy* are documented at {@link AxisTickStrategies}.
 *
 * The Axis interval limits imposed by *Axis Type* are documented at {@link AxisOptions}.
 *
 * #### Axis highlighters
 *
 * Two kinds of *highlighters* are supported:
 * - {@link ConstantLine} | highlights a position on the Axis.
 * - {@link Band} | highlights a range on the Axis.
 *
 * Examples showcasing *axis highlighters*:
 * - [Bands and ConstantLines example](https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0701-bandsConstantlines.html)
 * @public
 */
export declare class Axis extends GenericAxis<LinearScale1D | LogarithmicScale1D, DimensionalAxisStrategy, Tick, _TickPlottingVariables, undefined> implements Validatable, StylableAxisLine, Hideable, HideableEvents {
    /**
     * Set *TickStrategy* of *Axis*.
     *
     * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
     * as well as the style of created ticks.
     *
     * **Example usage**:
     *
     * **DateTime Axis**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.DateTime )
     * ```
     *
     * **Disable automatic ticks completely**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Empty )
     * ```
     *
     * **Customized TickStrategy**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Numeric, ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *      .setNumericUnits( true )
     *      .setMajorTickStyle( ( tickStyle ) => tickStyle
     *          .setLabelFont( ( font ) => font
     *              .setWeight( 'bold' )
     *          )
     *      )
     *  )
     * ```
     *
     * **Type table for optional second parameter ('styler')**:
     *
     * | tickStrategy   | styler                                                        |
     * | :------------- | :------------------------------------------------------------ |
     * | 'Numeric'      | `( tickStrategy: **NumericTickStrategy** ) => tickStrategy`   |
     * | 'Time'         | `( tickStrategy: **TimeTickStrategy** ) => tickStrategy`      |
     * | 'DateTime'     | `( tickStrategy: **DateTimeTickStrategy** ) => tickStrategy`  |
     * | 'Empty'        | `undefined`                                                   |
     *
     *
     * @param tickStrategy - Selected TickStrategy.
     *                          See {@link AxisTickStrategies} for a collection of options.
     * @param styler - Optional callback that can be used to customize the *TickStrategy*.
     *                          The type of supplied *TickStrategy* object depends on what was supplied to 'tickStrategy' parameter;
     *                          See the above method documentation for a value table.
     * @returns Object itself for fluent interface.
     * @public
     */
    setTickStrategy<TickStrategy extends TickStrategyType>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
    /**
     * Get the currently used tick strategy
     * @public
     */
    getTickStrategy(): TickStrategyType;
    /**
     * Add a highlighter Band to the Axis.
     * A Band can be used to highlight an interval on the Axis.
     *
     * @param onTop - Is Band rendered above Series, or below. Default to above.
     * @returns Band object.
     * @public
     */
    addBand(onTop?: boolean): Band;
    /**
     * Add a highlighter ConstantLine to the Axis.
     * A ConstantLine can be used to highlight a specific value on the Axis.
     *
     * @param onTop - Is ConstantLine rendered above Series, or below. Default to above.
     * @returns ConstantLine object.
     * @public
     */
    addConstantLine(onTop?: boolean): ConstantLine;
    /**
     * Get all Highlighters of Axis.
     * @returns array of highlighters
     * @public
     */
    getHighlighters(): Highlighter[];
    /**
     * Add event listener to Mouse Click on Axis
     * @param clbk - Event listener for Mouse Click Event
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseClick: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Double Click on Axis
     * @param clbk - Event listener for Mouse Double Click Event
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseDoubleClick: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Down on Axis
     * @param clbk - Event listener for Mouse Down Event
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseDown: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Up on Axis
     * @param clbk - Event listener for Mouse Up Event
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseUp: (clbk: MouseEventHandler<this>) => Token;
    /**
     * Add event listener to Mouse Enter Event on Axis
     * @param clbk - Event listener function for Mouse Enter Event
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseEnter: (clbk: MouseEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Leave Event on Axis
     * @param clbk - Event listener function for Mouse Leave Event
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseLeave: (clbk: MouseEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Move on Axis
     * @param clbk - Event listener function for Mouse Move
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseMove: (clbk: MouseEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Wheel event on Axis
     * @param clbk - Event listener function for Mouse Wheel
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseWheel: (clbk: MouseWheelEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Drag Start event on Axis
     * @param clbk - Event listener function for Mouse Drag Start
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseDragStart: (clbk: MouseDragStartEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Drag event on Axis
     * @param clbk - Event listener function for Mouse Drag
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseDrag: (clbk: MouseDragEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Drag Stop event on Axis
     * @param clbk - Event listener function for Mouse Drag Stop
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaMouseDragStop: (clbk: MouseDragStopEventHandler<this>) => Token;
    /**
     *  Add event listener to Touch Start event on Axis
     * @param clbk - Event listener function for Touch Start
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaTouchStart: (clbk: TouchEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Touch event on Axis
     * @param clbk - Event listener function for Mouse Touch
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaTouch: (clbk: TouchEventHandler<this>) => Token;
    /**
     *  Add event listener to Mouse Touch Stop event on Axis
     * @param clbk - Event listener function for Mouse Touch Stop
     * @returns Token of subscription
     * @public
     */
    onAxisInteractionAreaTouchStop: (clbk: TouchEventHandler<this>) => Token;
    /**
     * Remove event listener from  Mouse Click event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseClick: (token: Token) => boolean;
    /**
     * Remove event listener from  Mouse Double Click event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseDoubleClick: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Down event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseDown: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Up event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseUp: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Enter event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseEnter: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Leave event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseLeave: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Move event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseMove: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Wheel event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseWheel: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Start event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseDragStart: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseDrag: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Drag Stop event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaMouseDragStop: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Touch Start event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaTouchStart: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Touch event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaTouch: (token: Token) => boolean;
    /**
     * Remove event listener from Mouse Touch Stop event
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offAxisInteractionAreaTouchStop: (token: Token) => boolean;
    /**
     * Set Axis *thickness* as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax,
     *  Axis.setThickness( 60 )
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: number): this;
    /**
     * Configure Axis *thickness* min/max limits as pixels.
     *
     * The thickness of Axis is calculated based on ticks, title, axis line, etc.
     * By setting `min` and/or `max` thickness, the size allocated for Axis can be restricted to desired limits.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax, set axis to at least 100 px thick, but allow larger axis thickness if labels are large, or other such scenario.
     *  Axis.setThickness({ min: 100, max: undefined })
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: {
        min?: number;
        max?: number;
    }): this;
    /**
     * Get Axis *thickness* min/max limits as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * By default, Axis has no thickness restrictions, so `getThickness` should return `{ min: undefined, max: undefined }`.
     *
     * @returns Actively configured Axis thickness limits as pixels.
     * @public
     */
    getThickness(): {
        min: number | undefined;
        max: number | undefined;
    };
    /**
     * Set enabled flags for all mouse-interactions on axis directly.
     * Does not affect chart mouse-interactions.
     * @param enabled - Boolean: are mouse-interactions enabled
     * @returns Axis itself for fluent interface
     * @public
     */
    setMouseInteractions(enabled: boolean): this;
    /**
     * Pan scale by pixel value delta.
     *
     * Used by ChartXY as well as Axis itself.
     * @param amount - Amount to shift scale of axis in pixels
     * @public
     */
    pan(amount: pixel): void;
    /**
     * Zoom scale from/to a position.
     *
     * Used by ChartXY as well as Axis itself.
     * @param referencePosition - Position to zoom towards or from on axis
     * @param zoomDirection - Amount and direction of zoom [-1, 1] as a guideline
     * @public
     */
    zoom(referencePosition: number, zoomDirection: number): void;
    /**
     * Add custom tick to Axis.
     * *Custom ticks* can be used to expand on default tick placement, or completely override Axis ticks placement with custom logic.
     *
     * Example usage:
     *
     * **Create custom tick, specify position on Axis and label text.**
     *
     * ```typescript
     *  const customTick = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
     *      .setValue(5)
     *      // Label text is specified with a callback function.
     *      // This example formats Axis positions with one fraction, like this: "5.0"
     *      .setTextFormatter((value) => value.toFixed(1))
     * ```
     *
     * **Select CustomTick Marker type.**
     *
     * ```typescript
     *  // CustomTick shape can be changed by supplying a tick marker builder.
     *  // The supported values are 'AxisTickMajor', 'AxisTickMinor' and 'PointableTextBox'
     *  const customTick1 = Axis.addCustomTick(UIElementBuilders.AxisTickMajor)
     *  const customTick2 = Axis.addCustomTick(UIElementBuilders.AxisTickMinor)
     *  const customTick3 = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
     * ```
     *
     * **Disable default ticks, and create custom positioned ticks.**
     *
     * ```typescript
     *  // Disable default Axis ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Empty)
     *
     *  // Create a bunch of custom positioned ticks.
     *  for (let x = 0; x <= 100; x += 10) {
     *      Axis.addCustomTick()
     *          .setValue(x)
     *  }
     * ```
     *
     * For more information, like styling *custom ticks*, see {@link CustomTick}.
     *
     * @param markerBuilder - Optional builder for *TickMarker* of CustomTick (tick line, label, possible background).
     *                          Possible values are: {@link UIElementBuilders | `UIElementBuilders.AxisTickMajor`}, {@link UIElementBuilders | `UIElementBuilders.AxisTickMinor`}, {@link UIElementBuilders | `UIElementBuilders.PointableTextBox`}.
     *                          Default is `AxisTickMajor`
     * @returns CustomTick.
     * @public
     */
    addCustomTick(markerBuilder?: UIElementBuilder<InternalTickMarker>): CustomTick;
    /**
     * Get position of axis on its chart as a %
     * @public
     */
    getUiPosition(): number;
    /**
     * Set style of Axis line stroke.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * - {@link emptyLine}
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  Axis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * **Supported fill styles:**
     *
     * {@link SolidFill}:
     *
     * Solid fill color.
     *
     * ```ts
     *  // Example, solid colored line.
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see {@link ColorRGBA}
     *
     * {@link PalettedFill}:
     *
     * Color line stroke dynamically based on `x` or `y` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 10, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see {@link LUT}.
     *
     * {@link LinearGradientFill}:
     *
     * Color line stroke with a linear configurable gradient palette.
     *
     * ```ts
     *  // Example, linear gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new LinearGradientFill()
     *  }))
     * ```
     *
     * To learn more about linear gradient configurations, see {@link LinearGradientFill}.
     *
     * {@link RadialGradientFill}:
     *
     * Color line stroke with a radial configurable gradient palette.
     *
     * ```ts
     *  // Example, radial gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new RadialGradientFill()
     *  }))
     * ```
     *
     * To learn more about radial gradient configurations, see {@link RadialGradientFill}.
     *
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Axis stroke as a LineStyle object
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Get style of axis overlay (shown only when interacting with mouse / touch).
     * @returns FillStyle object
     * @public
     */
    getOverlayStyle(): FillStyle;
    /**
     * Set style of axis overlay (shown only when interacting with mouse / touch).
     * @param style - FillStyle object or mutator to modify existing one
     * @public
     */
    setOverlayStyle(style: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set is mouse-interaction enabled:
     * Zooming by dragging on axis. (LMB)
     * @param enabled - Boolean flag
     * @public
     */
    setAxisInteractionZoomByDragging(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming by dragging on axis. (LMB)
     * @returns Boolean flag
     * @public
     */
    getAxisInteractionZoomByDragging(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Panning by dragging on axis. (RMB)
     * @param enabled - Boolean flag
     * @public
     */
    setAxisInteractionPanByDragging(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Panning by dragging on axis. (RMB)
     * @returns Boolean flag
     * @public
     */
    getAxisInteractionPanByDragging(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Zooming by mouse-wheeling on axis.
     * @param enabled - Boolean flag
     * @public
     */
    setAxisInteractionZoomByWheeling(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming by mouse-wheeling on axis.
     * @returns Boolean flag
     * @public
     */
    getAxisInteractionZoomByWheeling(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Release axis by double-clicking on axis.
     * @param enabled - Boolean flag
     * @public
     */
    setAxisInteractionReleaseByDoubleClicking(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Release axis by double-clicking on axis.
     * @returns Boolean flag
     * @public
     */
    getAxisInteractionReleaseByDoubleClicking(): boolean;
    /**
     * Set mouse style when hovering over axis area.
     * @param mouseStyle - Mouse-style preset name (see {@link MouseStyles})
     * @returns Object itself
     * @public
     */
    setAxisMouseHoverStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when hovering over axis area.
     * @returns Mouse-style preset name
     * @public
     */
    getAxisMouseHoverStyle(): string;
    /**
     * Set mouse style when panning axis.
     * @param mouseStyle - Mouse-style preset name (see {@link MouseStyles})
     * @returns Object itself
     * @public
     */
    setAxisMousePanStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when panning axis.
     * @returns Mouse-style preset name
     * @public
     */
    getAxisMousePanStyle(): string;
    /**
     * Set mouse style when zooming axis.
     * @param mouseStyle - Mouse-style preset name (see {@link MouseStyles})
     * @returns Object itself
     * @public
     */
    setAxisMouseZoomStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when zooming axis.
     * @returns Mouse-style preset name
     * @public
     */
    getAxisMouseZoomStyle(): string;
    /**
     * Set component highlight animations enabled or not.
     * For most components this is enabled by default.
     *
     * ```ts
     *  // Example usage, disable highlight animations.
     *  component.setAnimationHighlight(false)
     * ```
     *
     * @param   enabled    - Animation enabled?
     * @returns            Object itself
     */
    setAnimationHighlight(enabled: boolean): this;
    /**
     * Get component highlight animations enabled or not.
     *
     * @returns      Animation enabled?
     */
    getAnimationHighlight(): boolean;
    /**
     * @returns Padding after Axis title
     * @public
     */
    getTitleMargin(): number;
    /**
     * Specifies padding after Axis title.
     * This is only accounted when title is visible.
     * @param margin - Gap between the title and the next axis in pixels. Can also affect chart margins
     * @returns Axis itself for fluent interface
     * @public
     */
    setTitleMargin(margin: pixel): this;
    /**
     * @returns Axis nib stroke length in pixels
     * @public
     */
    getNibLength(): number;
    /**
     * Specifies Axis nib stroke length in pixels
     * @param length - Axis nib stroke length in pixels
     * @returns Axis itself for fluent interface
     * @public
     */
    setNibLength(length: pixel): this;
    /**
     * @returns nib stroke fillstyle as a Fillstyle object
     * @public
     */
    getNibStyle(): LineStyle;
    /**
     * Specifies Axis nibs StrokeStyle
     * @param style - LineStyle object or mutator to modify existing one
     * @returns Axis itself for fluent interface
     * @public
     */
    setNibStyle(style: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of nib overlay (shown only when interacting with mouse / touch).
     * @returns FillStyle object
     * @public
     */
    getNibOverlayStyle(): FillStyle;
    /**
     * Set style of nib overlay (shown only when interacting with mouse / touch).
     * @param style - FillStyle object or mutator to modify existing one
     * @public
     */
    setNibOverlayStyle(style: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Set ideal size of nib mouse-picking area in pixels.
     * @param size - Size in pixels
     * @returns Object itself
     * @public
     */
    setNibMousePickingAreaSize(size: pixel): this;
    /**
     * Get size of nib mouse-picking area in pixels.
     * @returns Size in pixels
     * @public
     */
    getNibMousePickingAreaSize(): number;
    /**
     * Set is mouse-interaction enabled:
     * Scaling by dragging on nib.
     * @param enabled - Boolean flag
     * @public
     */
    setNibInteractionScaleByDragging(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Scaling by dragging on nib.
     * @returns Boolean flag
     * @public
     */
    getNibInteractionScaleByDragging(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Scaling by mouse-wheeling on nib.
     * @param enabled - Boolean flag
     * @public
     */
    setNibInteractionScaleByWheeling(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Scaling by mouse-wheeling on nib.
     * @returns Boolean flag
     * @public
     */
    getNibInteractionScaleByWheeling(): boolean;
    /**
     * Set mouse style when hovering over nib area.
     * @param mouseStyle - Mouse-style preset name (see {@link MouseStyles})
     * @returns Object itself
     * @public
     */
    setNibMouseHoverStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when hovering over nib area.
     * @returns Mouse-style preset name
     * @public
     */
    getNibMouseHoverStyle(): string;
    /**
     * Set mouse style when scaling nib.
     * @param mouseStyle - Mouse-style preset name (see {@link MouseStyles})
     * @returns Object itself
     * @public
     */
    setNibMouseScaleStyle(mouseStyle?: string): this;
    /**
     * Get mouse style when hovering over nib area.
     * @returns Mouse-style preset name
     * @public
     */
    getNibMouseScaleStyle(): string;
    /**
     * Set all states of chart mouse interactions on axis at once.
     * @param enabled - Boolean flag
     * @public
     */
    setChartInteractions(enabled: boolean): this;
    /**
     * Set is mouse-interaction enabled:
     * Panning by dragging on chart.
     * @param enabled - Boolean flag
     * @public
     */
    setChartInteractionPanByDrag(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Panning by dragging on chart.
     * @returns Boolean flag
     * @public
     */
    getChartInteractionPanByDrag(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Zooming by mouse-wheeling on chart.
     * @param enabled - Boolean flag
     * @public
     */
    setChartInteractionZoomByWheel(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming by mouse-wheeling on chart.
     * @returns Boolean flag
     * @public
     */
    getChartInteractionZoomByWheel(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Zooming by capturing rectangle on chart.
     * @param enabled - Boolean flag
     * @public
     */
    setChartInteractionZoomByDrag(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Zooming by capturing rectangle on chart.
     * @returns Boolean flag
     * @public
     */
    getChartInteractionZoomByDrag(): boolean;
    /**
     * Set is mouse-interaction enabled:
     * Fitting by capturing rectangle on chart.
     * @param enabled - Boolean flag
     * @public
     */
    setChartInteractionFitByDrag(enabled: boolean): this;
    /**
     * Get is mouse-interaction enabled:
     * Fitting by capturing rectangle on chart.
     * @returns Boolean flag
     * @public
     */
    getChartInteractionFitByDrag(): boolean;
    /**
     * **Permanently** destroy the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @returns Object itself for fluent interface
     * @public
     */
    dispose(): this;
    /**
     * Subscribe `onDispose` event.
     * This event is triggered whenever the Axis is disposed.
     *
     * ```typescript
     *  // Example usage
     *
     * axis.onDispose(() => {
     *   console.log('axis was disposed')
     * })
     *
     * axis.dispose()
     * ```
     *
     * @param clbk - Event handler function
     * @returns Token of subscription
     * @public
     */
    onDispose(clbk: (obj: this) => void): Token;
    /**
     * Remove event listener from dispose event.
     * @param token - Token of event listener which has to be removed
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offDispose(token: Token): boolean;
    /**
     * Set element visibility.
     *
     * @param state - `true` when element should be visible and `false` when element should be hidden.
     * @returns Object itself.
     */
    setVisible(state: boolean): this;
    /**
     *  Disable/Enable all animations of the Chart.
     * @param animationsEnabled - Boolean value to enable/disable animations.
     * @returns Axis itself for fluent interface.
     * @public
     * @privateRemarks Override to also update highlight animation enabled status
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
}
/**
 * Three-dimensional Axis, that resides inside Chart3D.
 * Can be either X, Y or Z. There is always exactly one Axis3D object for each dimension in a Chart3D.
 *
 * *Axes* have automatic scrolling logic to fit attached *Series*.
 * This can be modified with {@link setScrollStrategy} method.
 *
 * *Axes* are associated with a title, which can be enabled with {@link setTitle} method.
 *
 * Axis ticks can be altered with {@link setTickStrategy} and {@link addCustomTick} methods.
 *
 * @public
 */
export declare class Axis3D extends GenericAxis<UnitScale, AxisStrategy3D, _Tick3D, _Tick3DPlottingVariables, _TickSpecificPlottingVariables> {
    /**
     * @public
     * @privateRemarks  Override property type
     */
    readonly chart: Chart3D;
    /**
     * Set *TickStrategy* of *Axis*.
     *
     * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
     * as well as the style of created ticks.
     *
     * **Example usage**:
     *
     * **DateTime Axis**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.DateTime )
     * ```
     *
     * **Disable automatic ticks completely**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Empty )
     * ```
     *
     * **Customized TickStrategy**:
     * ```javascript
     *  Axis.setTickStrategy( AxisTickStrategies.Numeric, ( tickStrategy: NumericTickStrategy ) => tickStrategy
     *      .setNumericUnits( true )
     *      .setMajorTickStyle( ( tickStyle ) => tickStyle
     *          .setLabelFont( ( font ) => font
     *              .setWeight( 'bold' )
     *          )
     *      )
     *  )
     * ```
     *
     * **Type table for optional second parameter ('styler')**:
     *
     * | tickStrategy   | styler                                                        |
     * | :------------- | :------------------------------------------------------------ |
     * | 'Numeric'      | `( tickStrategy: **NumericTickStrategy** ) => tickStrategy`   |
     * | 'Time'         | `( tickStrategy: **TimeTickStrategy** ) => tickStrategy`      |
     * | 'DateTime'     | `( tickStrategy: **DateTimeTickStrategy** ) => tickStrategy`  |
     * | 'Empty'        | `undefined`                                                   |
     *
     *
     * @param tickStrategy - Selected TickStrategy.
     *                          See {@link AxisTickStrategies} for a collection of options.
     * @param styler - Optional callback that can be used to customize the *TickStrategy*.
     *                          The type of supplied *TickStrategy* object depends on what was supplied to 'tickStrategy' parameter;
     *                          See the above method documentation for a value table.
     * @returns Object itself for fluent interface.
     * @public
     */
    setTickStrategy<TickStrategy extends TickStrategyType>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
    /**
     * Get the currently used tick strategy
     * @public
     */
    getTickStrategy(): TickStrategyType;
    /**
     * Add an end user managed tick to the axis.
     *
     * Custom ticks are just like default ticks, except they can be completely controlled by the end user.
     *
     * ```ts
     *  // Example
     *  const customTick = Axis3D.addCustomTick()
     *      // Tick position on Axis.
     *      .setValue(100)
     *      .setTextFormatter((value) => `Custom tick at ${value.toFixed(1)}`)
     * ```
     *
     * For full set of configuration API, see {@link CustomTick3D}.
     *
     * @returns     CustomTick3D.
     * @public
     */
    addCustomTick(): CustomTick3D;
    /**
     * Set style of Axis line stroke.
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  Axis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * **Supported fill styles:**
     *
     * {@link SolidFill}:
     *
     * Solid fill color.
     *
     * ```ts
     *  // Example, solid colored line.
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * To learn more about available *Color* factories, see {@link ColorRGBA}
     *
     * {@link PalettedFill}:
     *
     * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
     *
     * ```ts
     *  // Example, dynamic color by Y coordinates
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new PalettedFill({
     *          lookUpProperty: 'y',
     *          lut: new LUT({
     *              interpolate: true,
     *              steps: [
     *                  { value: 0, color: ColorRGBA(255, 0, 0) },
     *                  { value: 10, color: ColorRGBA(0, 255, 0) },
     *              ]
     *          })
     *      })
     *  }))
     * ```
     *
     * To learn more about Color lookup tables, see {@link LUT}.
     *
     * {@link LinearGradientFill}:
     *
     * Color line stroke with a linear configurable gradient palette.
     *
     * ```ts
     *  // Example, linear gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new LinearGradientFill()
     *  }))
     * ```
     *
     * To learn more about linear gradient configurations, see {@link LinearGradientFill}.
     *
     * {@link RadialGradientFill}:
     *
     * Color line stroke with a radial configurable gradient palette.
     *
     * ```ts
     *  // Example, radial gradient line color
     *  Axis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new RadialGradientFill()
     *  }))
     * ```
     *
     * To learn more about radial gradient configurations, see {@link RadialGradientFill}.
     *
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Style of Axis line.
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Enable / disable all interactions of Axis.
     * @param enabled - Interactions enabled or not.
     * @returns Object itself for fluent interface.
     * @public
     */
    setMouseInteractions(enabled: boolean): this;
    /**
     * Set element visibility.
     *
     * @param state - `true` when element should be visible and `false` when element should be hidden.
     * @returns Object itself.
     * @public
     */
    setVisible(state: boolean): this;
}
/**
 * Interval info for an Axis
 * @public
 */
export declare interface AxisInterval {
    /**
     * The start value of the axis scale interval.
     */
    start: number;
    /**
     * The end value of the axis scale interval.
     */
    end: number;
}
/**
 * Parameters for {@link Axis.setInterval} method.
 *
 * Examples:
 *
 * ```ts
 *  // Set interval start and end.
 *  Axis.setInterval({ start: 0, end: 5000 })
 * ```
 *
 * ```ts
 *  // Set interval end only.
 *  Axis.setInterval({ end: 5000 })
 * ```
 *
 * ```ts
 *  // Set interval but don't stop the axis from scrolling
 *  Axis.setInterval({ start: 0, end: 5000, stopAxisAfter: false })
 * ```
 *
 * ```ts
 *  // Set interval with 2000 milliseconds long animation
 *  Axis.setInterval({ start: 0, end: 5000, animate: 2000 })
 * ```
 *
 * @public
 */
declare interface AxisIntervalConfiguration {
    /**
     * Axis interval start.
     *
     * For X axis this refers to LEFT, while for Y axis this refers to BOTTOM.
     */
    start?: number;
    /**
     * Axis interval end.
     *
     * For X axis this refers to RIGHT, while for Y axis this refers to TOP.
     */
    end?: number;
    /**
     * Should the change in axis interval be animated or not?
     *
     * Defaults to `false`.
     *
     * - `false` -\> Don't animate
     * - `true` -\> Default animation
     * - `1000` or other number -\> Animate with this duration as milliseconds
     */
    animate?: number | boolean;
    /**
     * Should the axis scrolling be stopped after applying the interval?
     *
     * Defaults to `true`.
     *
     * If `true`, whatever the active scroll strategy of the Axis is, it will not override the applied axis interval until the axis is released.
     */
    stopAxisAfter?: boolean;
}
/**
 * Interface for specifying Axis (XY) configurations that can't be changed after creation of the Axis.
 *
 * **Example usage**:
 *
 * - Configure default Y Axis of chart on opposite side to default configuration (right).
 *
 * ```typescript
 *  ChartXY({
 *      defaultAxisY: {
 *          opposite: true,
 *      }
 *  })
 * ```
 *
 * - Configure default X Axis of chart as logarithmic (10 base).
 *
 * ```typescript
 *  ChartXY({
 *      defaultAxisX: {
 *          type: 'logarithmic',
 *          base: 10,
 *      }
 *  })
 * ```
 *
 * - Configure newly created X Axis of chart as logarithmic (natural base).
 *
 * ```typescript
 *  ChartXY.addAxisX({
 *      type: 'logarithmic',
 *      base: 'natural',
 *  })
 * ```
 *
 * NOTE: Some series / features do not support all available non-default Axis types (logarithmic, high precision, ..).
 *
 * Additionally, there can be further limitations in combinations of two Axis types.
 * For example, as of now `logarithmic` and `linear-highPrecision` can't be combined as X + Y Axes.
 *
 * Refer to documentation of {@link AxisOptions."type"} for detailed information.
 * @public
 */
export declare interface AxisOptions {
    /**
     * Specify Axis position in chart.
     *
     * Default is bottom for X Axes, and left for Y Axes.
     *
     * Setting to `true` will result in the opposite side (top for X Axes, right for Y Axes).
     */
    opposite?: boolean;
    /**
     * Type of Axis.
     *
     * Each type section contains information about related Axis zooming limits,
     * as in constraints on the magnitude of Axis interval, which is calculated as `Math.abs(end - start)`.
     * When the limit is reached, the Axis will not be able to zoom in and out further by programmatic calls ({@link Axis.setInterval}) or user interactions.
     *
     * `linear`:
     *
     * Default Axis type. Same behavior as `type: undefined`.
     *
     * Achievable zoom range depends on the magnitude of Axis interval start;
     * Following table contains *reference values* on the achievable zoom ranges - in practice zoom range might be limited sooner or later.
     *
     * | Axis interval start | Min interval | Max interval |
     * | :------------------ | :----------- | :----------- |
     * | `0`                 | `1e-4`       | `1e+16`       |
     * | `100`               | `1e-2`       | `1e+16`       |
     * | `10 000`            | `1.00`       | `1e+16`       |
     * | `1 000 000`         | `100`        | `1e+16`       |
     * | `Date.now()` (UNIX) | `73600000`   | `1e+16`       |
     *
     * `logarithmic`:
     *
     * Logarithmic Axis. By default base number will be `10`.
     *
     * With Logarithmic Axis, **range must always start above 0!** (log is not defined at 0).
     *
     * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
     *
     * List of series that support logarithmic Axes:
     * - {@link LineSeries}
     * - {@link PointSeries}
     * - {@link PointLineSeries}
     * - {@link StepSeries}
     * - {@link SplineSeries}
     * - {@link AreaSeries}
     * - {@link AreaRangeSeries}
     * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
     * - {@link RectangleSeries}
     * - {@link SegmentSeries}
     *
     * List of series that do **not** support logarithmic Axes:
     * - {@link HeatmapGridSeriesIntensityValues}
     * - {@link HeatmapScrollingGridSeriesIntensityValues}
     *
     * As of yet `logarithmic` and `linear-highPrecision` can't be combined as X + Y Axes.
     *
     * `linear-highPrecision`:
     *
     * Behaves otherwise similarly as `linear`, but zoom range is significantly improved, with the drawback of a considerable performance drop.
     *
     * Achievable zoom range depends on the magnitude of Axis interval start;
     * Following table contains *reference values* on the achievable zoom ranges - in practice zoom range might be limited sooner or later.
     *
     * | Axis interval start | Min interval | Max interval |
     * | :------------------ | :----------- | :----------- |
     * | `0`                 | `1e-12`      | `1e+30`      |
     * | `100`               | `1e-10`      | `1e+30`      |
     * | `10 000`            | `1e-8`       | `1e+30`      |
     * | `1 000 000`         | `1e-6`       | `1e+30`      |
     * | `Date.now()` (UNIX) | `1.00`       | `1e+30`      |
     *
     * NOTE: Not all series types support high precision axes! Attaching a non-supported Series will crash the application.
     *
     * List of series that support high precision Axes:
     * - {@link LineSeries}
     * - {@link PointSeries}
     * - {@link PointLineSeries}
     * - {@link StepSeries}
     * - {@link SplineSeries}
     * - {@link AreaSeries}
     * - {@link AreaRangeSeries}
     * - {@link OHLCSeries}
     * - {@link RectangleSeries}
     * - {@link SegmentSeries}
     *
     * List of series that do **not** support high precision Axes:
     * - {@link HeatmapGridSeriesIntensityValues}
     * - {@link HeatmapScrollingGridSeriesIntensityValues}
     *
     * As of yet `logarithmic` and `linear-highPrecision` can't be combined as X + Y Axes.
     *
     * **High precision Axis is an experimental feature**, which means that it can be significantly altered in minor version releases.
     */
    type?: 'linear' | 'logarithmic' | 'linear-highPrecision';
    /**
     * Specification of Logarithmic Base number (e.g. 10, 2, natural log).
     *
     * Defaults to 10 if omitted.
     *
     * Examples:
     *
     * - `10` | powers of ten (1, 10, 100, 1000, 10000, ...).
     * - `e`  | natural logarithm (1e, 2e, 3e, 4e, ...)
     *
     * `type` must be set to `'logarithmic'` for this to effect!
     */
    base?: number | 'E' | 'e' | 'natural';
}
/**
 * Axis positioning Enum
 * @public
 */
export declare enum AxisPosition {
    Top = 0,
    Bottom = 1,
    Left = 2,
    Right = 3
}
/**
 * Object that describes an Axis interval (start, end).
 * @public
 */
declare interface AxisScale {
    /**
     * Get Scale start value.
     * @returns number.
     * @public
     */
    getInnerStart(): number;
    /**
     * Get Scale end value.
     * @returns number.
     * @public
     */
    getInnerEnd(): number;
}
/**
 * Collection of available *AxisScrollStrategies*.
 *
 * *AxisScrollStrategies* can be used to customize the behavior of *Axis scrolling*.
 *
 * Use with {@link Axis.setScrollStrategy}
 * @public
 */
export declare const AxisScrollStrategies: {
    /**
     * *Axis* will constantly scroll to fit attached *Series*.
     * @public
     */
    fitting: AxisScrollStrategy;
    /**
     * *Axis* will scroll to fit *Series* that are out of view, but it won't shrink even if there is empty space (like "fitting" does).
     * @public
     */
    expansion: AxisScrollStrategy;
    /**
     * *Axis* will scroll to show new, **progressive** data, but will keep its interval constant - leaving older data out of view.
     * @public
     */
    progressive: AxisScrollStrategy;
    /**
     * *Axis* will scroll to show new, **regressive** data, but will keep its interval constant - leaving older data out of view.
     * @public
     */
    regressive: AxisScrollStrategy;
};
/**
 * Type of a scroll strategy.
 * Consists of two scrolling functions:
 * 'start' and 'end'
 * @public
 */
export declare interface AxisScrollStrategy {
    /**
     * Scroll function for 'start' value.
     * Scrolls from interval 'scaleStart' - 'scaleEnd' according to 'contentMin' - 'contentMax' taking 'interpolation' into account
     * @param scaleStart - 'start' value of starting scale (not necessarily min!)
     * @param scaleEnd - 'end' value of starting scale (not necessarily max!)
     * @param contentMin - Minimum value of content to scroll according to
     * @param contentMax - Maximum value of content to scroll according to
     * @returns 'start' of resulting scale
     * @public
     */
    start: (scaleStart: number, scaleEnd: number, contentMin: number, contentMax: number) => number;
    /**
     * Scroll function for 'end' value.
     * Scrolls from interval 'scaleStart' - 'scaleEnd' according to 'contentMin' - 'contentMax' taking 'interpolation' into account
     * @param scaleStart - 'start' value of starting scale (not necessarily min!)
     * @param scaleEnd - 'end' value of starting scale (not necessarily max!)
     * @param contentMin - Minimum value of content to scroll according to
     * @param contentMax - Maximum value of content to scroll according to
     * @returns 'end' of resulting scale
     * @public
     */
    end: (scaleStart: number, scaleEnd: number, contentMin: number, contentMax: number) => number;
}
/**
 * Interface that describes state of Axis, as in is it scrolling, is user panning it, etc.
 *
 * Used for passing realtime Axis information to rendering Engine for application and situation specific optimizations.
 * @public
 */
declare interface AxisState {
}
/**
 * Interface for a strategy which defines Axis dimension
 * @public
 */
declare interface AxisStrategy extends AbstractAxisStrategy {
    /**
     * Mouse style when dragging over axis
     * @public
     */
    readonly defaultDragMouseStyle: string;
    /**
     * Used internally for rendering the axis title text at a specified angle
     * @param direction - Axis direction factor
     * @returns Configured title text rotation in degrees
     * @public
     */
    readonly getTitleTextRotation: (direction: 1 | -1) => number;
}
/**
 * Interface for a strategy which represents the logic that is different between X, Y and Z Axes.
 * @public
 */
export declare interface AxisStrategy3D extends AbstractAxisStrategy {
}
/**
 * Collection of available *AxisTickStrategies*.
 *
 * *AxisTickStrategies* modify logic of drawing *Axis Ticks* and formatting to better suit different user applications.
 * For example, a *DateTime Axis* is created by selecting `AxisTickStrategies.DateTime`.
 * @public
 */
export declare const AxisTickStrategies: {
    /**
     * Disables all automatic creation of Axis ticks.
     *
     * *CustomTicks* can still be created manually.
     *
     * Example usage:
     *
     * ```typescript
     * Axis.setTickStrategy( AxisTickStrategies.Empty )
     * ```
     */
    Empty: "Empty";
    /**
     * *Axis Tick Strategy* that is designed for depicting numeric values of all magnitudes.
     *
     * **`NumericTickStrategy` is the default selection for all Axes**.
     *
     * Axis interval ranges supported by `NumericTickStrategy`:
     * - Minimum: `10e-9`
     * - Maximum: Unlimited.
     *
     * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
     *
     * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks
     *      // All methods of `NumericTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * For configuration API, see {@link NumericTickStrategy}.
     */
    Numeric: "Numeric";
    /**
     * *Axis Tick Strategy* that is designed for depicting date and time.
     *
     * Axis values are interpreted as UNIX timestamps similarly as with JavaScript Date API.
     *
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
     *
     * Axis interval ranges supported by `DateTimeTickStrategy`:
     * - Minimum: 1 second (`1000`).
     * - Maximum: 1000 years (*really big number*).
     *
     * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
     *
     * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks
     *      // All methods of `DateTimeTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * For configuration API, see {@link DateTimeTickStrategy}.
     */
    DateTime: "DateTime";
    /**
     * *Axis Tick Strategy* that is designed for depicting time ranges between hundreds of hours to individual nanoseconds.
     *
     * Axis values are interpreted as milliseconds, for example:
     * - `0` -\> `00:00:00`
     * - `1 000` -\> `00:00:01`
     * - `3 600 000` -\> `01:00:00`
     * - `1` -\> `00:00:00.001`
     * - `0.001` -\> `00:00:00.000001`
     *
     * **When `TimeTickStrategy` is active, Axis interval will be always restricted to max. 100 hours interval and min. 100 nanoseconds interval.**
     *
     * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks
     *      // All methods of `TimeTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * For configuration API, see {@link TimeTickStrategy}.
     */
    Time: "Time";
};
/**
 * Type of Background constructor
 * @public
 */
declare type BackgroundConstructor<T extends UIBackground = UIBackground> = new (layer: unknown, renderingScale: unknown, scale: unknown, remove: unknown, theme: unknown) => T;
/**
 * Axis Highlighter that highlights an interval on the Axis.
 * @public
 */
export declare class Band extends Highlighter {
    /**
     * Set start value of Band. This is in values of its owning Axis.
     * @param valueStart - Value on Axis.
     * @returns Object itself for fluent interface.
     * @public
     */
    setValueStart(valueStart: number): this;
    /**
     * Get start value of Band. This is in values of its owning Axis.
     * @returns Value on Axis.
     * @public
     */
    getValueStart(): number;
    /**
     * Set end value of Band. This is in values of its owning Axis.
     * @param valueEnd - Value on Axis.
     * @returns Object itself for fluent interface.
     * @public
     */
    setValueEnd(valueEnd: number): this;
    /**
     * Get end value of Band. This is in values of its owning Axis.
     * @returns Value on Axis.
     * @public
     */
    getValueEnd(): number;
    /**
     * Set fill style of Band.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * Band.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * Band.setFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * Band.setFillStyle(transparentFill)
     * ```
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Band.
     * @returns Normal FillStyle
     * @public
     */
    getFillStyle(): FillStyle;
    /**
     * Set stroke style of Band.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link emptyLine}
     *
     * Example usage:
     *```javascript
     * // Specified SolidLine
     * Band.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * Band.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * Band.setStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
     * @returns Chart itself
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Band.
     * @returns Normal StrokeStyle
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Subscribe to value change event.
     *
     * This event is called whenever the position of the *Band* is changed via either **Band.setValueStart/End** or user interactions.
     * @param handler - Function that is called when event is triggered.
     * @param band - Band itself.
     * @param start - New 'start' position of Band.
     * @param end - New 'end' position of Band.
     * @returns Token that can be used to unsubscribe from the event.
     * @public
     */
    onValueChange(handler: (band: this, start: number, end: number) => void): Token;
    /**
     * Unsubscribe from value change event.
     *
     * This event is called whenever the position of the *Band* is changed via either **Band.setValueStart/End** or user interactions.
     * @param token - Token that was received when the subscription was created.
     * @returns True if unsubscription was successful.
     * @public
     */
    offValueChange(token: Token): boolean;
    /**
     * Attach object to an legendBox entry
     * @param entry - Object which has to be attached
     * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
     *                          when its respective Entry is clicked.
     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
     * @returns Object itself for fluent interface
     * @public
     */
    attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
}
/**
 * Chart type for visualizing categorical data as Bars.
 * Supports Positive and Negative data sets (baseline 0), and Bipolar data sets. These are automatically detected.
 *
 * `BarChart` can be created in two different ways - to learn more about creation time configuration of `BarChart`, please refer to:
 * - {@link LightningChart.BarChart} (stand-alone chart).
 * - {@link Dashboard.createBarChart} (chart inside *dashboard*).
 *
 * **BarChart features**
 *
 * 1. Axes
 *
 * `BarChart` has a Category Axis and Value Axis.
 * These can be referenced with {@link BarChart.categoryAxis} and {@link BarChart.valueAxis} properties.
 * For their available APIs, see {@link BarChartCategoryAxis} and {@link BarChartValueAxis} respectively.
 *
 * 2. Data input
 *
 * `BarChart` supports a handful of different syntaxes for data input.
 * See {@link BarChart.setData} for more details.
 *
 * 3. AutoCursor
 *
 * *Auto cursor* is activated when the users mouse is over a bar.
 * It displays information about the hovered bar to the user over the chart in a *result table*.
 *
 * *Auto cursor* can be configured in a variety of ways;
 * - {@link BarChart.setAutoCursorMode} | set auto cursor behavior.
 * - {@link BarChart.setAutoCursor} | style auto cursor.
 * - {@link BarChart.setCursorResultTableFormatter} | configure formatting of *result table* contents.
 *
 * 4. LegendBox
 *
 * `BarChart` has built-in *legend box* functionality for listing the bars in a *user interface*.
 * The *legend box* also provides additional logic, like hiding selected *series* by clicking on the *legend box*.
 *
 * *Legend box* is added using {@link BarChart.addLegendBox}.
 *
 * 5. Title
 *
 * `BarChart` has a built-in *title* component, which can be configured using {@link BarChart.setTitle}.
 *
 * 6. Backgrounds
 *
 * `BarChart` contains two separate *background* components:
 * - *Background* ({@link BarChart.setBackgroundFillStyle}).
 * - *Series Background* ({@link BarChart.setSeriesBackgroundFillStyle}).
 *
 * 7. UI Elements
 *
 * Custom *UI elements* can be placed on `BarChart` in same way as all other *charts*, using {@link BarChart.addUIElement}.
 *
 * 8. Sorting
 *
 * `BarChart` has built-in sorting functionality, which can be configured with {@link BarChart.setSorting}.
 *
 * 9. Bar styling
 *
 * Each bar in `BarChart` can be individually styled. See {@link BarChartBar} for more details.
 *
 * **Other APIs worthy of mention:**
 *
 * - Labels can be configured with {@link BarChart.setCategoryLabels}, {@link BarChart.setValueLabels} and {@link BarChart.setLabelFittingEnabled}.
 * - Empty space around `BarChart` can be configured with {@link BarChart.setPadding}.
 * - Additional margin around *chart title* can be configured with {@link BarChart.setTitleMargin}.
 * - All animations can be conveniently controlled with {@link BarChart.setAnimationsEnabled}.
 * - `BarChart` can be removed permanently with {@link BarChart.dispose}.
 * - Some useful events that can be subscribed to:
 *      * *Resize events* ({@link BarChart.onResize}).
 *      * *Background events* ({@link BarChart.onBackgroundMouseMove}).
 *      * *Series Background events* ({@link BarChart.onSeriesBackgroundMouseMove}).
 *
 * @public
 */
export declare class BarChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<BarChartBar> implements ChartWithCursor<CursorResultTableBackgroundType> {
    /**
     * Selector for coordinate system of the Bars.
     *
     * This selector can be used for translating locations relative to Bars to other coordinate systems and vice versa.
     *
     * For example, in order to:
     * - Position LCJS UI elements in relative to Bar locations.
     * - Find client coordinate relative to a Bar, for example to position external HTML content above them.
     * - etc.
     *
     * See {@link translateCoordinate} for more detailed use case information and example usage.
     *
     * @public
     */
    readonly coordsBars: CoordinateSystemBarChart;
    /**
     * Reference to the Value Axis of bar chart.
     * @public
     */
    readonly valueAxis: BarChartValueAxis;
    /**
     * Reference to the Category Axis of bar chart.
     * @public
     */
    readonly categoryAxis: BarChartCategoryAxis;
    /**
     * Get series of a chart
     * @returns Array of series
     * @public
     */
    getSeries(): BarChartBar[];
    /**
     * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, style AutoCursor ResultTable.
     *  barChart.setAutoCursor((autoCursor) => autoCursor
     *      .setResultTable((resultTable) => resultTable
     *          .setOrigin(UIOrigins.LeftTop)
     *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     *          .setTextFont((font) => font
     *              .setSize(12)
     *              .setFamily('sans-serif')
     *          )
     *          .setBackground((background) => background
     *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
     *          )
     *      )
     *  )
     * ```
     *
     * ```typescript
     *  // Example 2, style AutoCursor PointMarker.
     *  barChart.setAutoCursor((autoCursor) => autoCursor
     *      .setPointMarker((marker) => marker
     *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     *          .setSize({ x: 10, y: 10 })
     *          .setStrokeStyle(emptyLine),
     *      ),
     *  )
     * ```
     * @param mutator - Callback function that receives reference to the charts `AutoCursor`.
     * @returns Object itself for fluent interface.
     * @public
     */
    setAutoCursor(mutator: Mutator<AutoCursor<CursorResultTableBackgroundType>>): this;
    /**
     * Get reference to charts `AutoCursor`.
     *
     * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
     *
     * @returns `AutoCursor`.
     * @public
     */
    getAutoCursor(): AutoCursor<CursorResultTableBackgroundType>;
    /**
     * Set chart `AutoCursor` behavior, by selecting a preset option from {@link AutoCursorModes}.
     *
     * Possible values:
     * - `AutoCursorModes.snapToClosest` (default) | *AutoCursor* snaps to closest data point from mouse location.
     * - `AutoCursorModes.onHover` | *AutoCursor* is only shown when it is directly over a *series*. NOTE: Series mouse interactions must be enabled for this to work!
     * - `AutoCursorModes.disabled` | *AutoCursor* is disabled
     *
     * ```typescript
     *  // Example, disable AutoCursor
     *  barChart.setAutoCursorMode(AutoCursorModes.disabled)
     * ```
     *
     * **Related information:**
     *
     * On *series* level, *AutoCursor* behavior can be configured individually for each *series*, and there are also more *series* specific options available.
     * Here is `LineSeries` for example:
     *
     * - {@link Series2D.setCursorEnabled} | configure whether cursor should pick on the series or not.
     * - {@link SeriesXY.setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
     * - {@link LineSeries.setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
     * - {@link SeriesXY.setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
     *
     * @param mode - Selection of *AutoCursor* behavior.
     * @returns Object itself for fluent interface.
     * @public
     */
    setAutoCursorMode(mode: AutoCursorModes): this;
    /**
     * Get `AutoCursor` behavior, from a collection of preset options ({@link AutoCursorModes}).
     * @returns Active selection of *AutoCursor* behavior.
     * @public
     */
    getAutoCursorMode(): AutoCursorModes;
    /**
     * Set *ResultTable* formatter. Can be used to specify the information that is displayed, when hovering mouse/pointer
     * over a Bar.
     *
     * ```ts
     *  // Example usage
     *  barChart.setCursorResultTableFormatter((builder, category, value, bar) => builder
     *      .addRow('Category:', '', category)
     *      .addRow('Value:', '', bar.chart.valueAxis.formatValue(value))
     *  )
     * ```
     *
     * @param formatter - Function which builds ResultTable content.
     *                      See definition of {@link BarChartResultTableFormatter} for supplied formatting information.
     * @returns Object itself
     * @public
     */
    setCursorResultTableFormatter(formatter: BarChartResultTableFormatter): this;
    /**
     * Set margin around each bar along category axis as percentage of the bar thickness.
     * For example, `0.1` = on both left and right side of bar there is a 10% margin.
     * Actual thickness of bar depends on chart size, but for 100 px bar that would be 10 px + 10 px margin.
     *
     * Valid value range is between [0, 0.49].
     *
     * ```ts
     *  // Example, no margin between bars.
     *  BarChart.setBarsMargin(0)
     * ```
     *
     * ```ts
     *  // Example, increased space between bars.
     *  BarChart.setBarsMargin(0.20)
     * ```
     *
     * @param   margin - Margin around each bar along category axis as percentage of bar thickness.
     * @returns     Object itself.
     * @public
     */
    setBarsMargin(margin: number): this;
    /**
     * Get margin around each bar along category axis as percentage of the bar thickness.
     * For example, `0.1` = on both left and right side of bar there is a 10% margin.
     * Actual thickness of bar depends on chart size, but for 100 px bar that would be 10 px + 10 px margin.
     *
     * Valid value range is between [0, 0.49].
     *
     * @returns     Margin around each bar along category axis as percentage of bar thickness.
     * @public
     */
    getBarsMargin(): number;
    /**
     * Set theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * @param enabled - Theme effect enabled
     * @returns          Object itself.
     * @public
     * @privateRemarks  Override
     */
    setBarsEffect(enabled: boolean): this;
    /**
     * Get theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
     * @public
     */
    getBarsEffect(): boolean;
    /**
     * Set `BarChart` data, updating the visible bars.
     *
     * This method signature takes in an array of objects with `category` and optional `value` properties.
     *
     * ```ts
     *  // Example usage
     *  barChart.setData([
     *      { category: 'Category 1', value: 10 },
     *      { category: 'Category 2', value: 12 },
     *  ])
     * ```
     *
     * In use cases with real-time updates, the recommended way to push value updates to existing bars is to call `setData` again.
     *
     * @param   arg     - Array of objects with category and value properties.
     * @returns         Object itself
     * @public
     */
    setData(arg: {
        category: string;
        value?: number;
    }[]): this;
    /**
     * Set `BarChart` data, updating the visible bars.
     *
     * This method signature takes a single object that can have any number of keys.
     * Each key is interpreted as a category, and the respective value as the bar value.
     *
     * ```ts
     *  // Example usage
     *  barChart.setData({
     *      'Category 1': 10,
     *      'Category 2': 12,
     *  })
     * ```
     *
     * In use cases with real-time updates, the recommended way to push value updates to existing bars is to call `setData` again.
     *
     * @param   arg     - Object with string keys and number values.
     * @returns         Object itself
     * @public
     */
    setData(arg: {
        [key: string]: unknown;
    }): this;
    /**
     * Set `BarChart` data, updating the visible bars.
     *
     * This method signature takes an array of numbers, where each number is a value for a bar.
     * In this case, each bar is just assigned an automatic category like "Category 1".
     *
     * ```ts
     *  // Example usage
     *  barChart.setData([10, 12])
     * ```
     *
     * In use cases with real-time updates, the recommended way to push value updates to existing bars is to call `setData` again.
     *
     * @param   arg     - Number array of bar values.
     * @returns         Object itself
     * @public
     */
    setData(arg: number[]): this;
    /**
     * Set `BarChart` data, updating the visible bars.
     *
     * This method signature takes in an array of strings as Categories, without any Values.
     * It can be used to initialize the categories before data is available, for example to show the bars in a LegendBox:
     *
     * ```ts
     *  // Data is not yet available, but prepare legend.
     *  barChart.setData(categories)
     *  const legend = barChart.addLegendBox().add(barChart)
     * ```
     *
     * @param   arg     - Array of strings as categories
     * @returns         Object itself
     * @public
     */
    setData(arg: string[]): this;
    /**
     * Configure how category labels are displayed in the `BarChart`.
     * To see all configuration options, see {@link BarChartCategoryLabels}.
     *
     * To display labels inside or after bars, see {@link setValueLabels}.
     *
     * ```ts
     *  // Example, hide labels
     *  barChart.setCategoryLabels(undefined)
     * ```
     *
     * ```ts
     *  // Example, change label color
     *  barChart.setCategoryLabels({
     *      labelFillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  })
     * ```
     *
     * ```ts
     *  // Example, change label font size. In this case, the previous label configuration is used as a reference so callback function is convenient.
     *  barChart.setCategoryLabels((labels) => ({
     *      labelFont: labels.labelFont.setSize(10)
     *  }))
     * ```
     *
     * ```ts
     *  // Example, configure formatting
     *  barChart.setCategoryLabels({
     *      formatter: (bar, category, value) => `${category} (${(value / 1000).toFixed(1)} k)`,
     *  })
     * ```
     *
     * - To learn more of font configurations, see {@link FontSettings}.
     * - To learn more of fill style configurations, see {@link FillStyle}.
     * - To disable automatic label fitting, use {@link setLabelFittingEnabled}.
     *
     * @param   config - `undefined` to hide labels, or alternatively a valid {@link BarChartCategoryLabels} configuration OR a callback function which receives the current label configuration and returns a new one to use.
     * @returns     Object itself.
     * @public
     */
    setCategoryLabels(config: undefined | Partial<BarChartCategoryLabels> | ImmutableMutator<BarChartCategoryLabels, Partial<BarChartCategoryLabels>>): this;
    /**
     * Get current category labels configuration.
     * @returns     BarChartCategoryLabels object or undefined if labels are hidden.
     * @public
     */
    getCategoryLabels(): BarChartCategoryLabels | undefined;
    /**
     * Configure how value labels are displayed in the `BarChart`.
     *
     * There are a handful of different value label positioning types in `BarChart`, which you can find in {@link BarChartValueLabels}.
     * Labels can also be separately displayed before bars on the other side of category axis, see {@link setCategoryLabels}.
     *
     * ```ts
     *  // Example, hide labels
     *  barChart.setValueLabels(undefined)
     * ```
     *
     * ```ts
     *  // Example, display value labels after bars
     *  barChart.setValueLabels({
     *      position: 'after-bar'
     *  })
     * ```
     *
     * ```ts
     *  // Example, display value labels inside bars with black color
     *  barChart.setValueLabels({
     *      position: 'inside-bar',
     *      labelFillStyle: new SolidFill({ color: ColorRGBA(0, 0, 0) })
     *  })
     * ```
     *
     * ```ts
     *  // Example, change label font size. In this case, the previous label configuration is used as a reference so callback function is convenient.
     *  barChart.setValueLabels((labels) => ({
     *      labelFont: labels.labelFont.setSize(10)
     *  }))
     * ```
     *
     * ```ts
     *  // Example, configure formatting
     *  barChart.setValueLabels({
     *      formatter: (bar, category, value) => `${category} (${(value / 1000).toFixed(1)} k)`,
     *  })
     * ```
     *
     * - To learn more of font configurations, see {@link FontSettings}.
     * - To learn more of fill style configurations, see {@link FillStyle}.
     * - To disable automatic label fitting, use {@link setLabelFittingEnabled}.
     *
     * @param   config - `undefined` to hide labels, or alternatively a valid {@link BarChartValueLabels} configuration OR a callback function which receives the current label configuration and returns a new one to use.
     * @returns     Object itself.
     * @public
     */
    setValueLabels(config: undefined | Partial<BarChartValueLabels> | ImmutableMutator<BarChartValueLabels, Partial<BarChartValueLabels>>): this;
    /**
     * Get current value labels configuration.
     * @returns     BarChartValueLabels object or undefined if labels are hidden.
     * @public
     */
    getValueLabels(): BarChartValueLabels | undefined;
    /**
     * Enable or disable automatic label fitting.
     *
     * This is enabled by default.
     *
     * ```ts
     *  // Example, disable automatic label fitting
     *  barChart.setLabelFittingEnabled(false)
     * ```
     * @param   enabled - true or false.
     * @returns     Object itself.
     * @public
     */
    setLabelFittingEnabled(enabled: boolean): this;
    /**
     * Get state of automatic label fitting.
     *
     * This is enabled by default.
     *
     * @returns     true or false
     * @public
     */
    getLabelFittingEnabled(): boolean;
    /**
     * Get reference to a particular {@link BarChartBar}.
     * The match is done against the `category` of bars.
     *
     * ```ts
     *  // Example
     *  barChart.setData([
     *      { category: 'Category 1', value: 10 },
     *      { category: 'Category 2', value: 12 },
     *  ])
     *  const bar = barChart.getBar('Category 1')
     * ```
     *
     * This method throws an error if the Bar is not found.
     *
     * @param   category - Category that is attempted to match against existing bars.
     * @returns     Reference to the BarChartBar with matching category.
     * @public
     */
    getBar(category: string): BarChartBar;
    /**
     * Get reference to all currently existing {@link BarChartBar}s.
     *
     * @returns     Array with all existing BarChartBar references.
     * @public
     */
    getBars(): BarChartBar[];
    /**
     * Configure automatic sorting of bars.
     *
     * The default value is {@link BarChartSorting.Descending}.
     *
     * ```ts
     *  // Example, disable sorting
     *  barChart.setSorting(BarChartSorting.None)
     * ```
     *
     * ```ts
     *  // Example, ascending sorting
     *  barChart.setSorting(BarChartSorting.Ascending)
     * ```
     *
     * ```ts
     *  // Example, descending sorting
     *  barChart.setSorting(BarChartSorting.Descending)
     * ```
     *
     * ```ts
     *  // Example, alphabetical sorting
     *  barChart.setSorting(BarChartSorting.Alphabetical)
     * ```
     *
     * ```ts
     *  // Example, custom sorting (ascending implementation)
     *  barChart.setSorting((a, b) => a.value - b.value)
     * ```
     *
     * @param   sorter - Sorting function or undefined to disable sorting.
     * @returns     Object itself.
     * @public
     */
    setSorting(sorter: undefined | BarChartSorter): this;
    /**
     * Get current sorting configuration.
     * @returns     undefined or {@link BarChartSorter}.
     * @public
     */
    getSorting(): undefined | BarChartSorter;
    /**
     * Enable/disable animation of bar category positions.
     * This is enabled by default.
     *
     * ```ts
     *  // Example, disable category position animation.
     *  BarChart.setAnimationCategoryPosition(false)
     * ```
     * @param   enabled -   Boolean
     * @param   speedMultiplier     - Optional multiplier for category animation speed. `1` matches default speed.
     * @returns     Object itself.
     */
    setAnimationCategoryPosition(enabled: boolean, speedMultiplier?: number): this;
    /**
     * Enable/disable animation of bar values.
     * This is enabled by default.
     *
     * ```ts
     *  // Example, disable value animation.
     *  BarChart.setAnimationValues(false)
     * ```
     * @param   enabled -   Boolean
     * @param   speedMultiplier     - Optional multiplier for animation speed. `1` matches default speed.
     * @returns     Object itself.
     */
    setAnimationValues(enabled: boolean, speedMultiplier?: number): this;
    /**
     * Translate a coordinate in HTML client coordinate system to another coordinate system.
     *
     * **(1) bars coordinate system:**
     *
     * ```ts
     *  BarChart.onSeriesBackgroundMouseClick((_, event) => {
     *      const locationBars = chart.translateCoordinate(event, chart.coordsBars)
     *      // locationBars tells the clicked location relative to Bar Chart value and category axes.
     *  })
     * ```
     *
     * **(2) relative control coordinate system:**
     *
     * ```ts
     *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
     *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
     *  // locationRelative is in pixels relative to bottom left corner of the chart
     * ```
     *
     * Relative coordinates can be used for positioning LightningChart JS UI components:
     *
     * ```ts
     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
     *      .setOrigin(UIOrigins.LeftBottom)
     *      .setPosition({ x: 20, y: 20 })
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     */
    translateCoordinate<T extends CoordinateSystemRelative | CoordinateSystemBarChart>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : T extends CoordinateSystemBarChart ? CoordinateBarChart : never;
    /**
     * Translate a coordinate in Bars coordinate system to another coordinate system.
     *
     * **(1) HTML client coordinate system:**
     *
     * ```ts
     *  const locationBars = { iCategory: 0, value: 100 }
     *  const locationClient = chart.translateCoordinate(locationBars, chart.client)
     * ```
     *
     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
     *
     * ```ts
     *  myHTMLElement.style.position = 'absolute'
     *  myHTMLElement.style.left = locationClient.clientX
     *  myHTMLElement.style.top = locationClient.clientY
     * ```
     *
     * **(2) relative control coordinate system:**
     *
     * ```ts
     *  const locationBars = { iCategory: 0, value: 100 }
     *  const locationRelative = chart.translateCoordinate(locationBars, chart.coordsRelative)
     *  // locationRelative is in pixels relative to bottom left corner of the chart
     * ```
     *
     * Relative coordinates can be used for positioning LightningChart JS UI components:
     *
     * ```ts
     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
     *      .setOrigin(UIOrigins.LeftBottom)
     *      .setPosition({ x: 20, y: 20 })
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     */
    translateCoordinate<T extends CoordinateSystemRelative | CoordinateSystemClient>(coordinate: CoordinateBarChart, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : T extends CoordinateSystemClient ? CoordinateClient : never;
    /**
     * Translate a coordinate from relative control coordinates to another coordinate system.
     *
     * ```ts
     *  // 10 pixels left and 20 pixels up from controls bottom left corner
     *  const locationRelative = { x: 10, y: 20 }
     *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
     * ```
     *
     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
     *
     * ```ts
     *  myHTMLElement.style.position = 'absolute'
     *  myHTMLElement.style.left = locationClient.clientX
     *  myHTMLElement.style.top = locationClient.clientY
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     */
    translateCoordinate<T extends CoordinateSystemBarChart | CoordinateSystemClient>(coordinate: CoordinateXY, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : T extends CoordinateSystemBarChart ? CoordinateBarChart : never;
    /**
     * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
     *
     * ```ts
     *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
     *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
     *  // locationRelative is in pixels relative to bottom left corner of the chart
     * ```
     *
     * Relative coordinates can be used for positioning LightningChart JS UI components:
     *
     * ```ts
     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
     *      .setOrigin(UIOrigins.LeftBottom)
     *      .setPosition({ x: 20, y: 20 })
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     * @privateRemarks  This is a super method signature. It has to also be listed here to satisfy TypeScript even though it adds no additional functionality to the previous signatures.
     */
    translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
    /**
     * Translate a coordinate from relative control coordinates to HTML client coordinate system.
     *
     * ```ts
     *  // 10 pixels left and 20 pixels up from controls bottom left corner
     *  const locationRelative = { x: 10, y: 20 }
     *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
     * ```
     *
     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
     *
     * ```ts
     *  myHTMLElement.style.position = 'absolute'
     *  myHTMLElement.style.left = locationClient.clientX
     *  myHTMLElement.style.top = locationClient.clientY
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     * @privateRemarks  This is a super method signature. It has to also be listed here to satisfy TypeScript even though it adds no additional functionality to the previous signatures.
     */
    translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
    /**
     * Disable/Enable all animations of the Chart.
     * @param animationsEnabled - Boolean value to enable or disable animations.
     * @returns Chart itself for fluent interface.
     * @public
     * @privateRemarks  Override
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * **NOTE: BarChart does not support this method.**
     * You can track when mouse moves over a bar using mouse enter events, etc. {@link BarChartBar.onMouseEnter}.
     *
     * Solves the nearest data-point from series inside Chart of a given coordinate on screen
     * @param location - Location on screen or omit for cur mouse location
     * @returns Undefined or data-structure for positioning of markers (and cursors)
     * @public
     * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
     */
    solveNearest(location?: Point): CursorPoint | undefined;
    /**
     * **NOTE: BarChart does not support this method.**
     * You can track when mouse moves over a bar using mouse enter events, etc. {@link BarChartBar.onMouseEnter}.
     *
     * Method for solving the nearest data point from all existing series relative to a given coordinate on screen.
     *
     * ```ts
     *  // Example usage, from mouse move event.
     *  barChart.onSeriesBackgroundMouseMove((_, event) => {
     *      const result = barChart.solveNearest(event)
     *  })
     * ```
     *
     * ```ts
     *  // Example usage, arbitrary coordinate on client coordinate system.
     *  const result = barChart.solveNearest({ clientX: 100, clientY: 200 })
     * ```
     *
     * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
     *
     * @param   location -  Location in HTML client coordinates.
     * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
     * @public
     */
    solveNearest(location?: CoordinateClient): CursorPoint | undefined;
    /**
     * **Permanently** destroy the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...BarChart()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @returns Object itself for fluent interface
     * @public
     */
    dispose(): this;
    /**
     * Get minimum size of Chart.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @returns Vec2 minimum size or undefined if unimplemented
     */
    getMinimumSize(): Point | undefined;
}
/**
 * End user reference to 1 Bar in a {@link BarChart}
 *
 * Reference to a `BarChartBar` can be fetched using {@link BarChartBar.getBar} or {@link BarChartBar.getBars} methods.
 *
 * Possibly useful methods:
 *  - {@link BarChartBar.setFillStyle} | set fill style
 *  - {@link BarChartBar.setStrokeStyle} | set border style
 *  - {@link BarChartBar.onMouseClick} | Add events to interactions on a specific bar
 *
 * Changing bar values, or removing bars should be generally done directly using {@link BarChart.setData} method, rather than methods of `BarChartBar`!
 * However, it is also possible to directly change value of an existing bar with {@link BarChartBar.setValue}.
 *
 * @public
 */
export declare class BarChartBar extends Series2D<CursorPoint> implements _InternalSeriesWithCursor {
    /**
     * The category of the bar, as parsed through user input to {@link BarChart.setData} method.
     * @public
     */
    readonly category: string;
    /**
     * @public
     */
    readonly chart: BarChart;
    /**
     * Set value of the Bar.
     *
     * This can also be achieved with {@link BarChart.setData}.
     *
     * @param   value - New value for the bar.
     * @public
     */
    setValue(value: number): this;
    /**
     * Get value of the bar.
     * @returns     Value of the bar.
     * @public
     */
    getValue(): number;
    /**
     * @public
     */
    get value(): number;
    /**
     * Set fill style of the Bar.
     *
     * ```ts
     *  // Example usage
     *  bar.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
     * ```
     *
     * - To learn more of fill styles, see {@link FillStyle}.
     * - For highlighting use cases, you can also use {@link setHighlight}.
     *
     * @param   value - FillStyle or callback function which takes current fill style and returns a new one.
     * @returns     Object itself.
     * @public
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of the Bar.
     * @returns     FillStyle.
     * @public
     */
    getFillStyle(): FillStyle;
    /**
     * Set border style of the Bar.
     *
     * ```ts
     *  // Example usage
     *  bar.setStrokeStyle(new SolidLine({
     *      thickness: 1,
     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
     *  }))
     * ```
     *
     * ```ts
     *  // Example, remove border
     *  bar.setStrokeStyle(emptyLine)
     * ```
     *
     * - To learn more of line styles, see {@link LineStyle}.
     *
     * @param   value - LineStyle or callback function which takes current line style and returns a new one.
     * @returns     Object itself.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get border style of the Bar.
     * @returns     LineStyle.
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * **NOTE: BarChartBar does not support this method.**
     * You can track when mouse moves over a bar using mouse enter events, etc. {@link onMouseEnter}.
     * @public
     */
    solveNearestFromScreen(location: CoordinateClient): undefined;
    /**
     * **NOTE: BarChartBar does not support this method.**
     * You can track when mouse moves over a bar using mouse enter events, etc. {@link onMouseEnter}.
     * @public
     */
    solveNearestFromScreen(location: Point): undefined;
    /**
     * Set theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * **NOTE: Disabling/Enabling effects on 1 Bar currently results in same action applied to ALL Bars in the same chart. This can not be prevented at the moment.**
     *
     * @param enabled - Theme effect enabled
     * @returns          Object itself.
     * @public
     * @privateRemarks  Override
     */
    setEffect(enabled: boolean): this;
}
/**
 * Class that represents a {@link BarChart}s Category Axis.
 * It can be accessed through {@link BarChart.categoryAxis} property, and provides methods for configuring axis style and title.
 *
 * Useful methods:
 * - {@link setTitle} | set title text
 * - {@link setTitleFillStyle} | set title fill style
 * - {@link setTitleFont} | set title font
 * - {@link setStrokeStyle} | set style of axis line
 * @public
 */
export declare class BarChartCategoryAxis extends GenericAxis<LinearScale1D, AbstractAxisStrategy, _AbstractAxisTick, _AbstractTickPlottingVariables, {}> {
    /**
     * Set Axis *thickness* as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax,
     *  Axis.setThickness( 60 )
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: number): this;
    /**
     * Configure Axis *thickness* min/max limits as pixels.
     *
     * The thickness of Axis is calculated based on ticks, title, axis line, etc.
     * By setting `min` and/or `max` thickness, the size allocated for Axis can be restricted to desired limits.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax, set axis to at least 100 px thick, but allow larger axis thickness if labels are large, or other such scenario.
     *  Axis.setThickness({ min: 100, max: undefined })
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: {
        min?: number;
        max?: number;
    }): this;
    /**
     * Get Axis *thickness* min/max limits as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * By default, Axis has no thickness restrictions, so `getThickness` should return `{ min: undefined, max: undefined }`.
     *
     * @returns Actively configured Axis thickness limits as pixels.
     * @public
     */
    getThickness(): {
        min: number | undefined;
        max: number | undefined;
    };
    /**
     * Set style of Axis line stroke.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * - {@link emptyLine}
     *
     * ```ts
     *  // Example syntax, hide axis line
     *  barChart.categoryAxis.setStrokeStyle(emptyLine)
     * ```
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  barChart.categoryAxis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  barChart.categoryAxis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * - To learn more about line styles, see {@link LineStyle}.
     * - Sometimes the axis stroke style is confused together with the border style of {@link BarChart.setSeriesBackgroundStrokeStyle | series background border}
     *
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Axis stroke style as a LineStyle object
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Enable / disable all interactions of Axis.
     * @param enabled - Interactions enabled or not.
     * @returns Object itself for fluent interface.
     * @public
     */
    setMouseInteractions(enabled: boolean): this;
}
/**
 * Interface for configuration of Bar Chart category labels.
 *
 * Used with {@link BarChart.setCategoryLabels}.
 * @public
 */
export declare interface BarChartCategoryLabels {
    /**
     * Label text formatter.
     * See {@link BarChartLabelFormatter} for examples.
     */
    formatter: BarChartLabelFormatter;
    /**
     * Label fill style.
     * See {@link FillStyle} for examples.
     */
    labelFillStyle: FillStyle;
    /**
     * Label font.
     * See {@link FontSettings} for examples.
     */
    labelFont: FontSettings;
    /**
     * Pixels margin before label.
     */
    labelMargin: number;
    /**
     * Label rotation as degrees.
     */
    labelRotation: number;
    /**
     * Tick line style.
     * See {@link LineStyle} for examples.
     */
    tickStyle: LineStyle;
    /**
     * Length of tick line as pixels.
     */
    tickLength: number;
}
/**
 * Interface that can be used to define {@link BarChart} configurations, when inside a {@link Dashboard},
 * that can't be changed after creation.
 * @public
 */
export declare interface BarChartDashboardOptions extends DashboardCellOptions, BarChartOptions {
}
/**
 * Type definition for a function that formats text displayed in bar chart labels.
 *
 * See examples in {@link BarChart.setCategoryLabels} and {@link BarChart.setValueLabels}.
 * @public
 */
export declare type BarChartLabelFormatter = (bar: BarChartBar, category: string, value: number) => string;
/**
 * Interface for readonly configuration of {@link BarChart}.
 *
 * Some properties of `BarChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
 *
 * ```typescript
 *  // Example, configure bar chart orientation.
 *  const chart = lightningChart().BarChart({
 *      type: BarChartTypes.Horizontal
 *  })
 * ```
 *
 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
 *
 * For *standalone* `BarChart`, more parameters are documented in {@link LightningChart.BarChart}.
 *
 * For *dashboard* `BarChart`, more parameters are documented in {@link Dashboard.createBarChart}.
 *
 *
 * **Commonly used properties:**
 *
 * - {@link BarChartOptions.theme}: Specify chart color *theme*.
 * - {@link BarChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
 * - {@link BarChartOptions.type}: Configure bar chart orientation.
 *
 * **Example usage:**
 *
 * ```typescript
 *  // Example 1, create chart with default configuration.
 *  const chart = lightningChart().BarChart({})
 * ```
 *
 * ```typescript
 *  // Example 2, create chart with specified color theme.
 *  const chart = lightningChart().BarChart({
 *      theme: Themes.light,
 *  })
 * ```
 *
 * ```typescript
 *  // Example 3, create chart with specified orientation
 *  const chart = lightningChart().BarChart({
 *      type: BarChartTypes.Horizontal,
 *  })
 * ```
 * @public
 */
export declare interface BarChartOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
    /**
     * Specify orientation of bar chart (vertical or horizontal).
     *
     * ```ts
     *  // Example usage
     *  const chart = lightningChart().BarChart({ type: BarChartTypes.Horizontal })
     * ```
     * @public
     */
    readonly type?: BarChartType;
    /**
     * Interface for supplying read-only configurations for the Value Axis. These can only be specified when the chart is created.
     * See {@link BarChartValueAxisOptions} for more information.
     * @public
     */
    readonly valueAxis?: BarChartValueAxisOptions;
    /**
     * Builder for the charts' *auto cursor*.
     *
     * For most use cases, it is not recommended to use this, but rather {@link BarChart.setAutoCursor} for a more convenient API.
     * @public
     */
    readonly autoCursorBuilder?: AutoCursor2DBuilder<CursorResultTableBackgroundType>;
}
/**
 * Type definition for a function that formats text displayed in cursor result table.
 *
 * See examples in {@link BarChart.setCursorResultTableFormatter}.
 * @public
 */
export declare type BarChartResultTableFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, category: string, value: number, bar: BarChartBar) => T;
/**
 * Type definition for a function that sorts bar charts.
 *
 * Works similar JavaScript [Array.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort), but each entry is given an object with `category` and `value` properties.
 *
 * See examples in {@link BarChart.setSorting}.
 * @public
 */
export declare type BarChartSorter = (a: {
    category: string;
    value: number;
}, b: {
    category: string;
    value: number;
}) => number;
/**
 * Built-in options for {@link BarChartSorter}s.
 *
 * See examples in {@link BarChart.setSorting}.
 * @public
 */
export declare const BarChartSorting: {
    Disabled: undefined;
    None: undefined;
    Ascending: BarChartSorter;
    Descending: BarChartSorter;
    Alphabetical: BarChartSorter;
};
/**
 * @public
 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
 */
declare interface _BarChartTickPlottingVariables extends _AbstractTickPlottingVariables {
    plotLines: _ShapeCollectionProvider<{
        positions: [Point, Point];
    }, {
        lineStyle: LineStyle;
    }>;
    oppositeAxisSize: number;
}
/**
 * Selector for Bar chart orientation (vertical or horizontal bars).
 *
 * See {@link BarChart} on how to supply the desired option.
 * @public
 */
export declare type BarChartType = typeof BarChartTypes[keyof typeof BarChartTypes];
/**
 * Selectors for Bar chart orientation (vertical or horizontal bars).
 *
 * See {@link BarChart} on how to supply the desired option.
 * @public
 */
export declare const BarChartTypes: {
    Horizontal: "horizontal";
    Vertical: "vertical";
};
/**
 * Class that represents a {@link BarChart}s Value Axis.
 * It can be accessed through {@link BarChart.valueAxis} property, and provides methods for configuring axis style, ticks and title.
 *
 * Useful methods:
 * - {@link setTitle} | set title text
 * - {@link setTitleFillStyle} | set title fill style
 * - {@link setTitleFont} | set title font
 * - {@link setStrokeStyle} | set style of axis line
 * - {@link setTickStrategy} | configure ticks
 * - {@link fit} | fit axis to visible data immediately
 * - {@link setAnimationScroll} | disable scroll animation
 * @public
 */
export declare class BarChartValueAxis extends GenericAxis<LinearScale1D | LogarithmicScale1D, AbstractAxisStrategy, _AbstractAxisTick, _BarChartTickPlottingVariables, undefined> {
    /**
     * Set Axis *thickness* as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax,
     *  Axis.setThickness( 60 )
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: number): this;
    /**
     * Configure Axis *thickness* min/max limits as pixels.
     *
     * The thickness of Axis is calculated based on ticks, title, axis line, etc.
     * By setting `min` and/or `max` thickness, the size allocated for Axis can be restricted to desired limits.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * ```
     *  // Example syntax, set axis to at least 100 px thick, but allow larger axis thickness if labels are large, or other such scenario.
     *  Axis.setThickness({ min: 100, max: undefined })
     * ```
     *
     * @param thickness - Explicit thickness of Axis as pixels.
     * @returns Object itself for fluent interface.
     * @public
     */
    setThickness(thickness: {
        min?: number;
        max?: number;
    }): this;
    /**
     * Get Axis *thickness* min/max limits as pixels.
     *
     * For X Axis, this means Axis height.
     *
     * For Y Axis, this means Axis width.
     *
     * By default, Axis has no thickness restrictions, so `getThickness` should return `{ min: undefined, max: undefined }`.
     *
     * @returns Actively configured Axis thickness limits as pixels.
     * @public
     */
    getThickness(): {
        min: number | undefined;
        max: number | undefined;
    };
    /**
     * Set style of Axis line stroke.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * - {@link emptyLine}
     *
     * ```ts
     *  // Example syntax, hide axis line
     *  barChart.valueAxis.setStrokeStyle(emptyLine)
     * ```
     *
     * ```ts
     *  // Example syntax, specify LineStyle
     *  barChart.valueAxis.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
     *  }))
     * ```
     *
     * ```ts
     *  // Example syntax, change thickness only
     *  barChart.valueAxis.setStrokeStyle((stroke) => new SolidLine({ ...stroke, thickness: 5 }))
     * ```
     *
     * - To learn more about line styles, see {@link LineStyle}.
     * - Sometimes the axis stroke style is confused together with the border style of {@link BarChart.setSeriesBackgroundStrokeStyle | series background border}
     *
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Object itself for fluent interface.
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * @returns Axis stroke style as a LineStyle object
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set *TickStrategy* of *Axis*.
     *
     * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
     * as well as the style of created ticks.
     *
     * ```ts
     *  // Example, disable ticks
     *  barChart.valueAxis.setTickStrategy(AxisTickStrategies.Empty)
     * ```
     *
     * ```ts
     *  // Example, customize tick labels formatting
     *  barChart.valueAxis.setTickStrategy(AxisTickStrategies.Numeric, ticks => ticks
     *      ticks
     *          .setMajorFormattingFunction((value) => `${value.toFixed(1)} `)
     *          .setMinorFormattingFunction((value) => `${value.toFixed(1)} `)
     *  )
     * ```
     *
     * ```ts
     *  // Example, set tick label fill style
     *  barChart.valueAxis.setTickStrategy(AxisTickStrategies.Numeric, ticks => ticks
     *      .setMajorTickStyle((major) => major.setLabelFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) })))
     *      .setMinorTickStyle((minor) => minor.setLabelFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) })))
     *  )
     * ```
     *
     * ```ts
     *  // Example, set tick label font size
     *  barChart.valueAxis.setTickStrategy(AxisTickStrategies.Numeric, ticks => ticks
     *      .setMajorTickStyle((major) => major.setLabelFont((font) => font.setSize(12)))
     *      .setMinorTickStyle((minor) =>  minor.setLabelFont((font) => font.setSize(10)))
     *  )
     * ```
     *
     * - To learn more of font configurations, see {@link FontSettings}.
     * - To learn more of fill style configurations, see {@link FillStyle}.
     *
     * @param tickStrategy - TickStrategy, either `AxisTickStrategies.Numeric` or `AxisTickStrategies.Empty`
     * @param styler - Optional callback that can be used to customize the *TickStrategy*.
     * @returns Object itself for fluent interface.
     * @public
     */
    setTickStrategy<TickStrategy extends 'Numeric' | 'Empty'>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
    /**
     * Enable / disable all interactions of Axis.
     * @param enabled - Interactions enabled or not.
     * @returns Object itself for fluent interface.
     * @public
     */
    setMouseInteractions(enabled: boolean): this;
}
/**
 * Interface for supplying read-only configurations for the Value Axis. These can only be specified when the chart is created.
 *
 * ```ts
 *  // Example, logarithmic value axis
 *  const barChart = lightningChart().BarChart({
 *      valueAxis: {
 *          type: 'logarithmic',
 *          base: 10
 *      }
 *  })
 * ```
 * @public
 */
export declare interface BarChartValueAxisOptions {
    /**
     * Type of Axis.
     *
     * `linear`:
     *
     * Default Axis type. Same behavior as `type: undefined`.
     *
     * `logarithmic`:
     *
     * Logarithmic Axis. By default base number will be `10`.
     */
    type?: 'linear' | 'logarithmic';
    /**
     * Specification of Logarithmic Base number (e.g. 10, 2, natural log).
     *
     * Defaults to 10 if omitted.
     *
     * Examples:
     *
     * - `10` | powers of ten (1, 10, 100, 1000, 10000, ...).
     * - `e`  | natural logarithm (1e, 2e, 3e, 4e, ...)
     *
     * `type` must be set to `'logarithmic'` for this to effect!
     */
    base?: number | 'E' | 'e' | 'natural';
}
/**
 * Interface for describing style of bar chart value labels.
 *
 * Used with {@link BarChart.setValueLabels}.
 *
 * There are currently 2 different value label positioning options available:
 * - {@link BarChartValueLabelsAfterBars}.
 * - {@link BarChartValueLabelsInsideBars}.
 * @public
 */
export declare type BarChartValueLabels = BarChartValueLabelsAfterBars | BarChartValueLabelsInsideBars;
/**
 * Interface for describing style of bar chart value labels when they are positioned after bars.
 *
 * Used with {@link BarChart.setValueLabels}.
 * @public
 */
export declare interface BarChartValueLabelsAfterBars {
    position: 'after-bar';
    /**
     * Label text formatter.
     * See {@link BarChartLabelFormatter} for examples.
     */
    formatter: BarChartLabelFormatter;
    /**
     * Label fill style.
     * See {@link FillStyle} for examples.
     */
    labelFillStyle: FillStyle;
    /**
     * Label font.
     * See {@link FontSettings} for examples.
     */
    labelFont: FontSettings;
    /**
     * Pixels margin before label.
     */
    labelMargin: number;
    /**
     * Label rotation as degrees.
     */
    labelRotation: number;
}
/**
 * Interface for describing style of bar chart value labels when they are positioned inside bars.
 *
 * Used with {@link BarChart.setValueLabels}.
 * @public
 */
export declare interface BarChartValueLabelsInsideBars {
    position: 'inside-bar' | 'inside-bar-end' | 'inside-bar-centered' | 'inside-bar-start';
    /**
     * Label text formatter.
     * See {@link BarChartLabelFormatter} for examples.
     */
    formatter: BarChartLabelFormatter;
    /**
     * Label fill style.
     * See {@link FillStyle} for examples.
     */
    labelFillStyle: FillStyle;
    /**
     * Label font.
     * See {@link FontSettings} for examples.
     */
    labelFont: FontSettings;
    /**
     * Pixels margin before label. Exact behavior depends on value of `position`.
     *
     * - `'inside-bar-end'` - margin applied between bar end and label.
     * - `'inside-bar-centered'` - no effect.
     * - `'inside-bar-start'` - margin applied between bar start and label.
     * - `'inside-bar'` - same as `'inside-bar-end'`
     */
    labelMargin: number;
    /**
     * Label rotation as degrees.
     */
    labelRotation: number;
}
/**
 * The class implements the most part of logic general for point and line series
 * @typeParam InputType - Implementations should use Point here if they only accept Points, otherwise pass
 *                                  ONLY the additionally supported input type. For example, PointSeries will give "ColorPoint".
 *
 * @public
 */
export declare abstract class BasicSeries<InputType extends Point = Point, ScaleType extends ScaleXY = ScaleXY> extends SeriesXY<CursorPoint, ScaleType> implements DataInputXY, DataInput, DataInputX, DataInputY, ObservableXYData<Point>, SeriesWithDataCleaning {
    /**
     * Disable automatic data cleaning.
     *
     * ```js
     *  // Example syntax, disable data cleaning.
     *  series.setDataCleaning(undefined)
     * ```
     *
     * @param arg - Data cleaning configuration.
     * @returns Object itself for fluent interface.
     * @public
     */
    setDataCleaning(arg: undefined): this;
    /**
     * Enable automatic data cleaning by `minDataPointCount` configuration.
     *
     * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
     *
     * ```js
     *  // Example syntax for specifying minDataPointCount
     *  series.setDataCleaning({ minDataPointCount: 10000 })
     * ```
     *
     * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
     * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
     *
     * ```js
     *  // Example, enable lazy data cleaning of out of view data.
     *  series.setDataCleaning({ minDataPointCount: 1 })
     * ```
     *
     * @param arg - Data cleaning configuration.
     * @returns Object itself for fluent interface.
     * @public
     */
    setDataCleaning(arg: {
        minDataPointCount: number | undefined;
    }): this;
    /**
     * Append a single `XY` coordinate or list of `XY` coordinates into the *series*.
     *
     * ```ts
     *  // Example syntax
     *  LineSeries.add({ x: 0, y: 100 })
     *
     *  LineSeries.add([
     *      { x: 0, y: 100 },
     *      { x: 10, y: 50 },
     *      { x: 20, y: 75 },
     *  ])
     * ```
     *
     * For more methods of appending data into series, see:
     *
     * - {@link addArrayY} | Append only Y coordinates.
     * - {@link addArrayX} | Append only X coordinates.
     * - {@link addArraysXY} | Append X and Y coordinates in separate arrays.
     *
     * **Data gaps**
     *
     * When using {@link LineSeries}, {@link AreaSeries} or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN` as either X or Y coordinate.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  LineSeries.add([
     *      { x: 0, y: 10 },
     *      { x: 1, y: 12 },
     *      { x: 2, y: Number.NaN },
     *      { x: 3, y: 15 },
     *      { x: 4, y: 20 }
     *  ])
     * ```
     *
     * @param points - Single XY coordinate or list of coordinates.
     * @returns Object itself for fluent interface.
     * @public
     */
    add(points: InputType | InputType[]): this;
    /**
     * Append new data points into the series by only supplying X coordinates.
     *
     * ```ts
     *  // Example syntax, number array
     *  LineSeries.addArrayX([ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  LineSeries.addArrayX(float32Array)
     * ```
     *
     * Each X coordinate will be paired with an automatically generated Y coordinate.
     *
     * By default, this continues from the last data point in the series.
     * However, the behavior of assigning Y coordinates can be controlled with the optional `step` and `start` parameters.
     *
     * For more methods of appending data into series, see:
     *
     * - {@link add} | Append XY coordinates.
     * - {@link addArrayY} | Append only Y coordinates.
     * - {@link addArraysXY} | Append X and Y coordinates in separate arrays.
     *
     * **Data gaps**
     *
     * When using {@link LineSeries}, {@link AreaSeries} or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  LineSeries.addArrayX([ 10, 12, Number.NaN, 15, 20 ])
     * ```
     *
     * @param arrayX - Array of X-values.
     * @param step - Optional step between each Y coordinate. Defaults to 1.
     * @param start - Optional value for first generated Y-value. If undefined, will continue after last point's Y value in series,
     *                  or 0 if there are no points in series.
     * @returns Object itself for fluent interface.
     * @public
     */
    addArrayX(arrayX: number[] | TypedArray, step?: number, start?: number): this;
    /**
     * Append new data points into the series by only supplying Y coordinates.
     *
     * ```ts
     *  // Example syntax, number array
     *  LineSeries.addArrayY([ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  LineSeries.addArrayY(float32Array)
     * ```
     *
     * Each Y coordinate will be paired with an automatically generated X coordinate.
     *
     * By default, this continues from the last data point in the series.
     * However, the behavior of assigning X coordinates can be controlled with the optional `step` and `start` parameters.
     *
     * For more methods of appending data into series, see:
     *
     * - {@link add} | Append XY coordinates.
     * - {@link addArrayX} | Append only X coordinates.
     * - {@link addArraysXY} | Append X and Y coordinates in separate arrays.
     *
     * **Data gaps**
     *
     * When using {@link LineSeries}, {@link AreaSeries} or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  LineSeries.addArrayY([ 10, 12, Number.NaN, 15, 20 ])
     * ```
     *
     * @param arrayY - Array of Y-values.
     * @param step - Optional step between each X coordinate. Defaults to 1.
     * @param start - Optional value for first generated X-value. If undefined, will continue after last point's X value in series,
     *                  or 0 if there are no points in series.
     * @returns Object itself for fluent interface.
     * @public
     */
    addArrayY(arrayY: number[] | TypedArray, step?: number, start?: number): this;
    /**
     * Append new data points into the series by supplying X and Y coordinates in two separated arrays.
     *
     * ```ts
     *  // Example syntax, number array
     *  LineSeries.addArraysXY([0, 1, 2, 3], [ 5, 1, 2, 0 ])
     * ```
     *
     * This method supports binary data input by using *Typed arrays*.
     * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
     *
     * ```ts
     *  // Example syntax, typed array (Float32)
     *  const float32Array = new Float32Array(4)
     *  float32Array[0] = 5
     *  float32Array[1] = 1
     *  float32Array[2] = 2
     *  float32Array[3] = 0
     *  LineSeries.addArraysXY([0, 1, 2, 3], float32Array)
     * ```
     *
     * For more methods of appending data into series, see:
     *
     * - {@link add} | Append XY coordinates.
     * - {@link addArrayX} | Append only X coordinates.
     * - {@link addArrayY} | Append only Y coordinates.
     *
     * **Data gaps**
     *
     * When using {@link LineSeries}, {@link AreaSeries} or other series types which connect data points together,
     * the connections between specific data points can be removed by adding gap data points.
     *
     * A gap data point is specified by using `Number.NaN`.
     *
     * ```ts
     *  // Example, data gap syntax.
     *  LineSeries.addArraysXY(
     *      [ 0, 1, 2, 3, 4 ],
     *      [ 10, 12, Number.NaN, 15, 20 ]
     *  )
     * ```
     *
     * @param arrayX - Array of X-values.
     * @param arrayY - Array of Y-values. Length should be equal to length of *arrayX*.
     * @returns Object itself for fluent interface.
     * @public
     */
    addArraysXY(arrayX: number[] | TypedArray, arrayY: number[] | TypedArray): this;
    /**
     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
     *
     * ```typescript
     *  // Example usage
     *  LineSeries.setCursorResultTableFormatter((tableBuilder, series, x, y, dataPoint) => {
     *      return tableBuilder
     *          .addRow(`Pointing at`, '', series.getName())
     *          .addRow(`X:`, '', dataPoint.x.toFixed(1))
     *          .addRow(`Y:`, '', dataPoint.y.toFixed(1))
     *  })
     * ```
     *
     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
     * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
     *
     * ```typescript
     *  // Using TableContentBuilder.
     *  LineSeries.setCursorResultTableFormatter((tableBuilder, series, x, y) => {
     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
     *      tableBuilder
     *          .addRow('Item 0:', '', 'Value 0')
     *          .addRow('Item 1:', '', 'Value 1')
     *          .addRow('Long row that highlights the idea of empty strings')
     *
     *      // After configuration, the table builder must be returned!
     *      return tableBuilder
     *  })
     * ```
     *
     * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
     *
     * The additional values that are supplied to the callback function, **vary per series**,
     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
     * For example, `LineSeries` receives three extra parameters:
     * 1. `series` | reference to the series itself.
     * 2. `x` | pointed data point X coordinate.
     * 3. `y` | pointed data point Y coordinate.
     * 4. `dataPoint` | reference to the pointed data point as supplied by user.
     *
     * **Related API:**
     *
     * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
     *
     * @param formatter - Function which builds *ResultTable* content.
     * @returns Object itself
     * @public
     */
    setCursorResultTableFormatter(formatter: SeriesXYFormatter): this;
    /**
     * Get ResultTable Formatter.
     * @returns Function which builds ResultTable content for SeriesXY.
     * @public
     */
    getCursorResultTableFormatter(): SeriesXYFormatter;
    /**
     * Get amount of points that series currently has.
     * @returns Number of points
     * @public
     */
    getPointAmount(): number;
    /**
     * Clear all previously pushed data points from the *series*.
     *
     * ```ts
     *  // Example usage
     *  LineSeries.clear()
     * ```
     *
     * @returns Object itself for fluent interface.
     * @public
     */
    clear(): this;
    /**
     * @returns Copy of last point added to the Series or undefined if it doesn't exist.
     * @public
     */
    getLastPoint(): Point | undefined;
    /**
     * @returns Max X value of the series or `0` if series has no data.
     * @public
     */
    getXMax(): number;
    /**
     * @returns Min X value of the series or `0` if series has no data.
     * @public
     */
    getXMin(): number;
    /**
     * @returns Max Y value of the series or `0` if series has no data.
     * @public
     */
    getYMax(): number;
    /**
     * @returns Min Y value of the series or `0` if series has no data.
     * @public
     */
    getYMin(): number;
}
/**
 * Abstract Picture with stylable border.
 * @public
 */
export declare abstract class BorderedPicture extends Picture {
    /**
     * Set stoke style of Picture
     * @param value - LineStyle object or function which modifies it
     * @returns Object itself for fluent interface
     * @public
     */
    abstract setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of Picture
     * @public
     */
    abstract getStrokeStyle(): LineStyle;
}
/**
 * Interface for non-geometric properties of a *box*.
 *
 * Box geometry can be specified in a variety of ways, namely:
 * - {@link BoxDataCentered}.
 * - {@link BoxDataBounds}.
 * @public
 */
export declare interface BoxData {
    /**
     * Color of this box, when the *series* is styled as {@link IndividualPointFill}.
     */
    color?: Color;
    /**
     * Look-up value for this box, when the *series* is styled as {@link PalettedFill}.
     *
     * Determines the color of the box.
     */
    value?: number;
    /**
     * Identifier of this box.
     *
     * Can be used to alter the boxes' properties afterwards.
     */
    id?: string | number;
}
/**
 * Interface for specifying properties of a *box*.
 *
 * Non-geometry properties are explained in {@link BoxData} interface.
 *
 * This interface defines the box using *coordinate boundaries*. For another geometry definitions, see:
 * - {@link BoxDataCentered}.
 * @public
 */
export declare interface BoxDataBounds extends BoxData {
    /**
     * Minimum X coordinate.
     */
    xMin: number;
    /**
     * Minimum Y coordinate.
     */
    yMin: number;
    /**
     * Minimum Z coordinate.
     */
    zMin: number;
    /**
     * Maximum X coordinate.
     */
    xMax: number;
    /**
     * Maximum Y coordinate.
     */
    yMax: number;
    /**
     * Maximum Z coordinate.
     */
    zMax: number;
}
/**
 * Interface for specifying properties of a *box*.
 *
 * Non-geometry properties are explained in {@link BoxData} interface.
 *
 * This interface defines the box using a *center coordinate* and *size*. For another geometry definitions, see:
 * - {@link BoxDataBounds}.
 * @public
 */
export declare interface BoxDataCentered extends BoxData {
    /**
     * Center X coordinate of Box.
     */
    xCenter: number;
    /**
     * Center Y coordinate of Box.
     */
    yCenter: number;
    /**
     * Center Z coordinate of Box.
     */
    zCenter: number;
    /**
     * X size of Box. Applied both ways from 'xCenter' divided by 2.
     */
    xSize: number;
    /**
     * Y size of Box. Applied both ways from 'yCenter' divided by 2.
     */
    ySize: number;
    /**
     * Z size of Box. Applied both ways from 'zCenter' divided by 2.
     */
    zSize: number;
}
/**
 * @public
 */
export declare class BoxFigure extends Figure implements BoxFigureDimensions {
    /**
     * Boundaries of BoxFigure.
     * Constant and computed in constructor.
     * @public
     */
    readonly boundaries: Interval<Point>;
    /**
     * @public
     */
    readonly scale: LinearScaleXY;
    /**
     * @public
     */
    readonly dimensionStrategy: MultidimensionalStrategy;
    /**
     * @public
     */
    readonly start: number;
    /**
     * @public
     */
    readonly end: number;
    /**
     * @public
     */
    readonly lowerExtreme: number;
    /**
     * @public
     */
    readonly lowerQuartile: number;
    /**
     * @public
     */
    readonly median: number;
    /**
     * @public
     */
    readonly upperQuartile: number;
    /**
     * @public
     */
    readonly upperExtreme: number;
    /**
     * Get boundaries that contain figure.
     * @returns Interval<Point>
     * @public
     */
    getBoundaries(): Interval<Point>;
    /**
     * Set width of box body as a % of the width of its interval width.
     * @param width - Ratio between box body width and the segments interval
     * @returns Object itself
     * @public
     */
    setBodyWidth(width: number): this;
    /**
     * Get width of box body as a % of the width of its interval width.
     * @returns Ratio between box body width and the segments interval
     * @public
     */
    getBodyWidth(): number;
    /**
     * Set fill style of Series.
     *
     *Example Usage:
     *```javascript
     * // Specified FillStyle
     * BoxAndWhiskers.setBodyFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Changed transparency
     * BoxAndWhiskers.setBodyFillStyle((solidFill) => solidFill.setA(80))
     * // Hidden (emptyFill is not supported)
     * BoxAndWhiskers.setBodyFillStyle(transparentFill)
     * ```
     * @param value - FillStyle which has to be used for recoloring or mutator to modify existing one.
     * @returns Series itself for fluent interface.
     * @public
     */
    setBodyFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of box body when not highlighted.
     * @returns FillStyle object
     * @public
     */
    getBodyFillStyle(): FillStyle;
    /**
     * Set border style of Series.
     *
     *```javascript
     * // Specified SolidLine
     * BoxAndWhiskers.setBodyStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setBodyStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setBodyStrokeStyle(transparentLine)
     * ```
     * @param value - LineStyle which has to be used for recoloring or mutator to modify existing one.
     * @returns Series itself for fluent interface.
     * @public
     */
    setBodyStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of box body when not highlighted.
     * @returns LineStyle object
     * @public
     */
    getBodyStrokeStyle(): LineStyle;
    /**
     * Set width of box tails as a % of the width of its interval width.
     * @param width - Ratio between box tail width and the segments interval
     * @returns Object itself
     * @public
     */
    setTailWidth(width: number): this;
    /**
     * Get width of box tails as a % of the width of its interval width.
     * @returns Ratio between box tail width and the segments interval
     * @public
     */
    getTailWidth(): number;
    /**
     * Set stroke style of Series whiskers and tails.
     *
     * Supported line styles:
     * - {@link SolidLine}
     * - {@link emptyLine}
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * BoxAndWhiskers.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Chart itself
     * @public
     */
    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of box whiskers and tails when not highlighted.
     * @returns LineStyle object
     * @public
     */
    getStrokeStyle(): LineStyle;
    /**
     * Set stroke style of Series median line.
     *
     * Example usage:
     *```javascript
     * // Specified LineStyle
     * BoxAndWhiskers.setMedianStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
     * // Changed thickness
     * BoxAndWhiskers.setMedianStrokeStyle((solidLine) => solidLine.setThickness(5))
     * // Hidden (emptyLine is not supported)
     * BoxAndWhiskers.setMedianStrokeStyle(transparentLine)
     * ```
     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
     * @returns Chart itself
     * @public
     */
    setMedianStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get stroke style of box median line when not highlighted.
     * @returns LineStyle object
     * @public
     */
    getMedianStrokeStyle(): LineStyle;
    /**
     * Return some dominant fill style of the segment
     * @returns FillStyle object
     * @public
     */
    getDominantStyle(): FillStyle;
}
/**
 * Data structure that defines the dimensions of a Box Figure.
 * Used to feed segment data to Box Series.
 * @public
 */
export declare interface BoxFigureDimensions {
    readonly start: number;
    readonly end: number;
    readonly lowerExtreme: number;
    readonly lowerQuartile: number;
    readonly median: number;
    readonly upperQuartile: number;
    readonly upperExtreme: number;
}
/**
 * BoxSeries class.
 * Takes in types of 'BoxFigureDimensions' and plots it using 'StatisticFigure'
 *
 * Currently always on X
 * @public
 */
export declare class BoxSeries extends FigureSeries<BoxFigure, BoxFigureDimensions, LinearScaleXY> {
    /**
     * Add new figure to the series.
     * @param dimensions - Dimensions that figure must represent
     * @returns Created figure
     * @public
     */
    add(dimensions: BoxFigureDimensions): BoxFigure;
    /**
     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
     *
     * ```typescript
     *  // Example usage
     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
     *      const rectangleDimensions = figure.getDimensionsTwoPoints()
     *      return tableBuilder
     *          .addRow(`Pointing at`, '', series.getName())
     *          .addRow(`X1:`, '', rectangleDimensions.x1)
     *          .addRow(`X2:`, '', rectangleDimensions.x2)
     *          .addRow(`Y1:`, '', rectangleDimensions.y1)
     *          .addRow(`Y2:`, '', rectangleDimensions.y2)
     *  })
     * ```
     *
     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
     * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
     *
     * ```typescript
     *  // Using TableContentBuilder.
     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
     *      tableBuilder
     *          .addRow('Item 0:', '', 'Value 0')
     *          .addRow('Item 1:', '', 'Value 1')
     *          .addRow('Long row that highlights the idea of empty strings')
     *
     *      // After configuration, the table builder must be returned!
     *      return tableBuilder
     *  })
     * ```
     *
     * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
     *
     * The additional values that are supplied to the callback function vary between different chart types,
     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
     * `Figure Series` receive two extra parameters:
     * 1. `series` | reference to the series itself.
     * 2. `figure` | reference to the pointed *figure*.
     * This type is **generic** - for example, for `RectangleSeries` it is of type `RectangleFigure`.
     *
     * **Related API:**
     *
     * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
     *
     * @param formatter - Function which builds *ResultTable* content.
     * @returns Object itself
     * @public
     */
    setCursorResultTableFormatter(formatter: BoxSeriesFormatter): this;
    /**
     * Get ResultTable Formatter.
     * @returns Function which builds ResultTable content for the Series.
     * @public
     */
    getCursorResultTableFormatter(): BoxSeriesFormatter;
}
/**
 * Class for visualization of large sets of individually configurable 3D *Boxes*.
 *
 * Add data with {@link BoxSeries3D.invalidateData}.
 *
 * Style *boxes* with {@link BoxSeries3D.setFillStyle}.
 *
 * **Example usage:**
 *
 * ```ts
 *  // Construct a grid of vertical boxes.
 *  const data = [
 *      { x: 0, z: 0 },
 *      { x: 1, z: 0 },
 *      { x: 0, z: 1 },
 *      { x: 1, z: 1 }
 *  ]
 *      // Map coords into **BoxData**.
 *      .map( coords => {
 *      const height = Math.random() * 100
 *      return {
 *          xCenter: coords.x,
 *          yCenter: height / 2,
 *          zCenter: coords.z,
 *          xSize: 1,
 *          ySize: height,
 *          zSize: 1
 *      }
 *  })
 *  const chart = lightningChart().Chart3D()
 *  const boxSeries = chart.addBoxSeries()
 *      .invalidateData( data )
 * ```
 *
 * **Color shading style**.
 *
 * By default, `BoxSeries3D` uses _Phong_ shading style.
 *
 * This can be changed with `BoxSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
 * @public
 */
export declare class BoxSeries3D extends Series3D implements AttachableWithLUT {
    /**
     * Method for invalidating *Box* data. Accepts an *Array* of {@link BoxDataCentered} objects.
     *
     * **Properties that must be defined for each NEW Box**:
     * - **"xCenter", "yCenter", "zCenter"**  | coordinates of Box in Axis values.
     * - **"xSize", "ySize", "zSize"**        | size of Box in Axis values.
     *
     * ( if altering a previously created Box, these are not necessary )
     *
     * **Optional properties:**
     * - **"id"**:
     *  If supplied, the *Box* can be altered afterwards by supplying different data with the same **"id"**
     * - **"color"**:
     *  If supplied, the *Box* will be coloured with that *color*,
     *  **but only when the *BoxSeries* is styled as {@link IndividualPointFill}**
     * - **"value"**
     *  *Look-up value* to be used when the *BoxSeries* is styled as {@link PalettedFill}.
     *
     * **Example usage:**
     *
     * - Add an unidentified Box - in this case the Box can not be altered afterwards.
     *
     * ```ts
     *  BoxSeries3D.invalidateData([
     *      { xCenter: 0, yCenter: 0, zCenter: 0, xSize: 1, ySize: 1, zSize: 1 }
     *  ])
     * ```
     *
     * - Add an identified Box and alter its 'color' property afterwards.
     *
     * ```ts
     *  const id = "anything-unique"
     *  BoxSeries3D
     *      .setFillStyle( new IndividualPointFill() )
     *      .invalidateData([
     *          { id, xCenter: 0, yCenter: 0, zCenter: 0, xSize: 1, ySize: 1, zSize: 1 }
     *      ])
     *  setTimeout(() => {
     *      BoxSeries3D.invalidateData([ { id, color: ColorRGBA( 0, 255, 0 ) } ])
     *  }, 2000)
     * ```
     * @public
     */
    invalidateData(data: Partial<BoxDataCentered>[]): this;
    /**
     * Method for invalidating *Box* data. Accepts an *Array* of {@link BoxDataBounds} objects.
     *
     * NOTE: Internally transforms all data into {@link BoxDataCentered} format, meaning that this method is slightly
     * slower than the alternative.
     *
     * **Properties that must be defined for each NEW Box**:
     * - **"xMin", "xMax"**   | bounds of Box on X Axis.
     * - **"yMin", "yMax"**   | bounds of Box on X Axis.
     * - **"zMin", "zMax"**   | bounds of Box on X Axis.
     *
     * ( if altering a previously created Box, these are not necessary )
     *
     * **Optional properties:**
     * - **"id"**:
     *  If supplied, the *Box* can be altered afterwards by supplying different data with the same **"id"**
     * - **"color"**:
     *  If supplied, the *Box* will be coloured with that *color*,
     *  **but only when the *BoxSeries* is styled as {@link IndividualPointFill}**
     * - **"value"**
     *  *Look-up value* to be used when the *BoxSeries* is styled as {@link PalettedFill}.
     *
     * **Example usage:**
     *
     * - Add an unidentified Box - in this case the Box can not be altered afterwards.
     *
     * ```ts
     *  BoxSeries3D.invalidateData([
     *      { xMin: 0, yMin: 0, zMin: 0, xMax: 1, yMax: 1, zMax: 1 }
     *  ])
     * ```
     *
     * - Add an identified Box and alter its 'color' property afterwards.
     *
     * ```ts
     *  const id = "anything-unique"
     *  BoxSeries3D
     *      .setFillStyle( new IndividualPointFill() )
     *      .invalidateData([
     *          { id, xMin: 0, yMin: 0, zMin: 0, xMax: 1, yMax: 1, zMax: 1 }
     *      ])
     *  setTimeout(() => {
     *      BoxSeries3D.invalidateData([ { id, color: ColorRGBA( 0, 255, 0 ) } ])
     *  }, 2000)
     * ```
     * @public
     */
    invalidateData(data: Partial<BoxDataBounds>[]): this;
    /**
     * Set *FillStyle* of *BoxSeries*.
     *
     * Supports following FillStyles:
     * - **{@link SolidFill}**:
     *  Single solid color for all *boxes*.
     * - **{@link IndividualPointFill}**:
     *  Each *box* is colored according to its **"color"** property.
     *  If the property is not present, the *box* is colored with the *IndividualPointFill* objects' fall-back color.
     * - **{@link PalettedFill}**:
     *  Each *box* is colored according to its **"value"** property and the *PalettedFill* objects'
     *  *look up table*.
     * @param value - FillStyle or function which creates a FillStyle based on previous value.
     * @returns Object itself.
     * @public
     */
    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get *FillStyle* of *BoxSeries*.
     *
     * Supports following FillStyles:
     * - **{@link SolidFill}**:
     *  Single solid color for all *boxes*.
     * - **{@link IndividualPointFill}**:
     *  Each *box* is colored according to its **"color"** property.
     *  If the property is not present, the *box* is colored with the *IndividualPointFill* objects' fall-back color.
     * - **{@link PalettedFill}**:
     *  Each *box* is colored according to its **"value"** property and the *PalettedFill* objects'
     *  *look up table*.
     * @returns FillStyle object.
     * @public
     */
    getFillStyle(): FillStyle;
    /**
     * Set rounded edges of Boxes.
     *
     * NOTE: Rounded edges result in increased geometry precision, which in turn uses more rendering resources.
     * @param roundness - Either a **number in range [0, 1]** describing the amount of rounding
     *                      or **undefined** to disable rounded edges.
     * @returns Object itself for fluent interface.
     * @public
     */
    setRoundedEdges(roundness: number | undefined): this;
    /**
     * Get rounded edges of Boxes.
     *
     * NOTE: Rounded edges result in increased geometry precision, which in turn uses more rendering resources.
     * @returns Either a **number in range [0, 1]** describing the amount of rounding
     *                      or **undefined** for disabled rounded edges.
     * @public
     */
    getRoundedEdges(): number | undefined;
    /**
     * Attach object to an legendBox entry
     * @param entry        -     Object which has to be attached
     * @param toggleVisibilityOnClick    -   Flag that indicates whether the Attachable should be hidden or not,
     *                          when its respective Entry is clicked.
     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
     * @returns Series itself for fluent interface
     * @public
     */
    attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
}
/**
 * Type of a BoxSeriesFormatter function.
 * Defines what Cursor ResultTables show.
 * @param tableContentBuilder - Builder that is used to build contents of ResultTable
 * @param series - BoxSeries
 * @param segment - StatisticData that is to be displayed with ResultTable
 * @returns TableContentBuilder that was supplied
 * @public
 */
export declare type BoxSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: BoxSeries, segment: BoxFigureDimensions) => T;
/**
 * Interface can be used to define the X and Y Axis that a series should be attached to,
 * define type of StatisticFigure and type of dimensionStrategy.
 * @public
 */
export declare interface BoxSeriesOptions extends SeriesOptionsXY {
    /**
     * DimensionStrategy Strategy used for selecting between vertical and horizontal Box Series.
     * @public
     */
    dimensionStrategy?: MultidimensionalStrategy;
}
/**
 * Data structure of a province / territory of Canada.
 * @public
 */
export declare interface CanadaProvinceOrTerritory {
    /**
     * Name of the province / territory. Eq. 'Ontario'. This is case insensitive.
     */
    name: string;
}
/**
 * Chart abstraction layer that implements Chart title and padding.
 * @public
 */
export declare abstract class Chart extends Panel implements ChartAPI {
    /**
     * Get minimum size of Chart.
     * Depending on the type of class this value might be automatically computed to fit different elements.
     * @returns Vec2 minimum size or undefined if unimplemented
     */
    abstract getMinimumSize(): Point | undefined;
    /**
     * Disable/Enable all animations of the Chart.
     * @param animationsEnabled - Boolean value to enable or disable animations.
     * @returns Chart itself for fluent interface.
     * @public
     */
    setAnimationsEnabled(animationsEnabled: boolean): this;
    /**
     * Get animations disable/enable state.
     * @returns Animations default state.
     * @public
     */
    getAnimationsEnabled(): boolean;
    /**
     * Set text of Chart title.
     * @param title - Chart title as a string.
     * @returns Object itself for fluent interface.
     * @public
     */
    setTitle(title: string): this;
    /**
     * Get text of Chart title.
     * @returns Chart title as a string.
     * @public
     */
    getTitle(): string;
    /**
     * Get Chart title size.
     *
     * This depends on current title content, font and style.
     *
     * @returns Size of Chart title in pixels
     * @public
     */
    getTitleSize(): Point;
    /**
     * Set fill style of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new style
     * Chart.setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
     * // Change transparency
     * Chart.setTitleFillStyle((solidFill) => solidFill.setA(80))
     * // Set hidden
     * Chart.setTitleFillStyle(emptyFill)
     * ```
     *
     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
     * @returns Chart itself
     * @public
     */
    setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
    /**
     * Get fill style of Chart Title.
     * @returns FillStyle object
     * @public
     */
    getTitleFillStyle(): FillStyle;
    /**
     * Set font of Chart Title.
     *
     * Example usage:
     *```javascript
     * // Create a new FontSettings
     * Chart.setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
     * // Change existing settings
     * Chart.setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
     * ```
     *
     * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
     * @returns Chart itself
     * @public
     */
    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
    /**
     * Get font of Chart title.
     * @returns FontSettings object
     * @public
     */
    getTitleFont(): FontSettings;
    /**
     * Set rotation of Chart title.
     * @param value - Rotation in degrees
     * @returns Object itself
     * @public
     */
    setTitleRotation(value: number): this;
    /**
     * Get rotation of Chart title.
     * @returns Rotation in degrees
     * @public
     */
    getTitleRotation(): number;
    /**
     * Set theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * @param enabled - Theme effect enabled
     * @returns          Object itself.
     * @public
     */
    setTitleEffect(enabled: boolean): this;
    /**
     * Get theme effect enabled on component or disabled.
     *
     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * ```ts
     *  // Example, disable theme effect from a particular component.
     *  Component.setEffect(false)
     * ```
     *
     * For the most part, theme effects are **enabled** by default on most components.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     *
     * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
     * @public
     */
    getTitleEffect(): boolean;
    /**
     * Specifies padding after chart title.
     *
     * This does not have an effect if title is hidden (empty FillStyle).
     *
     * ```typescript
     *  // Example 2, specify margins for all sides with same value for Title.
     *  ChartXY.setTitleMargin(40)
     * ```
     *
     * @param marginPixels - Gap after the chart title in pixels.
     * @returns Chart itself for fluent interface
     * @public
     */
    setTitleMargin(marginPixels: Partial<Margin> | pixel): this;
    /**
     * @returns Padding after Chart title
     * @public
     */
    getTitleMargin(): Partial<Margin>;
    /**
     * Set padding around Chart in pixels.
     *
     * ```typescript
     *  // Example 1, specify complete padding (four sides).
     *  ChartXY.setPadding({ left: 16, right: 16, top: 32, bottom: 8 })
     * ```
     *
     * ```typescript
     *  // Example 2, specify only single padding.
     *  ChartXY.setPadding({ right: 64 })
     * ```
     *
     * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
     *                      for each side. Any side can be omitted, only passed values will be overridden.
     * @returns Object itself
     * @public
     */
    setPadding(padding: Partial<Margin> | number): this;
    /**
     * Get padding around Chart in pixels.
     * @returns Padding datastructure
     * @public
     */
    getPadding(): Margin;
    /**
     * **Permanently** dispose the component.
     *
     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
     * **to the component and its children** in application code.
     * ```javascript
     * let chart = ...ChartXY()
     * let axisX = chart.getDefaultAxisX()
     * // Dispose Chart, and remove all references so that they can be garbage-collected.
     * chart.dispose()
     * chart = undefined
     * axisX = undefined
     * ```
     * @returns Object itself for fluent interface
     * @public
     */
    dispose(): this;
}
/**
 * Chart for visualizing data in a 3-dimensional scene, with camera and light source(s).
 *
 * Camera can be moved around with user interactions (mouse & touch). It is always oriented to face the center of the scene.
 *
 * Light source is always located at the location of the Camera, and directed towards the center of *Axes*.
 *
 * Data can be added to the *Chart* via various *Series* types, each with their own method of visualization:
 *
 * ```javascript
 *  const pointLineSeries3D = chart3D.addPointLineSeries()
 *      .add( [
 *          { x: 0, y: 0, z: 0 },
 *          { x: 1, y: 0, z: 0 },
 *          { x: 2, y: 1, z: 0 }
 *      ] )
 * ```
 * @public
 */
export declare class Chart3D extends ChartWithSeries<Series3D> implements ChartWithAxis<Axis3D> {
    /**
     * Distance that static light source is behind camera always. In World Units.
     */
    private readonly _lightSourceDistanceFromCamera;
    /**
     * Is zoom animation enabled.
     *
     * Zoom animation is applied on mouse wheel and trackpad zooming interactions.
     */
    private _zoomAnimationEnabled;
    private _isMouseZoomingEnabled;
    /**
     * Flag for Rotating mouse-interaction enabled:
     * Rotating axes with mouse-drag.
     */
    private _isRotateEnabled;
    /**
     * Velocity counter for zoom animation.
     */
    private _zoomAnimationVelocity;
    /**
     * 3D Coordinate system selector to use with {@link translatePoint3D} function, which lets users translate coordinates between different 3D coordinate systems.
     *
     * ```js
     *  // Example, translate coordinate from Chart3D Axes to World Space.
     *  const coordWorld = translatePoint3D(
     *      // Coordinate on Axes.
     *      { x: 10, y: 5, z: 25 },
     *      // Source coordinate system.
     *      chart3D.coordsAxis,
     *      // Target coordinate system.
     *      chart3D.coordsWorld
     *  )
     * ```
     *
     * The `axes` selector describes the coordinate system of 3D charts Axes (X, Y, Z).
     *
     * **About 3D coordinate systems:**
     *
     * `Chart3D` camera location is configured in World Space, which is currently the primary reason for interacting with different 3D coordinate systems.
     *
     * For example, depth sorting of transparent objects by rendering data based on their distance to the camera.
     *
     * Depth sorting is required for blending stacked transparent objects.
     * @public
     */
    readonly coordsAxis: CoordinateSystemDefinition3D;
    /**
     * 3D Coordinate system selector to use with {@link translatePoint3D} function, which lets users translate coordinates between different 3D coordinate systems.
     *
     * ```js
     *  // Example, translate coordinate from Chart3D Axes to World Space.
     *  const coordWorld = translatePoint3D(
     *      // Coordinate on Axes.
     *      { x: 10, y: 5, z: 25 },
     *      // Source coordinate system.
     *      chart3D.coordsAxis,
     *      // Target coordinate system.
     *      chart3D.coordsWorld
     *  )
     * ```
     *
     * The `world` selector describes 3D World Space.
     *
     * _3D world space_ is used for camera positioning, is centered at [0, 0, 0] and values generally range between += 5.
     *
     * **About 3D coordinate systems:**
     *
     * `Chart3D` camera location is configured in World Space, which is currently the primary reason for interacting with different 3D coordinate systems.
     *
     * For example, depth sorting of transparent objects by rendering data based on their distance to the camera.
     *
     * Depth sorting is required for blending stacked transparent objects.
     * @public
     */
    readonly coordsWorld: CoordinateSystemDefinition3D;
    /**
     * 3D Coordinate system selector to use with {@link translatePoint3D} function, which lets users translate coordinates between different 3D coordinate systems.
     *
     * ```js
     *  // Example, translate coordinate from Chart3D Axes to World Space.
     *  const coordWorld = translatePoint3D(
     *      // Coordinate on Axes.
     *      { x: 10, y: 5, z: 25 },
     *      // Source coordinate system.
     *      chart3D.axes,
     *      // Target coordinate system.
     *      chart3D.world
     *  )
     * ```
     *
     * The `axes` selector describes the coordinate system of 3D charts Axes (X, Y, Z).
     *
     * **About 3D coordinate systems:**
     *
     * `Chart3D` camera location is configured in World Space, which is currently the primary reason for interacting with different 3D coordinate systems.
     *
     * For example, depth sorting of transparent objects by rendering data based on their distance to the camera.
     *
     * Depth sorting is required for blending stacked transparent objects.
     * @deprecated  Deprecated from v4.2, in favour of `coordsAxis`.
     * @public
     */
    readonly axes: CoordinateSystemDefinition3D;
    /**
     * 3D Coordinate system selector to use with {@link translatePoint3D} function, which lets users translate coordinates between different 3D coordinate systems.
     *
     * ```js
     *  // Example, translate coordinate from Chart3D Axes to World Space.
     *  const coordWorld = translatePoint3D(
     *      // Coordinate on Axes.
     *      { x: 10, y: 5, z: 25 },
     *      // Source coordinate system.
     *      chart3D.axes,
     *      // Target coordinate system.
     *      chart3D.world
     *  )
     * ```
     *
     * The `world` selector describes 3D World Space.
     *
     * _3D world space_ is used for camera positioning, is centered at [0, 0, 0] and values generally range between += 5.
     *
     * **About 3D coordinate systems:**
     *
     * `Chart3D` camera location is configured in World Space, which is currently the primary reason for interacting with different 3D coordinate systems.
     *
     * For example, depth sorting of transparent objects by rendering data based on their distance to the camera.
     *
     * Depth sorting is required for blending stacked transparent objects.
     * @deprecated  Deprecated from v4.2, in favour of `coordsWorld`.
     * @public
     */
    readonly world: CoordinateSystemDefinition3D;
    /**
     * Method for adding a new `PointSeries3D` to the chart.
     * This series type for visualizing a collection of `{ x, y, z }` coordinates by different markers.
     *
     * `PointSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to {@link PointSeries3D}.
     *
     * **Readonly configuration:**
     *
     * Some properties of `PointSeries3D` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const pointCloudSeries3D = Chart3D.addPointSeries({
     *      // Specify point series type as point cloud.
     *      type: PointSeriesTypes3D.Pixelated
     *  })
     * ```
     *
     * To learn about available properties, refer to {@link PointSeriesOptions3D}.
     *
     * @param options - Optional object with readonly configuration arguments for `PointSeries3D`.
     * @returns New series.
     * @public
     */
    addPointSeries<T extends PointSeriesTypes3D = typeof PointSeries3D>(options?: PointSeriesOptions3D<T>): InstanceType<T>;
    /**
     * Method for adding a new `LineSeries3D` to the chart.
     * This Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke.
     *
     * `LineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to {@link LineSeries3D}.
     *
     * @returns New series.
     * @public
     */
    addLineSeries(options?: SeriesOptions): LineSeries3D;
    /**
     * Method for adding a new `PointLineSeries3D` to the chart.
     * This Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke and markers.
     *
     * `PointLineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * To learn more about its features and usage, refer to {@link PointLineSeries3D}.
     *
     * @returns New series.
     * @public
     */
    addPointLineSeries(options?: SeriesOptions): PointLineSeries3D;
    /**
     * Add a Series for visualizing a *Surface Grid* with a static column and grid count. Has API for fast modification of cell Y and Intensity values.
     *
     * The grid is defined by imagining a plane along X and Z axis, split to \< COLUMNS \> (cells along X axis) and \< ROWS \> (cells along Z axis)
     *
     * The total amount of \< CELLS \> in a surface grid is calculated as `columns * rows`. Each \< CELL \> can be associated with DATA from an user data set.
     *
     * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in tens of millions range is rendered in a matter of seconds.
     * - A data set in tens of millions range can be updated in less than a second.
     * - Maximum data set size is entirely limited by available memory (RAM).
     *   Even billion (1 000 000 000) data points have been visualized on a personal computer.
     *   Interacting with massive surface charts (more than tens of millions data points) requires a powerful GPU !
     *
     * To learn more about its features and usage, refer to {@link SurfaceGridSeries3D}.
     *
     *
     * **Readonly configuration:**
     *
     * Some properties of `SurfaceGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
     * They are all wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
     *      columns: 100,
     *      rows: 200,
     *  })
     * ```
     *
     * To learn about these properties, refer to {@link SurfaceGridSeries3DOptions}.
     *
     *
     * For *scrolling surface grid*, see {@link addSurfaceScrollingGridSeries}.
     *
     * @param options - Configuration parameters for Surface Grid Series.
     * @returns Surface Grid Series.
     * @public
     */
    addSurfaceGridSeries(options: SurfaceGridSeries3DOptions): SurfaceGridSeries3D;
    /**
     * Add a Series for visualizing a *Surface Grid* with API for pushing data in a scrolling manner (append new data on top of existing data).
     *
     * The grid is defined by imagining a plane along X and Z axis, split to \< COLUMNS \> (cells along X axis) and \< ROWS \> (cells along Z axis)
     *
     * The total amount of \< CELLS \> in a surface grid is calculated as `columns * rows`. Each \< CELL \> can be associated with DATA from an user data set.
     *
     * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A data set of tens of millions data points is rendered in a matter of seconds.
     * - Maximum data set size is entirely limited by available memory (RAM).
     *   Even billion (1 000 000 000) data points have been visualized on a personal computer.
     *   Interacting with massive surface charts (more than tens of millions data points) requires a powerful GPU !
     * - Scrolling Surface Grid input stream rate is virtually unlimited - even 10 million incoming data points **per second** can easily be processed.
     *   Application limitations usually come from previously mentioned RAM and/or GPU bottlenecks.
     *
     * To learn more about its features and usage, refer to {@link SurfaceScrollingGridSeries3D}.
     *
     *
     * **Readonly configuration:**
     *
     * Some properties of `SurfaceScrollingGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
     * They are all wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const surfaceScrollingGridSeries = Chart3D.addSurfaceScrollingGridSeries({
     *      columns: 100,
     *      rows: 200,
     *  })
     * ```
     *
     * To learn about these properties, refer to {@link SurfaceScrollingGridSeries3DOptions}.
     *
     *
     * For *static surface grid*, see {@link addSurfaceGridSeries}.
     *
     * @param options - Configuration parameters for Surface Scrolling Grid Series.
     * @returns Surface Scrolling Grid Series.
     * @public
     */
    addSurfaceScrollingGridSeries(options: SurfaceScrollingGridSeries3DOptions): SurfaceScrollingGridSeries3D;
    /**
     * Create Series for visualization of large sets of individually configurable 3D *Boxes*.
     *
     * **Example usage:**
     *
     * ```ts
     *  // Construct a grid of vertical boxes.
     *  const data = [
     *      { x: 0, z: 0 },
     *      { x: 1, z: 0 },
     *      { x: 0, z: 1 },
     *      { x: 1, z: 1 }
     *  ]
     *      // Map coords into **BoxData**.
     *      .map( coords => {
     *      const height = Math.random() * 100
     *      return {
     *          xCenter: coords.x,
     *          yCenter: height / 2,
     *          zCenter: coords.z,
     *          xSize: 1,
     *          ySize: height,
     *          zSize: 1
     *      }
     *  })
     *  const chart = lightningChart().Chart3D()
     *  const boxSeries = chart.addBoxSeries()
     *      .invalidateData( data )
     * ```
     *
     * @returns BoxSeries3D.
     * @public
     */
    addBoxSeries(options?: SeriesOptions): BoxSeries3D;
    /**
     * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
     *
     * ```ts
     *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
     *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
     *  // locationRelative is in pixels relative to bottom left corner of the chart
     * ```
     *
     * Relative coordinates can be used for positioning LightningChart JS UI components:
     *
     * ```ts
     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
     *      .setOrigin(UIOrigins.LeftBottom)
     *      .setPosition({ x: 20, y: 20 })
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     * @privateRemarks  This definition of the method originates from the super class.
     */
    translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
    /**
     * Translate a coordinate from relative control coordinates to HTML client coordinate system.
     *
     * ```ts
     *  // 10 pixels left and 20 pixels up from controls bottom left corner
     *  const locationRelative = { x: 10, y: 20 }
     *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
     * ```
     *
     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
     *
     * ```ts
     *  myHTMLElement.style.position = 'absolute'
     *  myHTMLElement.style.left = locationClient.clientX
     *  myHTMLElement.style.top = locationClient.clientY
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     * @privateRemarks  This definition of the method originates from the super class.
     */
    translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
    /**
     * Translate `x, y, z` coordinates between different 3D coordinate systems.
     *
     * ```ts
     *  // Example, translate coordinate from Chart3D Axes to World Space.
     *  const coordWorld = Chart3D.translateCoordinate(
     *      // Coordinate on Axes.
     *      { x: 10, y: 5, z: 25 },
     *      // Source coordinate system.
     *      chart3D.coordsAxis,
     *      // Target coordinate system.
     *      chart3D.coordsWorld
     *  )
     * ```
     *
     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
     *
     * ```ts
     *  LineSeries.add(myData)
     *  requestAnimationFrame(() => {
     *      // translateCoordinate should now consider data added just now.
     *  })
     * ```
     *
     * @public
     */
    translateCoordinate(coordinate: Coordinate3D, srcCoordinateSystem: CoordinateSystemDefinition3D, targetCoordinateSystem: CoordinateSystemDefinition3D): Coordinate3D;
    /**
     * Get Axis X.
     * @returns Axis3D object.
     * @public
     */
    getDefaultAxisX(): Axis3D;
    /**
     * Get Axis Y.
     * @returns Axis3D object.
     * @public
     */
    getDefaultAxisY(): Axis3D;
    /**
     * Get Axis Z.
     * @returns Axis3D object.
     * @public
     */
    getDefaultAxisZ(): Axis3D;
    /**
     * Convenience method to get a tuple of the Charts X, Y and Z axes.
     *
     * Equal to `[Chart3D.getDefaultAxisX(), Chart3D.getDefaultAxisY(), Chart3D.getDefaultAxisZ()]`
     *
     * Intended for conveniently applying same modifications to all axes.
     *
     * ```typescript
     * // Example, disable mouse interactions from all axes.
     * Chart3D.getDefaultAxes().forEach((axis) => axis.setMouseInteractions(false))
     * ```
     *
     * @returns [Chart3D.getDefaultAxisX(), Chart3D.getDefaultAxisY(), Chart3D.getDefaultAxisZ()]
     * @public
     */
    getDefaultAxes(): [Axis3D, Axis3D, Axis3D];
    /**
     * Set the location of camera in _World Space_, a coordinate system that is not tied to 3D Axes.
     *
     * The camera always faces (0, 0, 0) coordinate.
     *
     * The light source is always a set distance behind the camera.
     * @param cameraLocation - Camera location in 3D space. Valid values are in the range **[1, 5]**.
     *                          Note, that placing the camera too close to the bounding box is restricted.
     * @public
     */
    setCameraLocation(cameraLocation: Point3D): this;
    /**
     * Get the location of camera in _World Space_, a coordinate system that is not tied to 3D Axes.
     * @returns Camera location in 3D space.
     * @public
     */
    getCameraLocation(): Point3D;
    /**
     * Get the direction of camera in _World Space_, a coordinate system that is not tied to 3D Axes.
     *
     * The direction is set according to the location of the camera, so that it is facing (0, 0, 0).
     * @returns Camera direction in 3D space. Always an unit vector.
     * @public
     */
    getCameraDirection(): Point3D;
    /**
     * Set automatic camera fitting enabled. This is enabled as the default configuration.
     * Note that zooming in or out disables it automatically.
     * @param enabled - Boolean.
     * @returns Object itself for fluent interface.
     * @public
     */
    setCameraAutomaticFittingEnabled(enabled: boolean): Chart3D;
    /**
     * Get automatic camera fitting enabled. This is enabled as the default configuration.
     * Note that zooming in or out disables it automatically.
     * @returns Boolean.
     * @public
     */
    getCameraAutomaticFittingEnabled(): boolean;
    /**
     * Subscribe to camera change event.
     *
     * This event is triggered whenever the location of `Chart3D` camera is changed.
     *
     * @param handler - function which is triggered on event. Receives two parameters: `chart`, and `cameraLocation`.
     * @returns Token which can be used with {@link offCameraChange} to unsubscribe the event handler.
     * @public
     */
    onCameraChange(handler: (chart: Chart3D, cameraLocation: Point3D) => unknown): Token;
    /**
     * Unsubscribe from camera change event.
     *
     * This event is triggered whenever the location of `Chart3D` camera is changed.
     *
     * @param token - Token which was received from {@link onCameraChange}.
     * @returns True if the listener is successfully removed and false if it is not found
     * @public
     */
    offCameraChange(token: Token): boolean;
    /**
     * Set style of 3D bounding box.
     *
     * The bounding box is a visual reference that all the data of the Chart is depicted inside of. The Axes of the
     * 3D chart are always positioned along the sides of the bounding box.
     *
     * Example usage:
     *
     * - **Specify explicit LineStyle object**
     * ```typescript
     *  Chart3D.setBoundingBoxStrokeStyle(new SolidLine({
     *      fillStyle: new SolidFill({ color: ColorHEX('#61ff61') }),
     *      thickness: 5
     *  }))
     * ```
     *
     * - **Modify default style**
     * ```typescript
     *  // Default value is SolidLine (note that a soft type cast is required for *TypeScript*).
     *  Chart3D.setBoundingBoxStrokeStyle(( line: SolidLine ) => line
     *      .setThickness( 10 )
     *  )
     * ```
     * @param value - {@link LineStyle} object or function that modifies previous value.
     *                  Value defaults to {@link SolidLine}.
     * @returns Object itself for fluent interface.
     * @public
     */
    setBoundingBoxStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
    /**
     * Get style of 3D bounding box.
     *
     * The bounding box is a visual reference that all the data of the Chart is depicted inside of. The Axes of the
     * 3D chart are always positioned along the sides of the bounding box.
     *
     * @returns {@link LineStyle} object.
         * @public
         */
     getBoundingBoxStrokeStyle(): LineStyle;
     /**
      * Set the dimensions of the Scenes bounding box.
      *
      * The bounding box is a visual reference that all the data of the Chart is depicted inside of. The Axes of the
      * 3D chart are always positioned along the sides of the bounding box.
      *
      * Example usage:
      * - **Symmetric bounding box**
      * ```javascript
      *  setBoundingBox( { x: 1.0, y: 1.0, z: 1.0 } )
      * ```
      * - **Bounding box whose Y dimension is 4 times that of the others**
      * ```javascript
      *  setBoundingBox( { x: 1.0, y: 4.0, z: 1.0 } )
      * ```
      *
      * @param dimensions - Dimensions of bounding box. These values do not represent any "unit", only their relative
      *                          ratios are considered.
      * @returns Object itself for fluent interface
      * @public
      */
     setBoundingBox(dimensions: Point3D): this;
     /**
      * Get dimensions of Scenes "bounding box".
      * Bounding box defines the space allocated for the Charts 3D Axes.
      *
      * It is visualized with a wireframe, as well as 3D Axes on its sides.
      * @returns Dimensions of bounding box as World Units.
      * @public
      */
     getBoundingBox(): Point3D;
     /**
      * **Permanently** destroy the component.
      *
      * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
      * **to the component and its children** in application code.
      * ```javascript
      * let chart = ...ChartXY()
      * let axisX = chart.getDefaultAxisX()
      * // Dispose Chart, and remove all references so that they can be garbage-collected.
      * chart.dispose()
      * chart = undefined
      * axisX = undefined
      * ```
      * @returns Object itself for fluent interface
      * @public
      */
     dispose(): this;
     /**
      * NOTE: Not just Chart3D, but also 2D !! _updateScale must be called, when padding/margin/title, etc are changed !!!
      * Event handler to update 3D viewport when Chart is resized.
      */
     private _handleResize;
     /**
      * Set all mouse-interaction flags at once.
      *
      * Affects rotation and zooming. Same as calling both {@link setMouseInteractionZoom} and {@link setMouseInteractionRotate}.
      * @param enabled - Are mouse-interactions enabled
      * @returns Object itself
      * @public
      */
     setMouseInteractions(enabled: boolean): this;
     /**
      * Set is mouse-interaction enabled:
      * Zooming axes with mouse-wheel or by touch.
      * @param enabled - Boolean flag
      * @returns Object itself
      * @public
      */
     setMouseInteractionZoom(enabled: boolean): this;
     /**
      * Get is mouse-interaction enabled:
      * Zooming axes with mouse-wheel or by touch.
      * @returns Boolean flag
      * @public
      */
     getMouseInteractionZoom(): boolean;
     /**
      * Set is mouse-interaction enabled:
      * Rotating axes with mouse-drag or by touch.
      * @param enabled - Boolean flag
      * @returns Object itself
      * @public
      */
     setMouseInteractionRotate(enabled: boolean): this;
     /**
      * Get is mouse-interaction enabled:
      * Rotating  axes with mouse-drag or by touch.
      * @returns Boolean flag
      * @public
      */
     getMouseInteractionRotate(): boolean;
     /**
      * Operate on each axis of chart, x and y
      * @param clbk - Callback function for axis
      * @public
      */
     forEachAxis(clbk: (axis: Axis3D) => void): this;
     /**
      * Get series of a chart
      * @returns Array of series
      * @public
      */
     getSeries(): Series3D[];
     /**
      * Get minimum size of Chart.
      * Depending on the type of class this value might be automatically computed to fit different elements.
      * @returns Vec2 minimum size or undefined if unimplemented
      * @public
      */
     getMinimumSize(): Point | undefined;
     /**
      * Disable/Enable all animations for the chart.
      *
      * Affects:
      * - Axis animations.
      * - Zoom animation.
      * - Series highlight animations.
      *
      * @param animationsEnabled - Boolean value to enable/disable all animations
      * @returns Chart itself for fluent interface.
      * @public
      * @privateRemarks  Override to also apply to axes and zoom.
      */
     setAnimationsEnabled(animationsEnabled: boolean): this;
     /**
      * Set Chart3D zoom animation enabled.
      *
      * When enabled, zooming with mouse wheel or trackpad will include a short animation.
      *
      * This is enabled by default.
      *
      * ```typescript
      *  // Example syntax, disable zoom animation.
      *  chart3D.setAnimationZoom(false)
      * ```
      * @param animationsEnabled - Boolean.
      * @returns Chart itself for fluent interface.
      * @public
      */
     setAnimationZoom(animationsEnabled: boolean | undefined): this;
     /**
      * Get Chart3D zoom animation enabled.
      *
      * When enabled, zooming with mouse wheel or trackpad will include a short animation.
      *
      * This is enabled by default.
      *
      * ```typescript
      *  // Example syntax, disable zoom animation.
      *  chart3D.setAnimationZoom(false)
      * ```
      * @returns Boolean.
      * @public
      */
     getAnimationZoom(): boolean;
    }
    /**
     * Interface that can be used to define {@link ChartOptions3D} configurations, when inside a {@link Dashboard},
     * that can't be changed after creation.
     * @public
     */
    export declare interface Chart3DDashboardOptions extends DashboardCellOptions, ChartOptions3D {
    }
    /**
     * Interface that defines end user API for a 'Chart'.
     * @public
     */
    export declare interface ChartAPI {
        /**
         * Set text displayed by charts built-in title component.
         *
         * ```typescript
         *  // Example, set title.
         *  ChartXY.setTitle('Realtime traffic visualization')
         * ```
         *
         * **NOTE: To hide title, AND remove padding around it, ** use `setTitleFillStyle(emptyFill)`
         *
         * @param title - Chart title as a string.
         * @returns Object itself for fluent interface.
         * @public
         */
        setTitle(title: string): this;
        /**
         * Get text of Chart title.
         * @returns Chart title as a string.
         * @public
         */
        getTitle(): string;
        /**
         * Set fill style of Chart Title.
         *
         * Example usage:
         *```javascript
         * // Create a new style
         * setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
         * // Change transparency
         * setTitleFillStyle((solidFill) => solidFill.setA(80))
         * // Set hidden
         * setTitleFillStyle(emptyFill)
         * ```
         * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
         * @returns Chart itself
         * @public
         */
        setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of Chart Title.
         * @returns FillStyle object
         * @public
         */
        getTitleFillStyle(): FillStyle;
        /**
         * Set font of Chart Title.
         *
         * Example usage:
         *```javascript
         * // Create a new FontSettings
         * setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
         * // Change existing settings
         * setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
         * ```
         *
         * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
         * @returns Chart itself
         * @public
         */
        setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get font of Chart title.
         * @returns FontSettings object
         * @public
         */
        getTitleFont(): FontSettings;
        /**
         * Specifies Margins after chart title. This can be used to account for extra space around the title as well as tweak its position.
         *
         * This does not have an effect if title is hidden (empty FillStyle or text content `''`).
         *
         * ```typescript
         *  // Example 1, specify complete margin for Title (four sides).
         *  ChartXY.setTitleMargin({ left: 16, right: 16, top: 32, bottom: 8 })
         * ```
         *
         * ```typescript
         *  // Example 2, specify only single margin for Title.
         *  ChartXY.setTitleMargin({ right: 64 })
         * ```
         * ```typescript
         *  // Example 3, specify margins for all sides with same value for Title.
         *  ChartXY.setTitleMargin(40)
         * ```
         *
         * ```typescript
         *  // Example 4, reset to default margins.
         *  ChartXY.setTitleMargin({})
         * ```
         *
         * @param marginPixels - Gap after the chart title in pixels.
         * @returns Chart itself for fluent interface
         * @public
         */
        setTitleMargin(marginPixels: Partial<Margin> | pixel): this;
        /**
         * Get title margins.
         *
         * `undefined` values refer to default title margins.
         * @returns Margin after Chart title
         * @public
         */
        getTitleMargin(): Partial<Margin>;
        /**
         * Set padding around Chart in pixels.
         *
         * ```typescript
         *  // Example 1, specify complete padding (four sides).
         *  ChartXY.setPadding({ left: 16, right: 16, top: 32, bottom: 8 })
         * ```
         *
         * ```typescript
         *  // Example 2, specify only single padding.
         *  ChartXY.setPadding({ right: 64 })
         * ```
         * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
         *                      for each side. Any side can be omitted, only passed values will be overridden.
         * @returns Object itself for fluent interface
         * @public
         */
        setPadding(padding: Partial<Margin> | number): this;
        /**
         * Get padding around Chart in pixels.
         * @returns Padding datastructure
         * @public
         */
        getPadding(): Margin;
        /**
         * Set {@link FillStyle} of chart background.
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `FillStyle` or function which mutates the active `FillStyle`.
         * @returns Object itself
         * @public
         */
        setBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fillstyle of chart background.
         * @returns FillStyle
         * @public
         */
        getBackgroundFillStyle(): FillStyle;
        /**
         * Set {@link LineStyle} of chart background border stroke.
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setBackgroundStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
         *  }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidLine} to describe a solid line style.
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `LineStyle` or function which mutates the active `LineStyle`.
         * @returns Object itself
         * @public
         */
        setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of chart background.
         * @returns LineStyle
         * @public
         */
        getBackgroundStrokeStyle(): LineStyle;
    }
    /**
     * Abstract base class for "Chart components".
     * Chart component is defined as a mouse-interactable component of a Chart.
     * ChartComponent is a public class, so users can have access to it.
     * @public
     */
    export declare abstract class ChartComponent implements Interactable, Attachable, Highlightable, Hideable, HideableEvents, Disposable, DisposableEvents, ComponentWithEffects {
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getEffect(): boolean;
        /**
         * Subscribe to highlight object event. This is called whenever an object is highlighted.
         * @param handler - Function that is called when event is triggered.
         * @param isHighlighted - The Highlight state.
         * @returns Token that can be used to unsubscribe from the event.
         * @public
         */
        onHighlight(handler: (obj: this, isHighlighted: boolean | number) => void): Token;
        /**
         * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
         * @param token - Token that was received when subscribing to the event.
         * @returns True if the unsubscription was successful.
         * @public
         */
        offHighlight(token: Token): boolean;
        /**
         * Sets the name of the Component
         * updating attached LegendBox entries
         * @param name - Name of the Component
         * @returns Object itself
         * @public
         */
        setName(name: string): this;
        /**
         * Get the name of the Component.
         * @returns The name of the Component.
         * @public
         */
        getName(): string;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         * @public
         */
        setVisible(state: boolean): this;
        /**
         * Get element visibility.
         *
         * @returns `true` when element is set to be visible and `false` otherwise.
         * @public
         */
        getVisible(): boolean;
        /**
         * Register new event listener to `visibleStateChanged` event.
         *
         * @param listener - Event listener for `visibleStateChanged`
         * @public
         */
        onVisibleStateChanged(listener: VisibleStateChangedHandler<this>): Token;
        /**
         * Remove event listener from `visibleStateChanged`
         * @public
         */
        offVisibleStateChanged(token: Token): boolean;
        /**
         * Set state of component highlighting.
         *
         * ```ts
         *  // Example usage
         *
         *  component.setHighlight(true)
         *
         *  component.setHighlight(0.5)
         * ```
         *
         * If highlight animations are enabled (which is true by default), the transition will be animated.
         * As long as the component is highlighted, the active highlight intensity will be animated continuously between 0 and the configured value.
         * Highlight animations can be disabled with {@link setAnimationHighlight}
         *
         * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
         * @returns Object itself
         * @public
         */
        setHighlight(highlight: boolean | number): this;
        /**
         * Get state of component highlighting.
         *
         * In case highlight animations are enabled, this method returns the **unanimated highlight value**.
         *
         * @returns Number between 0 and 1, where 1 is fully highlighted.
         * @public
         */
        getHighlight(): number;
        /**
         * Set component highlight animations enabled or not.
         * For most components this is enabled by default.
         *
         * ```ts
         *  // Example usage, disable highlight animations.
         *  component.setAnimationHighlight(false)
         * ```
         *
         * @param   enabled    - Animation enabled?
         * @returns            Object itself
         */
        setAnimationHighlight(enabled: boolean): this;
        /**
         * Get component highlight animations enabled or not.
         *
         * @returns      Animation enabled?
         */
        getAnimationHighlight(): boolean;
        /**
         * Set component mouse interactions enabled or disabled.
         *
         * Disabling mouse interactions means that the objects below this component can be interacted _through_ it.
         *
         * Possible side-effects from disabling mouse interactions:
         *
         * - **Mouse events are not triggered.** For example, {@link onMouseMove}.
         * - **Mouse driven highlighting will not work**.
         *
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setMouseInteractions(state: boolean): this;
        /**
         * Get mouse interactions enabled or disabled.
         * Disabled mouse-interactions will naturally prevent mouse-driven highlighting from ever happening.
         * @returns Mouse interactions state
         * @public
         */
        getMouseInteractions(): boolean;
        /**
         * Get boolean flag for whether object is currently under mouse or not
         * @returns Boolean for is object under mouse currently
         * @public
         */
        getIsUnderMouse(): boolean;
        /**
         * Set highlight on mouse hover enabled or disabled.
         *
         * Mouse interactions have to be enabled on the component for this to function as expected.
         * See {@link setMouseInteractions} for more information.
         *
         * @param state - True if highlighting on mouse hover, false if no highlight on mouse hover
         * @returns Object itself for fluent interface.
         * @public
         */
        setHighlightOnHover(state: boolean): this;
        /**
         * Get boolean flag for whether object should highlight on mouse hover
         * @returns Boolean for if object should highlight on mouse hover or not.
         * @public
         */
        getHighlightOnHover(): boolean;
        /**
         * Attach object to an legendBox entry
         * @param entry      -                   Object which has to be attached
         * @param toggleVisibilityOnClick -      Flag that indicates whether the Attachable should be hidden or not,
         *                                      when its respective Entry is clicked.
         * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
         * @returns                              Series itself for fluent interface
         */
        attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
        /**
         * Add event listener to Enter Event
         * @param clbk - Event listener for Mouse Enter Event
         * @returns Token of the event listener
         * @public
         */
        onMouseEnter: (clbk: MouseEventHandler<this>) => Token;
        /**
         * Add event listener to Mouse Leave Event
         * @param clbk - Event listener for Mouse Leave Event
         * @returns Token of the event listener
         * @public
         */
        onMouseLeave: (clbk: AbruptMouseEventHandler<this>) => Token;
        /**
         * Add event listener to Mouse Click Event
         * @param clbk - Event listener for Mouse Click Event
         * @returns Token of the event listener
         * @public
         */
        onMouseClick: (clbk: MouseEventHandler<this>) => Token;
        /**
         * Add event listener to Mouse Double Click Event
         * @param clbk - Event listener for Mouse Double Click Event
         * @returns Token of the event listener
         * @public
         */
        onMouseDoubleClick: (clbk: MouseEventHandler<this>) => Token;
        /**
         * Add event listener to Mouse Down Event
         * @param clbk - Event listener for Mouse Down Event
         * @returns Token of the event listener
         * @public
         */
        onMouseDown: (clbk: MouseEventHandler<this>) => Token;
        /**
         * Add event listener to Mouse Up Event
         * @param clbk - Event listener for Mouse Up Event
         * @returns Token of the event listener
         * @public
         */
        onMouseUp: (clbk: MouseEventHandler<this>) => Token;
        /**
         * Add event listener to Mouse Move Event
         * @param clbk - Event listener for Mouse Move Event
         * @returns Token of the event listener
         * @public
         */
        onMouseMove: (clbk: MouseEventHandler<this>) => Token;
        /**
         * Subscribe to Mouse Drag Start event
         * @public
         */
        onMouseDragStart(clbk: MouseDragStartEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Drag event
         * @public
         */
        onMouseDrag(clbk: MouseDragEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Drag Stop event
         * @public
         */
        onMouseDragStop(clbk: MouseDragStopEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Wheel event
         * @param clbk - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseWheel(clbk: MouseWheelEventHandler<this>): Token;
        /**
         * Subscribe to Touch Start event
         * @param clbk - Event handler function
         * @returns Token of subscription
         * @public
         */
        onTouchStart(clbk: TouchEventHandler<this>): Token;
        /**
         * Subscribe to Touch Move event
         * @param clbk - Event handler function
         * @returns Token of subscription
         * @public
         */
        onTouchMove(clbk: TouchEventHandler<this>): Token;
        /**
         * Subscribe to Touch End event
         * @param clbk - Event handler function
         * @returns Token of subscription
         * @public
         */
        onTouchEnd(clbk: TouchEventHandler<this>): Token;
        /**
         * Subscribe `onDispose` event.
         * This event is triggered whenever the ChartComponent is disposed.
         *
         * ```typescript
         *  // Example usage
         *
         * lineSeries.onDispose(() => {
         *   console.log('lineSeries was disposed')
         * })
         *
         * lineSeries.dispose()
         * ```
         *
         * @param clbk - Event handler function
         * @returns Token of subscription
         * @public
         */
        onDispose(clbk: (obj: this) => void): Token;
        /**
         * Remove event listener from Mouse Enter Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseEnter: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Leave Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseLeave: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Click Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseClick: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Double Click Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDoubleClick: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Down Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDown: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Up Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseUp: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Move Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseMove: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Drag Start Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDragStart: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Drag Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDrag: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Drag Stop Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDragStop: (token: Token) => boolean;
        /**
         * Remove event listener from Mouse Wheel Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseWheel: (token: Token) => boolean;
        /**
         * Remove event listener from Touch Start Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offTouchStart(token: Token): boolean;
        /**
         * Remove event listener from Touch Move Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offTouchMove(token: Token): boolean;
        /**
         * Remove event listener from Touch End Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offTouchEnd(token: Token): boolean;
        /**
         * Remove event listener from dispose event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offDispose(token: Token): boolean;
    }
    /**
     * Cursor-based visual that can be plotted on a Chart.
     * Like Cursors its built of two parts:
     * PointMarker and ResultTable, first of which
     * shows the location of the Marker clearly and the second
     * to display information about the pointed DataPoint.
     * @public
     */
    export declare abstract class ChartMarker<ResultTableBackgroundType extends UIBackground = UIBackground, CursorType extends InternalStaticCursor<ResultTableBackgroundType> = InternalStaticCursor<ResultTableBackgroundType>> implements Marker<ResultTableBackgroundType, CursorType>, Hideable, HideableEvents, Disposable, DisposableEvents {
        /**
         * @public
         */
        protected readonly renderingScale: LinearScaleXY;
        /**
         * @public
         */
        readonly scale: ScaleXY;
        /**
         * Set the position of Annotation on its scale.
         * @param position - Position on Annotations scale.
         * @public
         */
        setPosition(position: Point): this;
        /**
         * Get current position of Annotation
         * @returns Position on Annotations scale
         * @public
         */
        getPosition(): Point;
        /**
         * This event is called whenever the position of the Marker is changed
         * @param handler - Function that is called when event is triggered.
         * @param position - New position of Marker.
         * @returns Token that can be used to unsubscribe from the event.
         * @public
         */
        onPositionChange(handler: (marker: this, position: Point) => void): Token;
        /**
         * This event is called whenever the position of the Marker is changed
         * @param token - Token that was received when the subscription was created.
         * @returns True if unsubscription was successful.
         * @public
         */
        offPositionChange(token: Token): boolean;
        /**
         * Set visibility mode for PointMarker.
         * PointMarker is a visual that is displayed at the Cursors position.
         * @param visibilityMode - Defines when part is visible
         * @returns Object itself
         * @public
         */
        setPointMarkerVisibility(visibilityMode: UIVisibilityModes): this;
        /**
         * Get visibility mode for PointMarker.
         * PointMarker is a visual that is displayed at the Cursors position.
         * @returns VisibilityMode
         * @public
         */
        getPointMarkerVisibility(): UIVisibilityModes;
        /**
         * Set visibility mode for ResultTable.
         * ResultTable is a visual that displays currently pointed data next to its location.
         * NOTE: ResultTable is only visible when it has displayable content, regardless of its VisibilityMode!
         * @param visibilityMode - Defines when part is visible
         * @returns Object itself
         * @public
         */
        setResultTableVisibility(visibilityMode: UIVisibilityModes): this;
        /**
         * Get visibility mode for ResultTable.
         * ResultTable is a visual that displays currently pointed data next to its location.
         * @returns VisibilityMode
         * @public
         */
        getResultTableVisibility(): UIVisibilityModes;
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setMouseInteractions(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getMouseInteractions(): boolean;
        /**
         * Set auto-fit strategy of Cursor.
         * Affects logic of automatic fitting of Cursors ResultTable to the screen.
         * @param autoFitStrategy - AutoFitStrategy factory or undefined to disable auto-fitting
         * @returns Object itself for fluent interface
         * @public
         */
        setAutoFitStrategy(autoFitStrategy?: AutoFitStrategyFactory<ResultTableBackgroundType>): this;
        /**
         * Get is auto-fit enabled.
         * Affects logic of automatic fitting of Cursors ResultTable to the screen.
         * @returns Boolean flag whether auto-fit is enabled
         * @public
         */
        getAutoFitStrategy(): boolean;
        /**
         * @returns True if object is attached or not attachable, false if it is not attached and attachable
         * @public
         */
        isAttached(): boolean;
        /**
         * Points the Marker at a given CursorPoint.
         * Updating its position and displayed data.
         * @public
         */
        pointAt(cursorPoint: CursorPoint): this;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * This event is called whenever the Marker is disposed
         * @param handler - Function that is called when event is triggered.
         * @returns Token that can be used to unsubscribe from the event.
         * @public
         */
        onDispose: (handler: () => unknown) => Token;
        /**
         * Remove event listener from dispose event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offDispose: (token: Token) => boolean;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         */
        setVisible(state: boolean): this;
        /**
         * Get element visibility.
         *
         * @returns `true` when element is set to be visible and `false` otherwise.
         */
        getVisible(): boolean;
        /**
         * Register new event listener to `visibleStateChanged` event.
         *
         * @param listener - Event listener for `visibleStateChanged`
         */
        onVisibleStateChanged(listener: VisibleStateChangedHandler<this>): Token;
        /**
         * Remove event listener from `visibleStateChanged`
         */
        offVisibleStateChanged(token: Token): boolean;
        /**
         * Mutator function for PointMarker.
         * PointMarker is a visual that is displayed at the Cursors position
         * @param mutator - Mutator function for PointMarker
         * @returns Object itself for fluent interface
         * @public
         */
        setPointMarker(mutator: Mutator<PointMarker>): this;
        /**
         * Get PointMarker object.
         * PointMarker is a visual that is displayed at the Cursors position
         * @returns PointMarker object
         * @public
         */
        getPointMarker(): PointMarker;
        /**
         * Mutator function for ResultTable.
         * ResultTable is a visual that displays currently pointed data next to its location
         * @param mutator - Mutator function for ResultTable
         * @returns Object itself for fluent interface
         * @public
         */
        setResultTable(mutator: Mutator<ResultTable<ResultTableBackgroundType>>): this;
        /**
         * Get ResultTable object.
         * ResultTable is a visual that displays currently pointed data next to its location
         * @returns ResultTable object
         * @public
         */
        getResultTable(): ResultTable<ResultTableBackgroundType>;
        /**
         * Set dragging mode of object. Defines how the object can be dragged by mouse.
         *
         * See {@link UIDraggingModes} collection for options.
         * @param draggingMode - DraggingMode or undefined to disable dragging
         * @returns Object itself
         * @public
         */
        setDraggingMode(draggingMode?: UIDraggingModes): this;
        /**
         * Get dragging mode of object.
         * Defines how the object can be dragged by mouse.
         * @returns Object itself
         * @public
         */
        getDraggingMode(): UIDraggingModes;
    }
    /**
     * Simple XY Marker that is basically a static cursor.
     * Like CursorXYs its built of four parts:
     * PointMarker shows the location of the Marker,
     * ResultTable displays information of the point
     * and X&Y tickMarkers to show gridstroke on its axes.
     * @public
     */
    export declare class ChartMarkerXY<ResultTableBackgroundType extends UIBackground = UIBackground> extends InternalChartMarkerXY<ResultTableBackgroundType> {
    }
    /**
     * Interface that can be used to define {@link ChartXY} configurations, when inside a {@link Dashboard},
     * that can't be changed after creation. For example:
     *
     * - Specifying TickStrategies for default X or Y Axes'. This is mostly used for creating DateTime Axes.
     *
     * - Supplying a custom Builder for the AutoCursor of Chart. This can be used to modify the AutoCursor on a level,
     * which can't be done during runtime. For example, changing the shape of ResultTable Background, Etc.
     *
     *
     *  Example usage:
     *```javascript
     * // Default
     * undefined
     * // Specified AutoCursor ResultTable Background
     * { chartXYOptions: { autoCursorBuilder: AutoCursorBuilders.XY.setResultTableBackground(UIBackgrounds.Circle) } }
     * ```
     * @public
     */
    export declare interface ChartOptions<CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, ChartXYOptions<CursorResultTableBackgroundType> {
    }
    /**
     * Interface for readonly configuration of {@link Chart3D}.
     *
     * Some properties of `Chart3D` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, specify chart color theme.
     *  const chart = LightningChart.Chart3D({
     *      theme: Themes.light
     *  })
     * ```
     *
     * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
     *
     * For *standalone* `Chart3D`, more parameters are documented in {@link LightningChart.Chart3D}.
     *
     * For *dashboard* `Chart3D`, more parameters are documented in {@link Dashboard.createChart3D}.
     *
     *
     * **Commonly used properties:**
     *
     * - [theme]({@link ChartOptions3D.theme}): Specify chart color *theme*.
     * - [animationsEnabled]({@link ChartOptions3D.animationsEnabled}): Convenience flag to disable all animations from chart.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create chart with default configuration.
     *  const chart = LightningChart.Chart3D({})
     * ```
     *
     * ```typescript
     *  // Example 2, create chart with specified color theme.
     *  const chart = LightningChart.Chart3D({
     *      theme: Themes.light,
     *  })
     * ```
     * @public
     */
    export declare interface ChartOptions3D extends CommonChartOptions {
    }
    /**
     * Type requirement for Charts that own Axes.
     * @public
     */
    export declare interface ChartWithAxis<AxisType extends GenericAxis<any, any, any, any, any>> extends ChartWithSeries {
        /**
         * Iterate over each Axis of Chart.
         * @param clbk - Callback function for each Axis.
         * @returns Object itself.
         * @public
         */
        forEachAxis(clbk: (axis: AxisType) => void): this;
    }
    /**
     * Interface for a chart that has built-in cursor.
     * @public
     */
    export declare interface ChartWithCursor<CursorResultTableBackgroundType extends UIBackground = UIBackground, AutoCursorType extends AutoCursor<CursorResultTableBackgroundType> = AutoCursor<CursorResultTableBackgroundType>> extends Chart {
        /**
         * Style chart `AutoCursor` using a callback function.
         *
         * ```typescript
         *  // Example syntax
         *  ChartXY.setAutoCursor((autoCursor) => autoCursor
         *      // `autoCursor` is of type AutoCursorXY, use its API for styling the cursor.
         *      .setGridStrokeXStyle(new SolidLine({
         *          thickness: 1,
         *          fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
         *      }))
         *  )
         * ```
         *
         * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
         *
         * **Example usage:**
         *
         * ```typescript
         *  // Example 1, disable Y Axis tick marker & grid line.
         *  ChartXY.setAutoCursor((autoCursor) => autoCursor
         *      .setTickMarkerYVisible(false)
         *      .setGridStrokeYStyle(emptyLine),
         *  )
         * ```
         *
         * ```typescript
         *  // Example 2, style AutoCursor ResultTable.
         *  ChartXY.setAutoCursor((autoCursor) => autoCursor
         *      .setResultTable((resultTable) => resultTable
         *          .setOrigin(UIOrigins.LeftTop)
         *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         *          .setTextFont((font) => font
         *              .setSize(12)
         *              .setFamily('sans-serif')
         *          )
         *          .setBackground((background) => background
         *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
         *          )
         *      )
         *  )
         * ```
         *
         * ```typescript
         *  // Example 3, style AutoCursor TickMarker X.
         *  ChartXY.setAutoCursor((autoCursor) => autoCursor
         *      .setTickMarkerX((tickMarker: UIPointableTextBox) => tickMarker
         *          .setTextFont((font) => font.setWeight('bold'))
         *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(0, 255, 0) }))
         *          .setBackground((background) => background.setFillStyle(emptyFill).setStrokeStyle(emptyLine)),
         *      )
         *  )
         * ```
         *
         * @param mutator - Callback function that receives reference to the charts `AutoCursor`.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAutoCursor(mutator: Mutator<AutoCursorType>): this;
        /**
         * Get reference to charts `AutoCursor`.
         *
         * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
         *
         * @returns `AutoCursor`.
         * @public
         */
        getAutoCursor(): AutoCursorType;
        /**
         * Set chart `AutoCursor` behavior, by selecting a preset option from {@link AutoCursorModes}.
         *
         * Possible values:
         * - `AutoCursorModes.snapToClosest` (default) | *AutoCursor* snaps to closest data point from mouse location.
         * - `AutoCursorModes.onHover` | *AutoCursor* is only shown when it is directly over a *series*. NOTE: Series mouse interactions must be enabled for this to work!
         * - `AutoCursorModes.disabled` | *AutoCursor* is disabled
         *
         * ```typescript
         *  // Example, disable AutoCursor
         *  ChartXY.setAutoCursorMode(AutoCursorModes.disabled)
         * ```
         *
         * **Related information:**
         *
         * On *series* level, *AutoCursor* behavior can be configured individually for each *series*, and there are also more *series* specific options available.
         * Here is `LineSeries` for example:
         *
         * - {@link Series2D.setCursorEnabled} | configure whether cursor should pick on the series or not.
         * - {@link SeriesXY.setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
         * - {@link LineSeries.setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
         * - {@link SeriesXY.setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
         *
         * @param mode - Selection of *AutoCursor* behavior.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAutoCursorMode(mode: AutoCursorModes): this;
        /**
         * Get `AutoCursor` behavior, from a collection of preset options ({@link AutoCursorModes}).
         * @returns Active selection of *AutoCursor* behavior.
         * @public
         */
        getAutoCursorMode(): AutoCursorModes;
    }
    /**
     * Class abstraction layer for Charts that have Series.
     *
     * NOTE: Sub classes are responsible for calling series_.beforePlot and series._afterPlot !!
     * @public
     * @privateRemarks  Adds shared functionalities for: Series Background, attaches Series to Legends
     */
    export declare abstract class ChartWithSeries<_SeriesType extends _InternalSeries = _InternalSeries> extends Chart implements ChartWithStylableSeriesBackground {
        /**
         * Get series of a chart
         * @returns Array of series
         * @public
         */
        abstract getSeries(): _SeriesType[];
        /**
         * Disable/Enable all animations of the Chart.
         * @param animationsEnabled - Boolean value to enable or disable animations.
         * @returns Chart itself for fluent interface.
         * @public
         * @privateRemarks  Override to also apply state to series.
         */
        setAnimationsEnabled(animationsEnabled: boolean): this;
        /**
         * Set {@link FillStyle} of *series background* (area behind *series*).
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 60, 0, 0 ) }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * **Transparent chart backgrounds:**
         *
         * LightningChart JS charts can be configured to be fully or partially transparent.
         *
         * ```ts
         *  // Example, partially transparent chart
         *
         *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
         *  chart.engine.setBackgroundFillStyle(emptyFill)
         *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
         *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
         *  // Some charts also have a separate series background.
         *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
         * ```
         *
         * @param value - `FillStyle` or function which mutates the active `FillStyle`.
         * @returns Object itself
         * @public
         */
        setSeriesBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get FillStyle of Series background area (area behind series).
         * @returns FillStyle
         * @public
         */
        getSeriesBackgroundFillStyle(): FillStyle;
        /**
         * Set {@link LineStyle} of series background border stroke.
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setSeriesBackgroundStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
         *  }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidLine} to describe a solid line style.
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `LineStyle` or function which mutates the active `LineStyle`.
         * @returns Object itself
         * @public
         */
        setSeriesBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get Stroke style of Series background area (area behind series).
         * @returns LineStyle
         * @public
         */
        getSeriesBackgroundStrokeStyle(): LineStyle;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setSeriesBackgroundEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getSeriesBackgroundEffect(): boolean;
        /**
         * Set the state for all Series in the Chart to highlight on mouse hover.
         * @param state - True if all Series should be highlighted on mouse hover, false if not.
         * @returns Object itself for fluent interface.
         * @public
         */
        setSeriesHighlightOnHover(state: boolean): this;
        /**
         * **Permanently** dispose the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Subscribe to mouse-enter event on Series Background
         * @public
         */
        onSeriesBackgroundMouseEnter: (handler: MouseEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-leave event on Series Background
         * @public
         */
        onSeriesBackgroundMouseLeave: (handler: MouseEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-move event on Series Background
         * @public
         */
        onSeriesBackgroundMouseMove: (handler: MouseEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-down event on Series Background
         * @public
         */
        onSeriesBackgroundMouseDown: (handler: MouseEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-up event on Series Background
         * @public
         */
        onSeriesBackgroundMouseUp: (handler: MouseEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-click event on Series Background
         * @public
         */
        onSeriesBackgroundMouseClick: (handler: MouseEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-doubleClick event on Series Background
         * @public
         */
        onSeriesBackgroundMouseDoubleClick: (handler: MouseEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-drag start event on Series Background
         * @public
         */
        onSeriesBackgroundMouseDragStart: (handler: MouseDragStartEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-drag event on Series Background
         * @public
         */
        onSeriesBackgroundMouseDrag: (handler: MouseDragEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-drag stop event on Series Background
         * @public
         */
        onSeriesBackgroundMouseDragStop: (handler: MouseDragStopEventHandler<this>) => Token;
        /**
         * Subscribe to mouse-wheel event on Series Background
         * @public
         */
        onSeriesBackgroundMouseWheel: (handler: MouseWheelEventHandler<this>) => Token;
        /**
         * Subscribe to touch start event on Series Background
         * @public
         */
        onSeriesBackgroundTouchStart: (handler: TouchEventHandler<this>) => Token;
        /**
         * Subscribe to touch move event on Series Background
         * @public
         */
        onSeriesBackgroundTouchMove: (handler: TouchEventHandler<this>) => Token;
        /**
         * Subscribe to touch end event on Series Background
         * @public
         */
        onSeriesBackgroundTouchEnd: (handler: TouchEventHandler<this>) => Token;
        /**
         * Remove event listener from mouse-enter event on Series Background
         * @public
         */
        offSeriesBackgroundMouseEnter: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-leave event on Series Background
         * @public
         */
        offSeriesBackgroundMouseLeave: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-move event on Series Background
         * @public
         */
        offSeriesBackgroundMouseMove: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-down event on Series Background
         * @public
         */
        offSeriesBackgroundMouseDown: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-up event on Series Background
         * @public
         */
        offSeriesBackgroundMouseUp: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-click event on Series Background
         * @public
         */
        offSeriesBackgroundMouseClick: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-doubleClick event on Series Background
         * @public
         */
        offSeriesBackgroundMouseDoubleClick: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-drag start event on Series Background
         * @public
         */
        offSeriesBackgroundMouseDragStart: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-drag event on Series Background
         * @public
         */
        offSeriesBackgroundMouseDrag: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-drag stop event on Series Background
         * @public
         */
        offSeriesBackgroundMouseDragStop: (token: Token) => boolean;
        /**
         * Remove event listener from mouse-wheel event on Series Background
         * @public
         */
        offSeriesBackgroundMouseWheel: (token: Token) => boolean;
        /**
         * Remove event listener from touch start event on Series Background
         * @public
         */
        offSeriesBackgroundTouchStart: (token: Token) => boolean;
        /**
         * Remove event listener from touch move event on Series Background
         * @public
         */
        offSeriesBackgroundTouchMove: (token: Token) => boolean;
        /**
         * Remove event listener from touch end event on Series Background
         * @public
         */
        offSeriesBackgroundTouchEnd: (token: Token) => boolean;
    }
    /**
     * Interface for Chart with stylable series background (area behind series).
     * @public
     */
    export declare interface ChartWithStylableSeriesBackground {
        /**
         * Set {@link FillStyle} of *series background* (area behind *series*).
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 60, 0, 0 ) }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `FillStyle` or function which mutates the active `FillStyle`.
         * @returns Object itself
         * @public
         */
        setSeriesBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get FillStyle of Series background area (area behind series).
         * @returns FillStyle
         * @public
         */
        getSeriesBackgroundFillStyle(): FillStyle;
        /**
         * Set {@link LineStyle} of series background border stroke.
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.setSeriesBackgroundStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
         *  }))
         * ```
         *
         * **Related API:**
         * - Use {@link SolidLine} to describe a solid line style.
         * - Use {@link SolidFill} to describe a solid fill color.
         * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
         *
         * @param value - `LineStyle` or function which mutates the active `LineStyle`.
         * @returns Object itself
         * @public
         */
        setSeriesBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get Stroke style of Series background area (area behind series).
         * @returns LineStyle
         * @public
         */
        getSeriesBackgroundStrokeStyle(): LineStyle;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setSeriesBackgroundEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getSeriesBackgroundEffect(): boolean;
    }
    /**
     * Chart type for visualizing data between two dimensions, **X** and **Y**.
     * It has built-in *Axis* functionality, and supports a large set of *series* types.
     *
     * `ChartXY` can be created in two different ways - to learn more about creation time configuration of `ChartXY`, please refer to:
     * - {@link LightningChart.ChartXY} (stand-alone chart).
     * - {@link Dashboard.createChartXY} (chart inside *dashboard*).
     *
     * **ChartXY features**
     *
     * 1. Axes
     *
     * `ChartXY` always has at least one X and Y *axes*.
     *
     * The default `Axis` can be referenced with {@link ChartXY.getDefaultAxisX} and
     * {@link ChartXY.getDefaultAxisY}.
     * See {@link Axis} for features of *axis*.
     *
     * `ChartXY` doesn't have a limit on number of *axes*.
     * Additional *axes* can be created with {@link ChartXY.addAxisX} and
     * {@link ChartXY.addAxisY}.
     * Multiple *Axes* can be stacked on top of another, and *axes* can be positioned on either side of
     * the *chart* (left, right, top, bottom, see {@link AxisOptions}).
     *
     * 2. Series
     *
     * `ChartXY` supports a variety of different *series* types, each with their own method of data visualization.
     * *Series* are created with `ChartXY.add...Series` methods, for example:
     * - {@link ChartXY.addLineSeries}
     * - {@link ChartXY.addPointSeries}
     * - {@link ChartXY.addHeatmapGridSeries}
     * - {@link ChartXY.addOHLCSeries}
     *
     * When created, a *series* is always attached to a pair of *X* and *Y Axes*.
     * The *Axes* can be specified by user, or the *chart default Axes* will be used.
     *
     * 3. AutoCursor
     *
     * *Auto cursor* is activated when the users mouse is over the chart.
     * It automatically solves the nearest *data point* to the mouse, and displays it to the user over the chart in a *result table*.
     *
     * *Auto cursor* can be configured in a variety of ways;
     * on *chart level*, the cursor behavior and style can be specified using:
     * - {@link ChartXY.setAutoCursorMode} | set auto cursor behavior.
     * - {@link ChartXY.setAutoCursor} | style auto cursor.
     *
     * On *series level*, the cursor behavior can be configured individually for each *series*:
     * - {@link LineSeries.setCursorEnabled} | configure whether cursor should pick on the series or not.
     * - {@link LineSeries.setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
     * - {@link LineSeries.setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
     * - {@link LineSeries.setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
     *
     * 4. LegendBox
     *
     * `ChartXY` has built-in *legend box* functionality for listing the *series* names in a *user interface*.
     * The *legend box* also provides additional logic, like hiding selected *series* by clicking on the *legend box*,
     * and visualizing *color look-up tables* ({@link LUT}) in applications where they are used.
     *
     * *Legend box* is added using {@link ChartXY.addLegendBox}.
     *
     * 5. Title
     *
     * `ChartXY` has a built-in *title* component, which can be configured using {@link ChartXY.setTitle}.
     *
     * 6. Backgrounds
     *
     * `ChartXY` contains two separate *background* components:
     * - *Background* ({@link ChartXY.setBackgroundFillStyle}).
     * - *Series Background* ({@link ChartXY.setSeriesBackgroundFillStyle}).
     *
     * 7. UI Elements
     *
     * Custom *UI elements* can be placed on `ChartXY` in same way as all other *charts*, using {@link ChartXY.addUIElement}.
     *
     * **Other APIs worthy of mention:**
     *
     * - Empty space around `ChartXY` can be configured with {@link ChartXY.setPadding}.
     * - Additional margin around *chart title* can be configured with {@link ChartXY.setTitleMargin}.
     * - All animations can be conveniently controlled with {@link ChartXY.setAnimationsEnabled}.
     * - `ChartXY` can be removed permanently with {@link ChartXY.dispose}.
     * - Some useful events that can be subscribed to:
     *      * *Resize events* ({@link ChartXY.onResize}).
     *      * *Background events* ({@link ChartXY.onBackgroundMouseMove}).
     *      * *Series Background events* ({@link ChartXY.onSeriesBackgroundMouseMove}).
     *
     * @public
     */
    export declare class ChartXY<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<SeriesXY> implements ChartWithAxis<Axis>, ChartWithCursor<CursorResultTableBackgroundType, AutoCursorXY<CursorResultTableBackgroundType>> {
        /**
         * Selector for default Axis Coordinate System, measured along the active default X and Y axes of the chart.
         *
         * This is a convenience selector that is equal to following declaration:
         *
         * ```ts
         *  { x: ChartXY.getDefaultAxisX(), y: ChartXY.getDefaultAxisY() }
         * ```
         *
         * This selector can be used for translating Axis coordinates to other coordinate systems and vice versa.
         * For example, in order to:
         * - Position LCJS UI elements in Axis coordinates
         * - Find client coordinate that matches an X and Y location along the Axes
         * - Translating user click event location to a pair of Axes
         * - etc.
         *
         * See {@link translateCoordinate} for more detailed use case information and example usage.
         *
         * @public
         */
        get coordsAxis(): CoordinateSystemAxis;
        /**
         * Get series of a chart
         * @returns Array of series
         * @public
         */
        getSeries(): SeriesXY[];
        /**
         * Style chart `AutoCursor` using a callback function.
         *
         * ```typescript
         *  // Example syntax
         *  ChartXY.setAutoCursor((autoCursor) => autoCursor
         *      // `autoCursor` is of type AutoCursorXY, use its API for styling the cursor.
         *      .setGridStrokeXStyle(new SolidLine({
         *          thickness: 1,
         *          fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
         *      }))
         *  )
         * ```
         *
         * See {@link AutoCursorXY} for all available methods for configuring the `AutoCursor`.
         *
         * **Example usage:**
         *
         * ```typescript
         *  // Example 1, disable Y Axis tick marker & grid line.
         *  ChartXY.setAutoCursor((autoCursor) => autoCursor
         *      .setTickMarkerYVisible(false)
         *      .setGridStrokeYStyle(emptyLine),
         *  )
         * ```
         *
         * ```typescript
         *  // Example 2, style AutoCursor ResultTable.
         *  ChartXY.setAutoCursor((autoCursor) => autoCursor
         *      .setResultTable((resultTable) => resultTable
         *          .setOrigin(UIOrigins.LeftTop)
         *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         *          .setTextFont((font) => font
         *              .setSize(12)
         *              .setFamily('sans-serif')
         *          )
         *          .setBackground((background) => background
         *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
         *          )
         *      )
         *  )
         * ```
         *
         * ```typescript
         *  // Example 3, style AutoCursor TickMarker X.
         *  ChartXY.setAutoCursor((autoCursor) => autoCursor
         *      .setTickMarkerX((tickMarker: UIPointableTextBox) => tickMarker
         *          .setTextFont((font) => font.setWeight('bold'))
         *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(0, 255, 0) }))
         *          .setBackground((background) => background.setFillStyle(emptyFill).setStrokeStyle(emptyLine)),
         *      )
         *  )
         * ```
         *
         * @param mutator - Callback function that receives reference to the charts `AutoCursor`.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAutoCursor(mutator: Mutator<AutoCursorXY<CursorResultTableBackgroundType>>): this;
        /**
         * Get reference to charts `AutoCursor`.
         *
         * See {@link AutoCursorXY} for all available methods for configuring the `AutoCursor`.
         *
         * @returns `AutoCursor`.
         * @public
         */
        getAutoCursor(): AutoCursorXY<CursorResultTableBackgroundType>;
        /**
         * Set chart `AutoCursor` behavior, by selecting a preset option from {@link AutoCursorModes}.
         *
         * Possible values:
         * - `AutoCursorModes.snapToClosest` (default) | *AutoCursor* snaps to closest data point from mouse location.
         * - `AutoCursorModes.onHover` | *AutoCursor* is only shown when it is directly over a *series*. NOTE: Series mouse interactions must be enabled for this to work!
         * - `AutoCursorModes.disabled` | *AutoCursor* is disabled
         *
         * ```typescript
         *  // Example, disable AutoCursor
         *  ChartXY.setAutoCursorMode(AutoCursorModes.disabled)
         * ```
         *
         * **Related information:**
         *
         * On *series* level, *AutoCursor* behavior can be configured individually for each *series*, and there are also more *series* specific options available.
         * Here is `LineSeries` for example:
         *
         * - {@link Series2D.setCursorEnabled} | configure whether cursor should pick on the series or not.
         * - {@link SeriesXY.setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
         * - {@link LineSeries.setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
         * - {@link SeriesXY.setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
         *
         * @param mode - Selection of *AutoCursor* behavior.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAutoCursorMode(mode: AutoCursorModes): this;
        /**
         * Get `AutoCursor` behavior, from a collection of preset options ({@link AutoCursorModes}).
         * @returns Active selection of *AutoCursor* behavior.
         * @public
         */
        getAutoCursorMode(): AutoCursorModes;
        /**
         * Get minimum size of Panel.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns Vec2 minimum size or undefined if unimplemented
         * @public
         */
        getMinimumSize(): Point | undefined;
        /**
         * Create new XY Chart Marker to be rendered as part of UI.
         * @param cursorBuilder - Optional StaticCursorBuilderXY to customize the markers background shape (defaults to rectangle). See {@link MarkerBuilders} for example.
         * @param axisX - Optional arbitrary X axis to attach ChartMarker on
         * @param axisY - Optional arbitrary Y axis to attach ChartMarker on
         * @returns Created ChartMarker
         * @public
         */
        addChartMarkerXY<ResultTableBackgroundType extends UIBackground = UIBackground>(cursorBuilder?: StaticCursorXYBuilder<ResultTableBackgroundType>, axisX?: Axis, axisY?: Axis): ChartMarkerXY<ResultTableBackgroundType>;
        /**
         * Add new *X Axis* to the *Chart*.
         *
         * **Example usage**:
         *
         * - Configure Axis on opposite side to default configuration (right).
         *
         * ```typescript
         *  ChartXY.addAxisX({
         *      opposite: true,
         *  })
         * ```
         *
         * - Configure Axis as logarithmic (10 base).
         *
         * ```typescript
         *  ChartXY.addAxisX({
         *      type: 'logarithmic',
         *      base: 10,
         *  })
         * ```
         *
         * - Configure Axis as logarithmic (natural base).
         *
         * ```typescript
         *  ChartXY.addAxisX({
         *      type: 'logarithmic',
         *      base: 'natural',
         *  })
         * ```
         *
         * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
         *
         * List of series that support logarithmic Axes:
         * - {@link LineSeries}
         * - {@link PointSeries}
         * - {@link PointLineSeries}
         * - {@link StepSeries}
         * - {@link SplineSeries}
         * - {@link AreaSeries}
         * - {@link AreaRangeSeries}
         * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
         * - {@link RectangleSeries}
         * - {@link SegmentSeries}
         *
         * List of series that do **not** support logarithmic Axes:
         * - {@link HeatmapGridSeriesIntensityValues}
         * - {@link HeatmapScrollingGridSeriesIntensityValues}
         *
         * @param opts - Optional {@link AxisOptions} object for specifying Axis configurations that can't be changed
         *                  during runtime.
         * @returns *Axis* object.
         * @public
         */
        addAxisX(opts?: AxisOptions): Axis;
        /**
         * Add new *Y Axis* to the *Chart*.
         *
         * **Example usage**:
         *
         * - Configure Axis on opposite side to default configuration (right).
         *
         * ```typescript
         *  ChartXY.addAxisY({
         *      opposite: true,
         *  })
         * ```
         *
         * - Configure Axis as logarithmic (10 base).
         *
         * ```typescript
         *  ChartXY.addAxisY({
         *      type: 'logarithmic',
         *      base: 10,
         *  })
         * ```
         *
         * - Configure Axis as logarithmic (natural base).
         *
         * ```typescript
         *  ChartXY.addAxisY({
         *      type: 'logarithmic',
         *      base: 'natural',
         *  })
         * ```
         *
         * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
         *
         * List of series that support logarithmic Axes:
         * - {@link LineSeries}
         * - {@link PointSeries}
         * - {@link PointLineSeries}
         * - {@link StepSeries}
         * - {@link SplineSeries}
         * - {@link AreaSeries}
         * - {@link AreaRangeSeries}
         * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
         * - {@link RectangleSeries}
         * - {@link SegmentSeries}
         *
         * List of series that do **not** support logarithmic Axes:
         * - {@link HeatmapGridSeriesIntensityValues}
         * - {@link HeatmapScrollingGridSeriesIntensityValues}
         *
         * @param opts - Optional {@link AxisOptions} object for specifying Axis configurations that can't be changed
         *                  during runtime.
         * @returns *Axis* object.
         * @public
         */
        addAxisY(opts?: AxisOptions): Axis;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Get reference to the *default X Axis* of the `ChartXY`.
         *
         * This will always return reference to the *X Axis* that is closest to the chart (starting from bottom).
         * The user can safely destroy the *default Axis* (with {@link Axis.dispose}, as long as there are no *series* attached to it).
         * @returns Default X Axis of chart.
         * @public
         */
        getDefaultAxisX(): Axis;
        /**
         * Get reference to the *default Y Axis* of the `ChartXY`.
         *
         * This will always return reference to the *Y Axis* that is closest to the chart (starting from left).
         * The user can safely destroy the *default Axis* (with {@link Axis.dispose}, as long as there are no *series* attached to it).
         * @returns Default Y Axis of chart.
         * @public
         */
        getDefaultAxisY(): Axis;
        /**
         * Convenience method to get a tuple of the Charts default X and Y axes.
         *
         * Equal to `[ChartXY.getDefaultAxisX(), ChartXY.getDefaultAxisY()]`
         *
         * Intended for conveniently applying same modifications to both X and Y axes.
         *
         * ```typescript
         * // Example, disable mouse interactions from both default axes.
         * ChartXY.getDefaultAxes().forEach((axis) => axis.setMouseInteractions(false))
         * ```
         *
         * @returns [chart.getDefaultAxisX(), chart.getDefaultAxisY()]
         * @public
         */
        getDefaultAxes(): [Axis, Axis];
        /**
         * @param axisPositions - array of axis positions which have to be included to the output
         *                          empty array indicates all of positions are included
         * @returns An array of axis
         * @public
         */
        getAxes(...axisPositions: AxisPosition[]): Axis[];
        /**
         * Operate on each x axis of chart
         * @param clbk - Callback function for axis
         * @public
         */
        forEachAxisX(clbk: (axis: Axis, i: number, arr: Axis[]) => void): void;
        /**
         * Operate on each y axis of chart
         * @param clbk - Callback function for axis
         * @public
         */
        forEachAxisY(clbk: (axis: Axis, i: number, arr: Axis[]) => void): void;
        /**
         * Set position of ChartXY title.
         *
         * ```ts
         *  // Example usage
         *  ChartXY.setTitlePosition(ChartXYTitlePositionOptions.LeftTop)
         *
         * // Or
         *  ChartXY.setTitlePosition('left-top')
         *
         * ```
         *
         * For available options, see {@link ChartXYTitlePosition}
         *
         * To tweak title position, you may use {@link ChartXY.setTitleMargin}
         *
         * @param pos - Title position.
         * @public
         */
        setTitlePosition(pos: ChartXYTitlePosition): this;
        /**
         * Get position of ChartXY title.
         *
         * @returns Title position.
         * @public
         */
        getTitlePosition(): ChartXYTitlePosition;
        /**
         * Method for adding a new `LineSeries` to the chart. This series type visualizes a list of {@link Point}s (pair of X and Y coordinates),
         * with a continuous stroke. `LineSeries` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
         *
         * - A static data set in tens of millions range is rendered in a matter of seconds.
         * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
         *
         * To learn more about its features and usage, refer to {@link LineSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `LineSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const lineSeries = ChartXY.addLineSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link LineSeriesOptions}.
         * @param options - Optional object with readonly configuration arguments for `LineSeries`.
         * @returns New series.
         * @public
         */
        addLineSeries(options?: LineSeriesOptions): LineSeries;
        /**
         * Method for adding a new `PointSeries` to the chart. This series type visualizes a list of {@link Point}s (pair of X and Y coordinates),
         * with configurable *markers* over each coordinate. `PointSeries` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
         *
         * - A static data set in tens of millions range is rendered in a matter of seconds.
         * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
         *
         * To learn more about its features and usage, refer to {@link PointSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PointSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const pointSeries = ChartXY.addPointSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link PointSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `PointSeries`.
         * @returns New series.
         * @public
         */
        addPointSeries(options?: PointSeriesOptions): PointSeries;
        /**
         * Method for adding a new `PointLineSeries` to the chart. This series type visualizes a list of {@link Point}s (pair of X and Y coordinates),
         * with a continuous stroke and configurable *markers* over each coordinate. `PointLineSeries` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
         *
         * - A static data set in tens of millions range is rendered in a matter of seconds.
         * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
         *
         * To learn more about its features and usage, refer to {@link PointLineSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PointLineSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const pointLineSeries = ChartXY.addPointLineSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link PointLineSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `PointLineSeries`.
         * @returns New series.
         * @public
         */
        addPointLineSeries(options?: PointLineSeriesOptions): PointLineSeries;
        /**
         * Method for adding a new `StepSeries` to the chart. This series type visualizes a list of {@link Point}s (pair of X and Y coordinates),
         * with a *stepped* stroke + *point markers* over each data point.
         *
         * Possible *step* modes are: `'before'`, `'middle'` and `'after'`.
         *
         * To learn more about its features and usage, refer to {@link StepSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `StepSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const stepSeries = ChartXY.addStepSeries({
         *      // Select shape of point markers.
         *      pointShape: PointShape.Circle
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link StepSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `StepSeries`.
         * @returns New series.
         * @public
         */
        addStepSeries(options?: StepSeriesOptions): StepSeries;
        /**
         * Method for adding a new `SplineSeries` to the chart. This series type visualizes a list of {@link Point}s (pair of X and Y coordinates),
         * with a smoothed curve stroke + *point markers* over each data point.
         *
         * To learn more about its features and usage, refer to {@link SplineSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `SplineSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const splineSeries = ChartXY.addSplineSeries({
         *      // Select shape of point markers.
         *      pointShape: PointShape.Circle
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link SplineSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `SplineSeries`.
         * @returns New series.
         * @public
         */
        addSplineSeries(options?: SplineSeriesOptions): SplineSeries;
        /**
         * Method for adding a new `RectangleSeries` to the chart. This series type visualizes a collection of *rectangles*.
         *
         * To learn more about its features and usage, refer to {@link RectangleSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `RectangleSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const rectSeries = ChartXY.addRectangleSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link RectangleSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `RectangleSeries`.
         * @returns New series.
         * @public
         */
        addRectangleSeries(options?: RectangleSeriesOptions): RectangleSeries;
        /**
         * Method for adding a new `PolygonSeries` to the chart. This series type visualizes a collection of *polygons*.
         *
         * To learn more about its features and usage, refer to {@link PolygonSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PolygonSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const polygonSeries = ChartXY.addPolygonSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link PolygonSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `PolygonSeries`.
         * @returns New series.
         * @public
         */
        addPolygonSeries(options?: PolygonSeriesOptions): PolygonSeries;
        /**
         * Method for adding a new `SegmentSeries` to the chart. This series type visualizes a collection of *line segments* (A -\> B).
         *
         * To learn more about its features and usage, refer to {@link SegmentSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `SegmentSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addSegmentSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link SegmentSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `SegmentSeries`.
         * @returns New series.
         * @public
         */
        addSegmentSeries(options?: SegmentSeriesOptions): SegmentSeries;
        /**
         * Method for adding a new `EllipseSeries` to the chart. This series type visualizes a collection of *ellipses*.
         *
         * To learn more about its features and usage, refer to {@link EllipseSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `EllipseSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addEllipseSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link EllipseSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `EllipseSeries`.
         * @returns New series.
         * @public
         */
        addEllipseSeries(options?: EllipseSeriesOptions): EllipseSeries;
        /**
         * Method for adding a new `BoxSeries` to the chart. This series type is used for visualizing data groups through quartiles.
         *
         * To learn more about its features and usage, refer to {@link BoxSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `BoxSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addBoxSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link BoxSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `BoxSeries`.
         * @returns New series.
         * @public
         */
        addBoxSeries(options?: BoxSeriesOptions): BoxSeries;
        /**
         * Method for adding a new `AreaSeries` to the chart. This series type is used for visualizing *area* between a static *base line* and supplied *curve data*.
         * `AreaSeries` is optimized for *large* amounts of data - here are some reference specs to give an idea:
         *
         * - A static data set in millions range is rendered in a matter of seconds.
         * - With streaming data, tens of thousands data points can be streamed in every second, while retaining an interactive document.
         *
         * To learn more about its features and usage, refer to {@link AreaSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `AreaSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addAreaSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link AreaSeriesOptions}.
         *
         * **Return type:**
         *
         * `AreaSeries` return type depends on supplied readonly configuration! Specifically, {@link AreaSeriesOptions.type}.
         *
         * | Configuration `type` | Return series type |
         * | :------------------- | :---------------- |
         * | `undefined` or omitted | {@link AreaSeriesPositive} |
         * | `AreaSeriesTypes.Positive` | {@link AreaSeriesPositive} |
         * | `AreaSeriesTypes.Negative` | {@link AreaSeriesNegative} |
         * | `AreaSeriesTypes.Bipolar` | {@link AreaSeriesBipolar} |
         *
         * @param options - Optional object with readonly configuration arguments for `AreaSeries`.
         * @returns New series.
         * @public
         */
        addAreaSeries: <AreaType extends AreaSeriesTypes = typeof AreaSeriesPositive>(options?: AreaSeriesOptions<AreaType>) => InstanceType<AreaType>;
        /**
         * Method for adding a new `AreaRangeSeries` to the chart. This series type is used for visualizing bands of data between two curves of data.
         * `AreaRangeSeries` is optimized for *large* amounts of data - here are some reference specs to give an idea:
         *
         * - A static data set in millions range is rendered in a matter of seconds.
         * - With streaming data, tens of thousands data points can be streamed in every second, while retaining an interactive document.
         *
         * To learn more about its features and usage, refer to {@link AreaRangeSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `AreaRangeSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addAreaRangeSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link AreaRangeSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `AreaRangeSeries`.
         * @returns New series.
         * @public
         */
        addAreaRangeSeries: (options?: AreaRangeSeriesOptions) => AreaRangeSeries;
        /**
         * Add a Series for visualizing a *Heatmap Grid* with a static column and grid count. Has API for fast modification of cell values.
         *
         * `HeatmapGridSeries` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
         *
         * - Heatmap Chart with 1 million data points (`1000x1000`) is cold started in ~0.3 seconds.
         * - Heatmap Chart with 1 million data points (`1000x1000`) is re-populated (change data set) in ~0.050 seconds.
         * - Heatmap Chart with 16 million data points (`4000x4000`) is cold started in ~2.0 seconds.
         * - Heatmap Chart with 16 million data points (`4000x4000`) is re-populated (change data set) in ~0.5 seconds.
         *
         * `HeatmapGridSeries` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
         * If by increasing the amount of `columns` and `rows` you encounter suddenly weak performance, it is likely that there is not enough RAM memory available.
         *
         * To learn more about its features and usage, refer to {@link HeatmapGridSeriesIntensityValues}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `HeatmapSeries` can only be configured when it is created. Some of these arguments are **mandatory**, while some are optional.
         * They are wrapped in a single object parameter:
         *
         * ```js
         *  // Example,
         *  const series = ChartXY.addHeatmapGridSeries({
         *      columns: 100,
         *      rows: 100
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link HeatmapGridSeriesOptions}.
         *
         * Heatmap data format is specified with `heatmapDataType: 'intensity'` property;
         * in this case, each cell of the heatmap is associated with a *numeric intensity value*, which can be used in conjuction with a
         * Color look up table ({@link LUT}).
         *
         * For *scrolling heatmap grids*, see {@link addHeatmapScrollingGridSeries}.
         *
         * @param options - Configuration parameters for Heatmap Grid Series.
         * @returns Heatmap Grid Series.
         * @public
         */
        addHeatmapGridSeries(options: HeatmapGridSeriesOptions<'intensity'>): HeatmapGridSeriesIntensityValues;
        /**
         * Add a Series for visualizing a *Heatmap Grid*, with API for pushing data in a scrolling manner (append new data on top of existing data).
         *
         * `HeatmapScrollingGridSeries` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
         *
         * - Scrolling Heatmap Chart with 2 million incoming data points **per second** (`rows: 2048`, 1000 columns/s) runs consistently and smoothly with 60 FPS and no stuttering. CPU usage stays easily below 40%.
         * - Scrolling Heatmap Chart with 8 million incoming data points **per second** (`rows: 4096`, 2000 columns/s) runs consistently and smoothly with 60 FPS and minor stuttering.
         *
         * `HeatmapScrollingGridSeries` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
         * If performance suddenly plummets at some approximate data threshold, then it is likely that there is not enough RAM available.
         * Use data cleaning configuration and suitable Axis intervals to adjust to your hardware limitations.
         *
         * To learn more about its features and usage, refer to {@link HeatmapScrollingGridSeriesIntensityValues}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `ScrollingHeatmapSeries` can only be configured when it is created. Some of these arguments are **mandatory**, while some are optional.
         * They are wrapped in a single object parameter:
         *
         * ```js
         *  // Example,
         *  const series = ChartXY.addHeatmapGridSeries({
         *      resolution: 100
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link HeatmapScrollingGridSeriesOptions}.
         *
         * Heatmap data format is specified with `heatmapDataType: 'intensity'` property;
         * in this case, each cell of the heatmap is associated with a *numeric intensity value*, which can be used in conjuction with a
         * Color look up table ({@link LUT}).
         *
         * For *static heatmap grids*, see {@link addHeatmapGridSeries}.
         *
         * @param options - Configuration parameters for Heatmap Grid Series.
         * @returns Scrolling Heatmap Grid Series.
         * @public
         */
        addHeatmapScrollingGridSeries(options: HeatmapScrollingGridSeriesOptions<'intensity'>): HeatmapScrollingGridSeriesIntensityValues;
        /**
         * Method for adding a new `OHLCSeries` to the chart. This series type is used for visualizing trading figures in large quantities and/or with real-time data input.
         *
         * **OHLC Series is only usable with a Trading license for LightningChart JS**
         *
         * To learn more about its features and usage, refer to {@link OHLCSeries}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `OHLCSeries` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example,
         *  const series = ChartXY.addOHLCSeries({
         *      // Specify non-default X Axis to attach series to.
         *      xAxis: myNonDefaultAxisX
         *  })
         * ```
         *
         * To learn about available properties, refer to {@link OHLCSeriesOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `OHLCSeries`.
         * @returns New series.
         * @public
         */
        addOHLCSeries<Type extends OHLCSeriesTypes = typeof OHLCSeriesCandlesticks>(options?: OHLCSeriesOptions<Type>): InstanceType<Type>;
        /**
         * Api to add OSM menu to the chart
         *
         * @param controls - A 2d array which describes the type of buttons to be added and their positions (row, column).
         * @param osmButtonShape - Optional parameter to specify the shape of the on-screen menu icons.
         * @beta                    This feature is considered experimental and might be changed in minor release.
         */
        addOnScreenMenu(controls: (OnScreenMenuButtonType | OnScreenMenuCustomButtonParams)[][], osmButtonShape?: OnScreenMenuButtonShape): OnScreenMenu;
        /**
         * Set mouse style when hovering over series background.
         * @param mouseStyle - Mouse-style preset name (see {@link MouseStyles})
         * @returns Object itself
         * @public
         */
        setMouseBackgroundStyle(mouseStyle?: string): this;
        /**
         * Set mouse style when zooming over series background.
         * @param mouseStyle - Mouse-style preset name (see {@link MouseStyles})
         * @returns Object itself
         * @public
         */
        setMouseZoomStyle(mouseStyle?: string): this;
        /**
         * Set mouse style when fitting over series background.
         * @param mouseStyle - Mouse-style preset name (see {@link MouseStyles})
         * @returns Object itself
         * @public
         */
        setMouseFitStyle(mouseStyle?: string): this;
        /**
         * Set mouse style when panning over series background.
         * @param mouseStyle - Mouse-style preset name (see {@link MouseStyles})
         * @returns Object itself
         * @public
         */
        setMousePanStyle(mouseStyle?: string): this;
        /**
         * Set all mouse-interaction flags at once.
         * @param enabled - Are mouse-interactions enabled
         * @returns Object itself
         * @public
         */
        setMouseInteractions(enabled: boolean): this;
        /**
         * Set is mouse-interaction enabled:
         * Zooming axes by capturing rectangle on frame.
         * @param enabled - Boolean flag
         * @returns Object itself
         * @public
         */
        setMouseInteractionRectangleZoom(enabled: boolean): this;
        /**
         * Get is mouse-interaction enabled:
         * Zooming axes by capturing rectangle on frame.
         * @returns Boolean flag
         * @public
         */
        getMouseInteractionRectangleZoom(): boolean;
        /**
         * Set is mouse-interaction enabled:
         * Fitting axes by capturing rectangle on frame.
         * @param enabled - Boolean flag
         * @returns Object itself
         * @public
         */
        setMouseInteractionRectangleFit(enabled: boolean): this;
        /**
         * Get is mouse-interaction enabled:
         * Fitting axes by capturing rectangle on frame.
         * @returns Boolean flag
         * @public
         */
        getMouseInteractionRectangleFit(): boolean;
        /**
         * Set is mouse-interaction enabled:
         * Panning axes by dragging mouse on frame.
         * @param enabled - Boolean flag
         * @returns Object itself
         * @public
         */
        setMouseInteractionPan(enabled: boolean): this;
        /**
         * Get is mouse-interaction enabled:
         * Panning axes by dragging mouse on frame.
         * @returns Boolean flag
         * @public
         */
        getMouseInteractionPan(): boolean;
        /**
         * Set is mouse-interaction enabled:
         * Zooming axes with mouse-wheel on frame (also touch pinch currently).
         * @param enabled - Boolean flag
         * @returns Object itself
         * @public
         */
        setMouseInteractionWheelZoom(enabled: boolean): this;
        /**
         * Get is mouse-interaction enabled:
         * Zooming axes with mouse-wheel on frame.
         * @returns Boolean flag
         * @public
         */
        getMouseInteractionWheelZoom(): boolean;
        /**
         * Set fillStyle for zooming rectangle when zooming.
         * @param value - FillStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setZoomingRectangleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fillStyle for zooming rectangle when zooming.
         * @returns FillStyle
         * @public
         */
        getZoomingRectangleFillStyle(): FillStyle;
        /**
         * Set stroke style for zooming rectangle when zooming.
         * @param value - LineStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setZoomingRectangleStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style for zooming rectangle when zooming.
         * @returns LineStyle
         * @public
         */
        getZoomingRectangleStrokeStyle(): LineStyle;
        /**
         * Set fillStyle for zooming rectangle when fitting.
         * @param value - FillStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setFittingRectangleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fillStyle for fitting rectangle when fitting.
         * @returns FillStyle
         * @public
         */
        getFittingRectangleFillStyle(): FillStyle;
        /**
         * Set stroke style for zooming rectangle when fitting.
         * @param value - LineStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setFittingRectangleStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style for fitting rectangle when fitting.
         * @returns LineStyle
         * @public
         */
        getFittingRectangleStrokeStyle(): LineStyle;
        /**
         * Add a *legendbox*.
         *
         * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
         * with user interactions, as well as positioned in application code.
         *
         * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
         * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
         *
         * **Legendbox alignment:**
         *
         * Alignment of legendbox can be selected by supplying one of the available {@link LegendBoxBuilders} to `addLegendBox`:
         *
         * ```typescript
         *  // Default (vertical) LegendBox.
         *  const legendBox = ChartXY.addLegendBox()
         *
         *  // Horizontal LegendBox.
         *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
         * ```
         *
         * **Custom Legendbox positioning:**
         *
         * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
         *
         * A custom location can be configured with {@link UIElement} API:
         * - {@link UIElement.setPosition}
         * - {@link UIElement.setOrigin}
         * - {@link UIElement.setMargin}
         *
         * *Position coordinate system* is specified when creating *legendbox*.
         *
         * 1) LegendBox with default positioning coordinate system.
         *
         * ```typescript
         *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
         *      // Position = [0, 100] as percentages.
         *      .setPosition({ x: 50, y: 50 })
         * ```
         *
         * 2) Position in pixel coordinate system.
         *
         * ```typescript
         *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.coordsRelative )
         *      // Position = pixels.
         *      .setPosition({ x: 300, y: 100 })
         * ```
         *
         * 3) Position on Axes.
         *
         * ```typescript
         *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
         *      // Position = Axis values.
         *      .setPosition({ x: 5, y: 5 })
         * ```
         *
         * For more information on `LegendBox` features, and usage, see {@link LegendBox}.
         *
         * @param builder - *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use {@link LegendBoxBuilders} for selection.
         * @param scale - Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in pixels.
         * @returns LegendBox
         * @public
         */
        addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox;
        protected _isZoomingActive: boolean;
        protected _isPanningActive: boolean;
        /**
         * Method pans axes by pixels.
         *
         * ```js
         * // Pan the chart 100 pixels to right.
         * chart.pan({x: 100, y: 0})
         * ```
         * @param delta - Amount to pan X/Y in pixels
         * @public
         */
        pan(delta: Point): void;
        /**
         * Method zooms axes by pixels.
         *
         * ```js
         * // Zoom the chart out.
         * chart.zoom({x: 500, y: 500}, {x: 1, y: 1})
         * ```
         * @param location - Origin location for zooming as viewport pixels
         * @param amount - Amount to zoom X/Y in pixels
         * @public
         */
        zoom(location: Point, amount: Point): void;
        /**
         * Disable/Enable all animations of the Chart.
         * @param animationsEnabled - Boolean value to enable or disable animations.
         * @returns Chart itself for fluent interface.
         * @public
         * @privateRemarks  Override to also apply state to axes.
         */
        setAnimationsEnabled(animationsEnabled: boolean): this;
        /**
         * Disable/Enable AutoCursor during Axis Animations.
         *
         * Axis Animations are Axis Scale changes that are animated, such as Zooming and Scrolling done by using API
         * (such as `Axis.setInterval`) or by using the mouse to click & drag on the Chart.
         * @param autoCursorEnabled - Boolean value to enable or disable AutoCursor during Axis Animations.
         * @returns Chart itself for fluent interface.
         * @public
         */
        setAutoCursorEnabledDuringAxisAnimation(autoCursorEnabled: boolean): this;
        /**
         * Get current AutoCursor during Axis animations state.
         *
         * Axis Animations are Axis Scale changes that are animated, such as Zooming and Scrolling done by using API
         * (such as `Axis.setInterval`) or by using the mouse to click & drag on the Chart.
         * @returns True if AutoCursor is enabled during Axis Animations, false if not.
         * @public
         */
        getAutoCursorEnabledDuringAxisAnimation(): boolean;
        /**
         * Operate on each axis of chart, x and y
         * @param clbk - Callback function for axis
         * @public
         */
        forEachAxis(clbk: (axis: Axis) => void): this;
        /**
         * Translate a coordinate in HTML client coordinate system to another coordinate system.
         *
         * **(1) arbitrary X and Y axes coordinate system:**
         *
         * ```ts
         *  ChartXY.onSeriesBackgroundMouseClick((_, event) => {
         *      const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
         *      // locationAxis tells the clicked location along Axis interval (in same value range as data points).
         *  })
         * ```
         *
         * `chart.coordsAxis` is a convenience selector for the active _default axes (X and Y)_. Arbitrary set of X and Y axes can be selected like this:
         *
         * ```ts
         *  const locationAxis = chart.translateCoordinate(event, { x: myAxisX, y: myAxisY })
         * ```
         *
         * **(2) relative control coordinate system:**
         *
         * ```ts
         *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
         *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
         *  // locationRelative is in pixels relative to bottom left corner of the chart
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemRelative | CoordinateSystemAxis>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : T extends CoordinateSystemAxis ? CoordinateXY : never;
        /**
         * Translate a coordinate to another coordinate system.
         *
         * | Supported INPUT coordinate systems | Syntax | Syntax 2 |
         * |:----|:----|:----|
         * | arbitrary X and Y axes | `chart.coordsAxis` | `{ x: Axis, y: Axis }` |
         * | relative coordinates | `chart.coordsRelative` | |
         *
         * | Supported OUTPUT coordinate systems | Syntax | Syntax 2 |
         * |:----|:----|:----|
         * | arbitrary X and Y axes | `chart.coordsAxis` | `{ x: Axis, y: Axis }` |
         * | relative coordinates | `chart.coordsRelative` | |
         * | HTML client coordinates | `chart.coordsClient` | |
         *
         * Most common example use cases:
         *
         * **(1) Translate a coordinate from axes to HTML client coordinates**
         *
         * ```ts
         *  const locationAxis = { x: 2, y: 5 }
         *  const locationClient = chart.translateCoordinate(locationAxis, chart.coordsAxis, chart.coordsClient)
         * ```
         *
         * Client coordinates can be used to absolute position HTML elements using CSS, for example.
         *
         * ```ts
         *  myHTMLElement.style.position = 'absolute'
         *  myHTMLElement.style.left = locationClient.clientX
         *  myHTMLElement.style.top = locationClient.clientY
         * ```
         *
         * **(2) Translate a coordinate from HTML client coordinates to axes**
         *
         * ```ts
         *  ChartXY.onSeriesBackgroundMouseClick((_, event) => {
         *      const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
         *      // locationAxis tells the clicked location along Axis interval (in same value range as data points).
         *  })
         * ```
         *
         * **(3) Translate a coordinate from axes to relative chart coordinates**
         *
         * ```ts
         *  const locationAxis = { x: 2, y: 5 }
         *  const locationRelative = chart.translateCoordinate(locationAxis, chart.coordsAxis, chart.coordsRelative)
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * **(4) Translate a coordinate from relative chart coordinates to axes**
         *
         * ```ts
         *  const locationRelative = { x: 0, y: 0 }
         *  const locationAxis = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsAxis)
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemClient | CoordinateSystemRelative | CoordinateSystemAxis>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemAxis | CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : T extends CoordinateSystemRelative ? CoordinateXY : T extends CoordinateSystemAxis ? CoordinateXY : never;
        /**
         * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
         *
         * ```ts
         *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
         *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
         *  // locationRelative is in pixels relative to bottom left corner of the chart
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         * @privateRemarks  This definition of the method originates from the super class. Mention it last as the intention is that above declarations can also used for this declarations use case.
         */
        translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
        /**
         * Translate a coordinate from relative control coordinates to HTML client coordinate system.
         *
         * ```ts
         *  // 10 pixels left and 20 pixels up from controls bottom left corner
         *  const locationRelative = { x: 10, y: 20 }
         *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
         * ```
         *
         * Client coordinates can be used to absolute position HTML elements using CSS, for example.
         *
         * ```ts
         *  myHTMLElement.style.position = 'absolute'
         *  myHTMLElement.style.left = locationClient.clientX
         *  myHTMLElement.style.top = locationClient.clientY
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         * @privateRemarks  This definition of the method originates from the super class. Mention it last as the intention is that above declarations can also used for this declarations use case.
         */
        translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
    }
    /**
     * Interface for readonly configuration of {@link ChartXY}.
     *
     * Some properties of `ChartXY` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, configure default X Axis.
     *  const chart = LightningChart.ChartXY({
     *      defaultAxisX: {
     *          type: 'linear',
     *      }
     *  })
     * ```
     *
     * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
     *
     * For *standalone* `ChartXY`, more parameters are documented in {@link LightningChart.ChartXY}.
     *
     * For *dashboard* `ChartXY`, more parameters are documented in {@link Dashboard.createChartXY}.
     *
     *
     * **Commonly used properties:**
     *
     * - {@link ChartXYOptions.theme}: Specify chart color *theme*.
     * - {@link ChartXYOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
     * - {@link ChartXYOptions.defaultAxisX}: Configure default X Axis.
     * - {@link ChartXYOptions.defaultAxisY}: Configure default Y Axis.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create chart with default configuration.
     *  const chart = LightningChart.ChartXY({})
     * ```
     *
     * ```typescript
     *  // Example 2, create chart with specified color theme.
     *  const chart = LightningChart.ChartXY({
     *      theme: Themes.light,
     *  })
     * ```
     *
     * ```typescript
     *  // Example 3, create chart with specified default axis configurations.
     *  const chart = LightningChart.ChartXY({
     *      defaultAxisX: {
     *          type: 'linear',
     *      },
     *      defaultAxisY: {
     *          type: 'logarithmic',
     *          base: 10,
     *      }
     *  })
     * ```
     * @public
     */
    export declare interface ChartXYOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
        /**
         * Builder for the charts' *auto cursor*. Use {@link AutoCursorBuilders | AutoCursorBuilders.XY} to modify the default builder, using methods of {@link AutoCursorXYBuilder}.
         *
         * ```typescript
         *  // Example, change cursor ResultTable background shape.
         *  const chart = LightningChart.ChartXY({
         *      autoCursorBuilder: AutoCursorBuilders.XY
         *          .setResultTableBackground(UIBackgrounds.Circle)
         *  })
         * ```
         */
        autoCursorBuilder?: AutoCursorXYBuilder<CursorResultTableBackgroundType>;
        /**
         * Interface for specifying Axis X configurations that can't be changed after creation of the Axis.
         *
         * **Example usage**:
         *
         * - Configure default X Axis of chart on opposite side to default configuration (top).
         *
         * ```typescript
         *  ChartXY({
         *      defaultAxisX: {
         *          opposite: true,
         *      }
         *  })
         * ```
         *
         * - Configure default X Axis of chart as logarithmic (10 base).
         *
         * ```typescript
         *  ChartXY({
         *      defaultAxisX: {
         *          type: 'logarithmic',
         *          base: 10,
         *      }
         *  })
         * ```
         *
         * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
         *
         * List of series that support logarithmic Axes:
         * - {@link LineSeries}
         * - {@link PointSeries}
         * - {@link PointLineSeries}
         * - {@link StepSeries}
         * - {@link SplineSeries}
         * - {@link AreaSeries}
         * - {@link AreaRangeSeries}
         * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
         * - {@link RectangleSeries}
         * - {@link SegmentSeries}
         *
         * List of series that do **not** support logarithmic Axes:
         * - {@link HeatmapGridSeriesIntensityValues}
         * - {@link HeatmapScrollingGridSeriesIntensityValues}
         * - {@link PolygonSeries}
         */
        defaultAxisX?: AxisOptions;
        /**
         * Interface for specifying Axis Y configurations that can't be changed after creation of the Axis.
         *
         * **Example usage**:
         *
         * - Configure default Y Axis of chart on opposite side to default configuration (top).
         *
         * ```typescript
         *  ChartXY({
         *      defaultAxisY: {
         *          opposite: true,
         *      }
         *  })
         * ```
         *
         * - Configure default Y Axis of chart as logarithmic (10 base).
         *
         * ```typescript
         *  ChartXY({
         *      defaultAxisY: {
         *          type: 'logarithmic',
         *          base: 10,
         *      }
         *  })
         * ```
         *
         * NOTE: Not all series types support logarithmic axes! Attaching a non-supported Series will crash the application.
         *
         * List of series that support logarithmic Axes:
         * - {@link LineSeries}
         * - {@link PointSeries}
         * - {@link PointLineSeries}
         * - {@link StepSeries}
         * - {@link SplineSeries}
         * - {@link AreaSeries}
         * - {@link AreaRangeSeries}
         * - {@link OHLCSeries} (Y Axis can be logarithmic, but not X Axis)
         * - {@link RectangleSeries}
         * - {@link SegmentSeries}
         *
         * List of series that do **not** support logarithmic Axes:
         * - {@link HeatmapGridSeriesIntensityValues}
         * - {@link HeatmapScrollingGridSeriesIntensityValues}
         * - {@link PolygonSeries}
         */
        defaultAxisY?: AxisOptions;
    }
    /**
     * Type union for possible ways to describe location of title in ChartXY.
     *
     * Use with {@link ChartXY.setTitlePosition}:
     *
     * ```
     *  // Example, place title inside series area.
     *  ChartXY.setTitlePosition(ChartXYTitlePositionOptions.SeriesCenterTop)
     *
     *  ChartXY.setTitlePosition('left-top')
     * ```
     *
     * ```
     *  // Example, align title with Y axis.
     *  ChartXY
     *      .setTitlePosition(ChartXYTitlePositionOptions.LeftTop)
     *      .setTitleMargin({ left: 60 })
     *      .getDefaultAxisY().setThickness(60)
     * ```
     * @public
     */
    export declare type ChartXYTitlePosition = EnumToStringUnion<ChartXYTitlePositionOptions>;
    /**
     * Enum for selecting position of Chart Title.
     *
     * This is currently only usable on {@link ChartXY.setTitlePosition} in {@link ChartXY}:
     *
     * ```ts
     *  ChartXY.setTitlePosition(ChartXYTitlePositionOptions.SeriesCenterBottom)
     * ```
     * @public
     */
    export declare enum ChartXYTitlePositionOptions {
        /**
         * Title horizontally centered, at the very top of the chart.
         *
         * This adds extra margin above series area, to make space for the title.
         */
        CenterTop = "center-top",
        /**
         * Title horizontally at right edge, at the very top of the chart.
         *
         * This adds extra margin above series area, to make space for the title.
         */
        RightTop = "right-top",
        /**
         * Title horizontally at left edge, at the very top of the chart.
         *
         * This adds extra margin above series area, to make space for the title.
         */
        LeftTop = "left-top",
        /**
         * Title horizontally centered, at the very bottom of the chart.
         *
         * This adds extra margin below series area, to make space for the title.
         */
        CenterBottom = "center-bottom",
        /**
         * Title horizontally at right edge, at the very bottom of the chart.
         *
         * This adds extra margin below series area, to make space for the title.
         */
        RightBottom = "right-bottom",
        /**
         * Title horizontally at left edge, at the very bottom of the chart.
         *
         * This adds extra margin below series area, to make space for the title.
         */
        LeftBottom = "left-bottom",
        /**
         * Title inside the series area, horizontally centered at the very top.
         */
        SeriesCenterTop = "series-center-top",
        /**
         * Title inside the series area, horizontally at right edge, at the very top.
         */
        SeriesRightTop = "series-right-top",
        /**
         * Title inside the series area, horizontally at left edge, at the very top.
         */
        SeriesLeftTop = "series-left-top",
        /**
         * Title inside the series area, horizontally centered, at the very bottom.
         */
        SeriesCenterBottom = "series-center-bottom",
        /**
         * Title inside the series area, horizontally at right edge, at the very bottom.
         */
        SeriesRightBottom = "series-right-bottom",
        /**
         * Title inside the series area, horizontally at left edge, at the very bottom.
         */
        SeriesLeftBottom = "series-left-bottom"
    }
    /**
     * Style class for describing a *color*.
     *
     * Instances of Color, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Color creation:**
     *
     * Create *LCJS colors* using any of the many available *factories*:
     * - {@link ColorRGBA}
     * - {@link ColorHEX}
     * - {@link ColorCSS}
     * - {@link ColorHSV}
     *
     * **Color usage:**
     *
     * *Watch out!* A common misuse is to attempt styling components directly with *color*.
     * *Color* is the lowest level style class in whole LCJS library, and is never used directly for styling components,
     * instead it must be wrapped within a more descriptive style type.
     * For example, {@link SolidFill} describes coloring with single, solid color.
     *
     * **Example usage:**
     *
     * Example 1, specifying chart title color using {@link ColorRGBA} and {@link SolidFill}
     *
     * ```typescript
     *  ChartXY.setTitleFillStyle( new SolidFill({
     *      color: ColorRGBA( 255, 0, 0 )
     *  }) )
     * ```
     *
     * Example 2, specifying line series stroke style using ColorRGBA, SolidFill and SolidLine
     *
     * ```typescript
     *  LineSeries.setStrokeStyle(new SolidLine({
     *      thickness: 2,
     *      fillStyle: new SolidFill({
     *          color: ColorRGBA( 255, 0, 0 )
     *      })
     *  }))
     * ```
     * @public
     */
    export declare class Color extends ColorRecord {
        /**
         * Creates a new color that is equal to this but with a certain alpha value
         * @param alpha - Value of alpha channel [0-255]
         * @returns New Color object
         * @public
         */
        setA(alpha: number): Color;
        /**
         * Creates a new color that is equal to this but with a certain red value
         * @param red - Value of red channel [0-255]
         * @returns New Color object
         * @public
         */
        setR(red: number): Color;
        /**
         * Creates a new color that is equal to this but with a certain green value
         * @param green - Value of green channel [0-255]
         * @returns New Color object
         * @public
         */
        setG(green: number): Color;
        /**
         * Creates a new color that is equal to this but with a certain blue value
         * @param blue - Value of blue channel [0-255]
         * @returns New Color object
         * @public
         */
        setB(blue: number): Color;
        /**
         * @returns Value of alpha channel [0-255]
         * @public
         */
        getA(): number;
        /**
         * @returns Value of red channel [0-255]
         * @public
         */
        getR(): number;
        /**
         * @returns Value of green channel [0-255]
         * @public
         */
        getG(): number;
        /**
         * @returns Value of blue channel [0-255]
         * @public
         */
        getB(): number;
        /**
         * Compute a highlighted version of this Color.
         * @returns New Color object
         * @public
         */
        getHighlight(): Color;
        /**
         * Returns a slightly lighter version from a Color.
         * @returns New Color object
         * @public
         */
        getLighter(): Color;
        /**
         * Returns a slightly darker version from a Color.
         * @returns New Color object
         * @public
         */
        getDarker(): Color;
        /**
         * @returns Color string in format acceptable by CSS
         * @public
         */
        toRGBAString(): string;
    }
    /**
     * One of the many available factories for {@link Color}.
     * This variant has a single parameter that follows the *CSS* suite of describing colors.
     * Can be especially useful when tying *LightningChart JS* styling together with user front-end application CSS.
     *
     * **Example usage**:
     *
     * ```typescript
     *  const colorRed = ColorCSS('red')
     *  const colorTransparentGreen = ColorCSS('rgba(0, 255, 0, 0.5)')
     * ```
     *
     * **Supported formats:**
     *
     * Basically all commonly used CSS color syntaxes are supported, but here is a list for reference:
     *
     * - HEX ('#FF00AA')
     * - HEX with transparency ('#FF00AABB')
     * - RGBA ('rgba(132, 15, 4, 1.0)')
     * - HSL ('hsl(0,100%, 50%)')
     * - Color Name ('blue')
     *
     * For more convenience factories, see:
     * - {@link ColorRGBA}
     * - {@link ColorHEX}
     * - {@link ColorHSV}
     *
     * @param color - CSS string description of a color. For example, 'red'.
     * @returns *Color* object. Please refer to {@link Color} API document, on extended information how to use *LCJS Colors*.
     * @public
     */
    export declare const ColorCSS: (color: string) => Color;
    /**
     * One of the many available factories for {@link Color}.
     * This variant has a single parameter that follows the *CSS* suite of describing colors as *hexadecimal strings*.
     *
     * **Example usage**:
     *
     * ```typescript
     *  const colorRed = ColorHEX('#ff0000')
     *  const colorTransparentGreen = ColorHEX('#00ff0010')
     * ```
     *
     * **Supported formats:**
     *
     * Basically all commonly used hexadecimal color syntaxes are supported, but here is a full list:
     *
     * - '#RRGGBB'
     * - '#RRGGBBAA'
     * - '#RGB'
     * - '#RGBA'
     * - 'RRGGBB'
     * - 'RRGGBBAA'
     * - 'RGB'
     * - 'RGBA'
     * - '0xRRGGBB'
     * - '0xRRGGBBAA'
     * - '0xRGB'
     * - '0xRGBA'
     *
     * For more convenience factories, see:
     * - {@link ColorRGBA}
     * - {@link ColorCSS}
     * - {@link ColorHSV}
     *
     * @param hexColor - Hexadecimal value for constructing a Color. Eq. '#FF0000' = Red
     * @returns *Color* object. Please refer to {@link Color} API document, on extended information how to use *LCJS Colors*.
     * @public
     */
    export declare const ColorHEX: (hexColor: string) => Color;
    /**
     * One of the many available factories for {@link Color}.
     * This variant receives input arguments in *HSV* color space.
     * *HSV* is popular in generating smooth, looping color ranges, for example (red -\> green -\> blue -\> red).
     *
     * **Example usage**:
     *
     * ```typescript
     *  // Hue = angle of color circle where 0 deg = red, 120 deg = green, 240 deg = blue.
     *  const colorRed = ColorHSV(0)
     *  const colorYellow = ColorHSV(60)
     *
     *  // Generate a simple color palette.
     *  const colors10 = new Array(10).fill(undefined).map((_, iColor) =>
     *      // Array will receive colors starting from red, moving through green, blue and ending just before red.
     *      ColorHSV( 0 + (iColor / 10) * 360 )
     *  )
     *
     *  // 'saturation' and 'value' arguments can be supplied optionally.
     *  const colorRedDim = ColorHSV(0, 1.0, 0.5)
     * ```
     *
     * For more convenience factories, see:
     * - {@link ColorRGBA}
     * - {@link ColorHEX}
     * - {@link ColorCSS}
     *
     * @param hue - *Hue* value as degrees [0, 360] (0 = red, 120 = green, 240 = blue, 360 = red, and so on...).
     * @param saturation - Saturation in range [0, 1]. Defaults to 1.
     * @param value - Value in range [0, 1]. Defaults to 1.
     * @returns *Color* object. Please refer to {@link Color} API document, on extended information how to use *LCJS Colors*.
     * @public
     */
    export declare const ColorHSV: (hue: number, saturation?: number, value?: number) => Color;
    /**
     * Collection of default *Color* *PaletteFactories*.
     *
     * Items are mostly functions that take a single argument, *length*, and return a *Color* {@link Palette} of that given length.
     *
     * *Color* *Palettes* are functions that give a *Color* based on a given *index*.
     * @public
     */
    export declare const ColorPalettes: {
        warm: PaletteFactory<Color>;
        cold: PaletteFactory<Color>;
        fullSpectrum: PaletteFactory<Color>;
        reverseSpectrum: PaletteFactory<Color>;
        flatUI: PaletteFactory<Color>;
        arction: PaletteFactory<Color>;
        arctionWarm: PaletteFactory<Color>;
        sunset: PaletteFactory<Color>;
        dynamic: PaletteFactory<Color>;
        magenta: PaletteFactory<Color>;
        greyscale: PaletteFactory<Color>;
        frozen: PaletteFactory<Color>;
        retro: PaletteFactory<Color>;
        crayons: PaletteFactory<Color>;
        custom: PaletteFactory<Color>;
        sector: (start: number, end: number, saturation?: number, vibrance?: number) => PaletteFactory<Color>;
        auroraBorealis: PaletteFactory<Color>;
        blueSciFi: PaletteFactory<Color>;
        light: PaletteFactory<Color>;
        monochrome: PaletteFactory<Color>;
        night: PaletteFactory<Color>;
        sunset2: PaletteFactory<Color>;
    };
    /**
     * Interface for immutable data-structure which represents a 2-dimensional location and an associated Color.
     *
     * This can be used for Point-based series for coloring each point individually, when combined with usage of IndividualPointFill-style.
     * @public
     */
    export declare interface ColorPoint extends Point, ColorValue {
    }
    /**
     * Interface for defining an RGBA Color with channels ranging [0, 1].
     * @public
     */
    declare interface ColorProperties {
        type: 'color';
        /**
         * Red value from 0 to 1
         */
        r: number;
        /**
         * Green value from 0 to 1
         */
        g: number;
        /**
         * Blue value from 0 to 1
         */
        b: number;
        /**
         * Alpha value from 0 to 1
         */
        a: number;
    }
    /**
     * Record class for ColorProperties,
     * Used as base for Color
     * @public
     */
    declare const ColorRecord: Record_2.Factory<ColorProperties>;
    /**
     * One of the many available factories for {@link Color}. This variant receives individual values for *red*, *green*, *blue*, and optionally *alpha* channels.
     * **Input values are in range [0, 255].**
     *
     * **Example usage**:
     *
     * ```typescript
     *  // Create Color from RGB [0, 255] values (completely red).
     *  const color = ColorRGBA( 255, 0, 0 )
     *
     * // Create transparent Color.
     * const transparentColor = ColorRGBA( 255, 0, 0, 127 )
     * ```
     *
     * For more convenience factories, see:
     * - {@link ColorHEX}
     * - {@link ColorCSS}
     * - {@link ColorHSV}
     *
     * @param r - Red from 0 to 255
     * @param g - Green from 0 to 255
     * @param b - Blue from 0 to 255
     * @param a - Alpha from 0 to 255 (can be omitted, defaulting to 255)
     * @returns *Color* object. Please refer to {@link Color} API document, on extended information how to use *LCJS Colors*.
     * @public
     */
    export declare const ColorRGBA: (r: number, g: number, b: number, a?: number) => Color;
    /**
     * Type union of possible options for describing a 3D _color shading style_.
     *
     * Interacting with color shading styles is designed to be carried out via {@link ColorShadingStyles}.
     * @public
     */
    export declare type ColorShadingStyle = SimpleShadingStyle | PhongShadingStyle;
    /**
     * Object with different options for 3D series _color shading style_.
     *
     * Color shading style is specified with {@link Series3D.setColorShadingStyle} method.
     *
     * ```js
     *  // Example syntax, select simple color shading style.
     *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())
     * ```
     * @public
     */
    export declare const ColorShadingStyles: {
        /**
         * Simple color shading style.
         *
         * Colors each pixel exactly according to its material color.
         *
         * Colors are **not** affected by camera angle, lighting, etc.
         *
         * ```js
         *  // Example syntax, select simple color shading style.
         *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())
         * ```
         *
         * _Simple color shading_ is really fast, which can be a crucial difference especially on low end devices, like laptops and mobile phones.
         */
        Simple: typeof SimpleShadingStyle;
        /**
         * _Phong_ color shading style.
         *
         * Phong shading supports ambient and specular lighting, greatly increasing depth perception
         * capabilities.
         *
         * With Phong shading enabled, the color of each pixel is affected by angle to camera, as well as the various available
         * Phong shading properties, like light colors and reflection values.
         *
         * ```js
         *  // Example syntax, use default Phong shading.
         *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong())
         * ```
         *
         * ```js
         *  // Example syntax, use Phong shading with specific configuration.
         *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong({
         *      // Add specular reflection for "highlight" effect.
         *      specularReflection: 0.5,
         *      specularColor: ColorRGBA(255, 255, 255),
         *  }))
         * ```
         */
        Phong: typeof PhongShadingStyle;
    };
    /**
     * Interface representing a Color Stop.
     * Each ColorStop has a color and an offset.
     * @public
     */
    export declare interface ColorStop {
        /**
         * Color for the color stop.
         */
        color: Color;
        /**
         * Offset for the color stop
         */
        offset: number;
    }
    /**
     * Interface for immutable data-structure which contains a color property.
     *
     * Can be used for individual data point coloring when styled with {@link IndividualPointFill}.
     *
     * For some series types, individual data point coloring might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     * @public
     */
    export declare interface ColorValue {
        /**
         * Data point color.
         *
         * Can be used for individual data point coloring when styled with {@link IndividualPointFill}.
         *
         * For some series types, individual data point coloring might have to be explicitly enabled when the series is created.
         * Refer to series documentation for more detailed information.
         */
        readonly color?: Color;
    }
    /**
     * Readonly configuration parameters that apply to all components.
     * @public
     */
    export declare interface CommonChartOptions {
        /**
         * Convenience flag that can be used to enable/disable all animations in a component.
         */
        animationsEnabled?: boolean;
        /**
         * Convenience flag that can be used to disable all animations in a component.
         * @deprecated  Deprecated in v5.0.0. Use `animationsEnabled` instead (note that **value should be inverted from previous applications!**)
         */
        disableAnimations?: boolean;
    }
    /**
     * Interface for component that can draw effects around it, such as glows and drop shadows.
     * @public
     */
    declare interface ComponentWithEffects {
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getEffect(): boolean;
    }
    /**
     * Axis Highlighter that highlights a single position on the Axis.
     * @public
     */
    export declare class ConstantLine extends Highlighter {
        /**
         * Set value of ConstantLine. This is in values of its owning Axis.
         * @param value - Value on Axis.
         * @returns Object itself for fluent interface.
         * @public
         */
        setValue(value: number): this;
        /**
         * Get value of ConstantLine. This is in values of its owning Axis.
         * @returns Value on Axis.
         * @public
         */
        getValue(): number;
        /**
         * Set stroke style of ConstantLine.
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link DashedLine}
         * - {@link emptyLine}
         *
         * Example usage:
         *```javascript
         * // Specified LineStyle
         * ConstantLine.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
         * // Changed thickness
         * ConstantLine.setStrokeStyle((solidLine) => solidLine.setThickness(5))
         * ```
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link DashedLine}
         * - {@link emptyLine}
         *
         *
         * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
         * @returns Chart itself
         * @public
         */
        setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of ConstantLine.
         * @returns Normal StrokeStyle
         * @public
         */
        getStrokeStyle(): LineStyle;
        /**
         * Enable or disable default interaction of moving constant line by dragging with mouse or touch.
         *
         * ```ts
         *  // Example, disable default interaction.
         *  ConstantLine.setInteractionMoveByDragging(false)
         * ```
         *
         * @returns  Object itself for fluent interface.
         * @public
         */
        setInteractionMoveByDragging(enabled: boolean): this;
        /**
         * Get Default Mouse Dragging Interaction enabled
         * @returns Boolean value
         * @public
         */
        getInteractionMoveByDragging(): boolean;
        /**
         * Subscribe to value change event.
         *
         * This event is called whenever the position of the *ConstantLine* is changed via either
         * **ConstantLine.setValueStart/End** or user interactions.
         * @param handler - Function that is called when event is triggered.
         * @param constantLine - ConstantLine itself.
         * @param value - New 'value' position of ConstantLine.
         * @returns Token that can be used to unsubscribe from the event.
         * @public
         */
        onValueChange(handler: (constantLine: this, value: number) => void): Token;
        /**
         * Unsubscribe from value change event.
         *
         * This event is called whenever the position of the *ConstantLine* is changed via either
         * **ConstantLine.setValueStart/End** or user interactions.
         * @param token - Token that was received when the subscription was created.
         * @returns True if unsubscription was successful.
         * @public
         */
        offValueChange(token: Token): boolean;
        /**
         * Attach object to an legendBox entry
         * @param entry - Object which has to be attached
         * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
         *                          when its respective Entry is clicked.
         * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
         * @returns Object itself for fluent interface
         * @public
         */
        attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
    }
    /**
     * Abstract super class for a Control.
     * Meaning a stand-alone Charting component, which owns a rendering Engine.
     * Eq. Panel, Dashboard, ...
     * @public
     */
    export declare interface Control extends Disposable, DisposableEvents {
        /**
         * Public, safe interface of rendering engine.
         * @public
         */
        readonly engine: PublicEngine;
        /**
         * Selector for "relative" _Coordinate System_.
         *
         * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
         * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
         *
         * This selector can be used for two purposes:
         *
         * **Positioning LCJS UI elements in pixels:**
         *
         * ```ts
         *  // Position UI element in pixels by supplying `Control.coordsRelative` as its positioning system.
         *  const textBox = Control.addUIElement(UIElementBuilders.TextBox, Control.coordsRelative)
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 100, y: 20 })
         * ```
         *
         * **Translations between coordinate systems:**
         *
         * Use with {@link translateCoordinate} method to translate coordinates from "relative" to another coordinate system.
         *
         * @public
         */
        readonly coordsRelative: CoordinateSystemRelative;
        /**
         * Selector for "client" _Coordinate System_.
         *
         * This references the coordinate system used in HTML.
         * It starts at top left of the web page and is measured in pixels.
         * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
         *
         * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
         *
         * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
         * For example, in order to:
         * - Position LCJS UI elements in client coordinates
         * - Find client coordinate that matches a location along LCJS Axis or Chart.
         * - etc.
         *
         * See {@link translateCoordinate} for more detailed use case information and example usage.
         *
         * @public
         */
        readonly coordsClient: CoordinateSystemClient;
        /**
         * Get size of control as pixels.
         *
         * For stand-alone component, the size will be equal to the size of its containing HTML \<div\> (`Control.engine.container`)
         *
         * For component inside Dashboard, the size will only include the component itself, so size can be less than the size of containing HTML \<div\>.
         *
         * @returns     Object with x and y properties `{ x: number, y: number }`, where both are pixel values.
         * @public
         */
        getSizePixels(): Point;
        /**
         * Subscribe to `resize` event.
         * This event is triggered whenever the area of *chart* changes (due to document or dashboard resizing).
         *
         * ```typescript
         *  // Example usage,
         *  ChartXY.onResize((chart, width, height, engineWidth, engineHeight) => {
         *      console.log('Chart resized', 'width', width, 'height', height, 'engineWidth', engineWidth, 'engineHeight', engineHeight)
         *  })
         * ```
         *
         * @param handler - Handler function for event
         * @param obj - Panel itself
         * @param width - Width of control in pixels
         * @param height - Height of control in pixels
         * @param engineWidth - Width of control rendering engine in pixels
         * @param engineHeight - Height of control rendering engine in pixels
         * @returns Token of subscription
         * @public
         */
        onResize(handler: (obj: this, width: number, height: number, engineWidth: number, engineHeight: number) => void): Token;
        /**
         * Remove event listener from resize event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offResize(token: Token): boolean;
        /**
         * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
         *
         * ```ts
         *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
         *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
         *  // locationRelative is in pixels relative to bottom left corner of the chart
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
        /**
         * Translate a coordinate from relative control coordinates to HTML client coordinate system.
         *
         * ```ts
         *  // 10 pixels left and 20 pixels up from controls bottom left corner
         *  const locationRelative = { x: 10, y: 20 }
         *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
         * ```
         *
         * Client coordinates can be used to absolute position HTML elements using CSS, for example.
         *
         * ```ts
         *  myHTMLElement.style.position = 'absolute'
         *  myHTMLElement.style.left = locationClient.clientX
         *  myHTMLElement.style.top = locationClient.clientY
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
        /**
         * Add a stand-alone *UIElement* using a *builder*.
         *
         * **Example usage:**
         *
         * 1) TextBox with default positioning coordinate system.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox )
         *      // Position = [0, 100] as percentages.
         *      .setPosition({ x: 50, y: 50 })
         * ```
         *
         * 2) Position in pixel coordinate system.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox, chart.coordsRelative )
         *      // Position = pixels.
         *      .setPosition({ x: 300, y: 100 })
         * ```
         *
         * 3) Position on Axes.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
         *      // Position = Axis values.
         *      .setPosition({ x: 5, y: 5 })
         * ```
         *
         * @typeParam UIElementType - Type of *UIElement* that is specified by 'builder'-*parameter*.
         *
         * @param builder - *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use {@link UIElementBuilders} for selection.
         * @param scale - Optional parameter for altering the coordinate system used for positioning the UIElement. Defaults to whole component in percentages [0, 100].
         * @returns Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
         * @public
         */
        addUIElement<UIElementType extends UIPart = UITextBox>(uiElementBuilder?: UIElementBuilder<UIElementType>, scale?: UserScaleDefinition): UIElementType & UIElement;
        /**
         * Add a *legendbox*.
         *
         * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
         * with user interactions, as well as positioned in application code.
         *
         * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
         * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
         *
         * **Legendbox alignment:**
         *
         * Alignment of legendbox can be selected by supplying one of the available {@link LegendBoxBuilders} to `addLegendBox`:
         *
         * ```typescript
         *  // Default (vertical) LegendBox.
         *  const legendBox = ChartXY.addLegendBox()
         *
         *  // Horizontal LegendBox.
         *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
         * ```
         *
         * **Custom Legendbox positioning:**
         *
         * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
         *
         * A custom location can be configured with {@link UIElement} API:
         * - {@link UIElement.setPosition}
         * - {@link UIElement.setOrigin}
         * - {@link UIElement.setMargin}
         *
         * *Position coordinate system* is specified when creating *legendbox*.
         *
         * 1) LegendBox with default positioning coordinate system.
         *
         * ```typescript
         *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
         *      // Position = [0, 100] as percentages.
         *      .setPosition({ x: 50, y: 50 })
         * ```
         *
         * 2) Position in pixel coordinate system.
         *
         * ```typescript
         *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.coordsRelative )
         *      // Position = pixels.
         *      .setPosition({ x: 300, y: 100 })
         * ```
         *
         * 3) Position on Axes.
         *
         * ```typescript
         *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
         *      // Position = Axis values.
         *      .setPosition({ x: 5, y: 5 })
         * ```
         *
         * @param builder - *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use {@link LegendBoxBuilders} for selection.
         * @param scale - Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in percentages [0, 100].
         * @returns LegendBox
         * @public
         */
        addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox;
        /**
         * Capture rendered state in an image file. Prompts the browser to download the created file.
         *
         * **NOTE: The download might be blocked by browser/plugins as harmful.**
         * To prevent this, only call the method in events tied to user-interactions.
         * From mouse-event handlers, for example.
         *
         * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
         * For supported image formats, compression quality, Etc. refer to:
         *
         * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
         *
         * Example usage:
         *```javascript
         * // Download 'screenshot.png'
         * saveToFile('screenshot')
         * // Attempt download 'maybeNotSupported.bmp'
         * saveToFile('maybeNotSupported', 'image/bmp')
         * // Attempt download jpeg.file with specified compression quality
         * saveToFile('fileName', 'image/jpeg', 0.50)
         * ```
         *
         * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
         *
         * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
         *                          as it is automatically detected from 'type'-argument.
         * @param type - A DOMString indicating the image format. The default format type is image/png.
         * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
         *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
         *                          the default value for image quality is used. The default value is 0.92.
         * @public
         */
        saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
        /**
         * Returns the Theme currently being used.
         * @returns An object containing the Theme.
         * @public
         */
        getTheme(): Theme;
    }
    /**
     * Interface for a data-structure which represents a 3-dimensional location.
     *
     * **Required properties:**
     *
     * - {@link Coord3D.x} | coordinate along X Axis.
     * - {@link Coord3D.y} | coordinate along Y Axis.
     * - {@link Coord3D.z} | coordinate along Z Axis.
     * @public
     */
    export declare interface Coord3D {
        /**
         * Location in X-dimension.
         */
        readonly x: number;
        /**
         * Location in Y-dimension.
         */
        readonly y: number;
        /**
         * Location in Z-dimension.
         */
        readonly z: number;
    }
    /**
     * Interface for a ambiguous 3D coordinate.
     * Ambiguous meaning that it doesn't explicitly tell which coordinate system it belongs to.
     *
     * Intended to be used with {@link Chart3D.translateCoordinate}.
     * @public
     */
    export declare type Coordinate3D = {
        x: number;
        y: number;
        z: number;
    };
    /**
     * Interface for a coordinate in Bar chart coordinate system
     *
     * Here, coordinates are described with a combination of "category index" and "value".
     * For example, `{ iCategory: 0, value: 10 }` describes the coordinate at `10` along Value Axis and the **center** of the first category bar.
     *
     * Intended to be used with {@link BarChart.translateCoordinate}.
     * @public
     */
    export declare type CoordinateBarChart = {
        iCategory: number;
        value: number;
    };
    /**
     * Interface for a coordinate in HTML client coordinate system.
     *
     * This references the coordinate system used in HTML.
     * It starts at top left of the web page and is measured in pixels.
     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
     *
     * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
     *
     * ```ts
     *  // Example of a CoordinateClient
     *  const coordinateClient = { clientX: 45, clientY: 10 }
     * ```
     *
     * Intended to be used with {@link Control.translateCoordinate}.
     * @public
     */
    export declare type CoordinateClient = {
        clientX: number;
        clientY: number;
    };
    /**
     * Interface for a coordinate in {@link PolarChart}.
     *
     * Polar coordinates are specified as a combination of `amplitude` and `angle`.
     * Their location on the web page depends on the location of the {@link PolarChart} as well as the interval of its Axes.
     *
     * ```ts
     *  // Example of a PolarCoordinate
     *  const polarCoordinate = { angle: 45, amplitude: 10 }
     * ```
     *
     * Intended to be used with {@link PolarChart.translateCoordinate}.
     * @public
     */
    export declare type CoordinatePolar = PolarPoint;
    /**
     * Type definition for describing a Coordinate System along an X and Y axis.
     *
     * Mainly related to {@link ChartXY.translateCoordinate}.
     *
     * Axis coordinates are specified as X and Y numbers.
     * Their location on the web page depends on the location of the {@link ChartXY} as well as the interval of its Axes.
     *
     * ```ts
     *  // Example of an Axis coordinate
     *  const axisCoordinate = { x: 45, y: 10 }
     * ```
     *
     * An Axis coordinate system can be specified in two ways:
     *
     * **(1) Select the default X and Y axes with a quick convenience selector:**
     *
     * ```ts
     *  ChartXY.translateCoordinate({ x: 0, y: 0 }, chart.coordsAxis, chart.coordsClient)
     * ```
     *
     * **(2) Specify arbitrary pair of X and Y Axes:**
     *
     * ```ts
     *  ChartXY.translateCoordinate({ x: 0, y: 0 }, { x: myAxisX, y: chart.getDefaultAxisX() }, chart.coordsClient)
     * ```
     *
     *
     * @public
     */
    export declare type CoordinateSystemAxis = {
        x: Axis;
        y: Axis;
    };
    /**
     * Type definition for selector of bar chart coordinate system.
     *
     * Here, coordinates are described with a combination of "category index" and "value".
     * For example, `{ iCategory: 0, value: 10 }` describes the coordinate at `10` along Value Axis and the **center** of the first category bar.
     *
     * By using {@link BarChart.translateCoordinate} method, client coordinates can be translated to other coordinate systems and vice versa.
     * For example, in order to:
     * - Position LCJS UI elements in relative to Bar locations.
     * - Find client coordinate relative to a Bar, for example to position external HTML content above them.
     * - etc.
     *
     * Users should not need to reference this type directly.
     * Instead, the convenience selector {@link BarChart.coordsBars} should be used.
     *
     * @public
     */
    export declare type CoordinateSystemBarChart = 'barChart';
    /**
     * Type definition for selector of HTML client coordinate system.
     *
     * This references the coordinate system used in HTML.
     * It starts at top left of the web page and is measured in pixels.
     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
     *
     * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
     *
     * ```ts
     *  // Example of a CoordinateClient
     *  const coordinateClient = { clientX: 45, clientY: 10 }
     * ```
     *
     * By using {@link Control.translateCoordinate} method, client coordinates can be translated to other coordinate systems and vice versa.
     * For example, in order to:
     * - Position LCJS UI elements in client coordinates
     * - Find client coordinate that matches a location along LCJS Axis or Chart.
     * - etc.
     *
     * Users should not need to reference this type directly.
     * Instead, the convenience selector {@link Control.coordsClient} should be used.
     *
     * @public
     */
    export declare type CoordinateSystemClient = 'client';
    /**
     * Interface for a description of 3D coordinate system.
     *
     * Used with {@link Chart3D.translateCoordinate}.
     *
     * This should not be used directly. Instead, you should reference one of following properties:
     * - {@link Chart3D.coordsAxis}
     * - {@link Chart3D.coordsWorld}
     *
     * @public
     */
    export declare type CoordinateSystemDefinition3D = {
        id: 'world';
        chart: Chart3D;
    } | {
        id: 'axes';
        chart: Chart3D;
    };
    /**
     * Interface for a description of Polar coordinate system.
     *
     * Mainly related to {@link PolarChart.translateCoordinate}.
     *
     * Users should not need to reference this type directly.
     * Instead, the convenience selector {@link PolarChart.coordsAxis} should be used.
     *
     * Polar coordinates are specified as a combination of `amplitude` and `angle`.
     * Their location on the web page depends on the location of the {@link PolarChart} as well as the interval of its Axes.
     *
     * ```ts
     *  // Example of a PolarCoordinate
     *  const polarCoordinate = { angle: 45, amplitude: 10 }
     * ```
     *
     * @public
     */
    export declare type CoordinateSystemPolar = {
        axisAmplitude: PolarAxisAmplitude;
        axisRadial: PolarAxisRadial;
    };
    /**
     * Type definition for selector of relative coordinate system.
     *
     * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
     *
     * ```ts
     *  // Example of a CoordinateRelative
     *  const coordinateRelative = { x: 45, y: 10 }
     * ```
     *
     * By using {@link Control.translateCoordinate} method, relative coordinates can be translated to other coordinate systems and vice versa.
     * For example, in order to:
     * - Position LCJS UI elements in pixels relative to control.
     * - Find locations expressed with other coordinate systems relative to the control.
     * - etc.
     *
     * Users should not need to reference this type directly.
     * Instead, the convenience selector {@link Control.coordsRelative} should be used.
     *
     * @public
     */
    export declare type CoordinateSystemRelative = 'relative';
    /**
     * Interface for an ambiguous coordinate with X and Y properties.
     * Ambiguous meaning that it doesn't explicitly tell which coordinate system it belongs to.
     *
     * Intended to be used with {@link Control.translateCoordinate}.
     * @public
     */
    export declare type CoordinateXY = {
        x: number;
        y: number;
    };
    /**
     * Data structure of a **country**.
     * @public
     */
    export declare interface Country {
        /**
         * Name of the country. Eq. 'Finland'. This is case insensitive.
         *
         * Roughly follows the [M49 standard](https://unstats.un.org/unsd/methodology/m49/).
         */
        name: string;
        /**
         * ISO_A3 code of the country. Eq. 'FIN'. This is case insensitive.
         *
         * Roughly follows the [M49 standard](https://unstats.un.org/unsd/methodology/m49/).
         */
        ISO_A3: string;
    }
    /**
     * Type definition for different configurations of 3D culling.
     *
     * Culling means skipping drawing of specific geometry parts, based on its orientation.
     *
     * `'disabled'` -\> full geometry is drawn.
     *
     * `'cull-back'` -\> the behind of geometry is **not** drawn.
     *
     * `'cull-front'` -\> the front of geometry is **not** drawn.
     * @public
     */
    export declare type CullMode3D = 'disabled' | 'cull-back' | 'cull-front';
    /**
     * Cursor is a hidable element that can be positioned on a point using a
     * data-structure called 'DataPoint'. Cursors are formed from two
     * distinct parts, PointMarker and ResultTable, first of which
     * shows the location of the Cursor clearly and the second
     * to display information about the pointed DataPoint.
     * @public
     */
    export declare interface Cursor<ResultTableBackgroundType extends UIBackground = UIBackground> extends Plotable, Hideable, Disposable {
        /**
         * Points the Cursor at a given CursorPoint.
         * Updating its position and displayed data.
         * @public
         */
        pointAt: (point: CursorPoint) => this;
        /**
         * Get current position of Cursor on its scale
         * @returns Position on Cursors scale
         * @public
         */
        getPosition: () => Point;
        /**
         * Set point marker visible or not.
         *
         * @param   visible  -   Point marker visible?
         * @returns              Object itself.
         * @public
         */
        setPointMarkerVisible(visible: boolean): this;
        /**
         * Get point marker visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getPointMarkerVisible(): boolean;
        /**
         * Mutator function for PointMarker.
         * PointMarker is a visual that is displayed at the Cursors position
         * @param mutator - Mutator function for PointMarker
         * @returns Object itself for fluent interface
         * @public
         */
        setPointMarker: (mutator: Mutator<PointMarker>) => this;
        /**
         * Get PointMarker object.
         * PointMarker is a visual that is displayed at the Cursors position
         * @returns PointMarker object
         * @public
         */
        getPointMarker: () => PointMarker;
        /**
         * Set result table visible or not.
         *
         * @param   visible  -   Result table visible?
         * @returns              Object itself.
         * @public
         */
        setResultTableVisible(visible: boolean): this;
        /**
         * Get result table visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getResultTableVisible(): boolean;
        /**
         * Mutator function for ResultTable.
         * ResultTable is a visual that displays currently pointed data next to its location
         * @param mutator - Mutator function for ResultTable
         * @returns Object itself for fluent interface
         * @public
         */
        setResultTable: (mutator: Mutator<ResultTable<ResultTableBackgroundType>>) => this;
        /**
         * Get ResultTable object.
         * ResultTable is a visual that displays currently pointed data next to its location
         * @returns ResultTable object
         * @public
         */
        getResultTable: () => ResultTable<ResultTableBackgroundType>;
        /**
         * Set AutoFitStrategy of Cursor. Customizable logic which attempts to fit ResultTable to view.
         *
         * See {@link AutoFitStrategies} for available options.
         * @param autoFitStrategy - AutoFitStrategy or undefined to disable auto-fitting
         * @returns Object itself for fluent interface
         * @public
         */
        setAutoFitStrategy(autoFitStrategy?: AutoFitStrategyFactory<ResultTableBackgroundType>): this;
        /**
         * Get is AutoFitStrategy enabled. Customizable logic which attempts to fit ResultTable to view.
         * @returns Boolean flag whether auto-fit is enabled
         * @public
         */
        getAutoFitStrategy(): boolean;
    }
    /**
     * Base class for all cursors.
     * @public
     */
    declare abstract class CursorBase<ResultTableBackgroundType extends UIBackground> implements InternalCursor<ResultTableBackgroundType>, Hideable {
        /**
         * @public
         */
        readonly scale: ScaleXY;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         */
        dispose(): this;
        /**
         * Points the Cursor at a given CursorPoint.
         * Updating its position and displayed data.
         * @param cursorPoint - Specifies new cursor location and content of result table
         * @public
         */
        pointAt(cursorPoint: CursorPoint): this;
        /**
         * Get current position of Cursor
         * @returns Position on Cursors scale
         * @public
         */
        getPosition(): Point;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         * @public
         */
        setVisible(state: boolean): this;
        /**
         * Get element visibility.
         *
         * @returns `true` when element is set to be visible and `false` otherwise.
         * @public
         */
        getVisible(): boolean;
        /**
         * Set point marker visible or not.
         *
         * @param   visible   -  Point marker visible?
         * @returns              Object itself.
         * @public
         */
        setPointMarkerVisible(visible: boolean): this;
        /**
         * Get point marker visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getPointMarkerVisible(): boolean;
        /**
         * Mutator function for Cursors PointMarker.
         * PointMarker is a visual that is displayed at the Cursors position
         * @param mutator - Mutator function for PointMarker
         * @returns Object itself for fluent interface
         * @public
         */
        setPointMarker(mutator: Mutator<PointMarker>): this;
        /**
         * Get PointMarker object.
         * PointMarker is a visual that is displayed at the Cursors position
         * @returns PointMarker object
         * @public
         */
        getPointMarker(): PointMarker;
        /**
         * Set result table visible or not.
         *
         * @param   visible   -  Result table visible?
         * @returns              Object itself.
         * @public
         */
        setResultTableVisible(visible: boolean): this;
        /**
         * Get result table visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getResultTableVisible(): boolean;
        /**
         * Mutator function for Cursors ResultTable.
         * ResultTable is a visual that displays currently pointed data next to its location
         * @param mutator - Mutator function for ResultTable
         * @returns Object itself for fluent interface
         * @public
         */
        setResultTable(mutator: Mutator<ResultTable<ResultTableBackgroundType>>): this;
        /**
         * Get ResultTable object.
         * ResultTable is a visual that displays currently pointed data next to its location
         * @returns ResultTable object
         * @public
         */
        getResultTable(): ResultTable<ResultTableBackgroundType>;
        /**
         * Set auto-fit strategy of Cursor.
         * Affects logic of automatic fitting of Cursors ResultTable to the screen.
         * @param autoFitStrategy - AutoFitStrategy factory or undefined to disable auto-fitting
         * @returns Object itself for fluent interface
         * @public
         */
        setAutoFitStrategy(autoFitStrategy?: AutoFitStrategyFactory<ResultTableBackgroundType>): this;
        /**
         * Get is auto-fit enabled.
         * Affects logic of automatic fitting of Cursors ResultTable to the screen.
         * @returns Boolean flag whether auto-fit is enabled
         * @public
         */
        getAutoFitStrategy(): boolean;
    }
    /**
     * Base class for cursor builders.
     * Cursor builders build cursors with parts of types as indicated by the builders type.
     * All setters of Cursor builders create new builders based on their current state and don't modify the actual object.
     * @public
     */
    export declare abstract class CursorBuilder<ResultTableBackgroundType extends UIBackground, CursorType extends Cursor<ResultTableBackgroundType>> {
        /**
         * Create new CursorBuilder with an additional styler.
         * @param cursorStyler - Cursor styler function
         * @returns CursorBuilder of same type
         * @public
         */
        abstract addStyler: (cursorStyler: CursorStyler<CursorType>) => ThisType<this>;
        /**
         * Create new CursorBuilder with a different ResultTable Background.
         * @param resultTableBackgroundConstructor - Constructor for Background
         * @returns CursorBuilder of same type
         * @public
         */
        abstract setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => ThisType<this>;
    }
    /**
     * Base class for cursorXY builders
     * @public
     */
    export declare abstract class CursorBuilderXY<ResultTableBackgroundType extends UIBackground, CursorType extends CursorXY<ResultTableBackgroundType>> extends CursorBuilder<ResultTableBackgroundType, CursorType> {
    }
    /**
     * Interface that is used to point a Cursor to a specific data-point.
     * @public
     */
    export declare interface CursorPoint {
        /**
         * Location of point
         * @public
         */
        location: Point;
        /**
         * Scale where point is located
         * @public
         */
        scale: ScaleXY;
        /**
         * Contents for ResultTable
         * @public
         */
        resultTableContent: ResultTableContent;
        /**
         * Chart component that is pointed at.
         * This could be a series, slice, etc.
         * @public
         */
        owner: unknown;
        /**
         * Optional attached fillStyle
         * @public
         */
        fillStyle?: FillStyle;
    }
    /**
     * Mutator function that is used for modifying a Cursor during runtime.
     * @public
     */
    export declare type CursorStyler<T extends Cursor> = (cursor: T, theme: Theme) => unknown;
    /**
     * A type of Cursor that is plotted along two axes.
     * Adds customizable gridStrokes and tickMarkers
     * @public
     */
    export declare interface CursorXY<ResultTableBackgroundType extends UIBackground = UIBackground> extends Cursor<ResultTableBackgroundType> {
        /**
         * Set is GridStrokeX cut at cursor location.
         * @param cut - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeXCut: (cut: boolean) => this;
        /**
         * Get is GridStrokeX cut at cursor location.
         * @returns Boolean flag
         * @public
         */
        getGridStrokeXCut: () => boolean;
        /**
         * Set is GridStrokeY cut at cursor location.
         * @param cut - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeYCut: (cut: boolean) => this;
        /**
         * Get is GridStrokeY cut at cursor location.
         * @returns Boolean flag
         * @public
         */
        getGridStrokeYCut: () => boolean;
        /**
         * Set style of x gridstroke
         * @param value - LineStyle object
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeXStyle: (value: LineStyle | ImmutableMutator<LineStyle>) => this;
        /**
         * Get style of x gridstroke
         * @returns LineStyle of gridstroke
         * @public
         */
        getGridStrokeXStyle: () => LineStyle;
        /**
         * Set style of y gridstroke
         * @param value - LineStyle object
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeYStyle: (value: LineStyle | ImmutableMutator<LineStyle>) => this;
        /**
         * Get style of y gridstroke
         * @returns LineStyle of gridstroke
         * @public
         */
        getGridStrokeYStyle: () => LineStyle;
        /**
         * Set TickMarkerX.
         * @param mutator - Mutator function for cursors X tickMarker
         * @returns Object itself for fluent interface
         * @public
         */
        setTickMarkerX: (mutator: Mutator<TickMarker>) => this;
        /**
         * Set TickMarkerY.
         * @param mutator - Mutator function for cursors Y tickMarker
         * @returns Object itself for fluent interface
         * @public
         */
        setTickMarkerY: (mutator: Mutator<TickMarker>) => this;
        /**
         * Set tick marker X visible or not.
         *
         * @param   visible   -  Tick marker X visible?
         * @returns              Object itself.
         * @public
         */
        setTickMarkerXVisible(visible: boolean): this;
        /**
         * Get tick marker X visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getTickMarkerXVisible(): boolean;
        /**
         * Set tick marker Y visible or not.
         *
         * @param   visible   -  Tick marker Y visible?
         * @returns              Object itself.
         */
        setTickMarkerYVisible(visible: boolean): this;
        /**
         * Get tick marker Y visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getTickMarkerYVisible(): boolean;
    }
    /**
     * Interface for object that has stylable and settable text.
     * @public
     */
    export declare type CustomizableText = StyleTextAPI & GettableText & SettableText;
    /**
     * Class that represents a single *Axis tick* that can be managed by the user.
     *
     * *Custom ticks* are created with {@link Axis.addCustomTick}.
     *
     * **Frequently used methods:**
     *
     * | Method | Purpose |
     * |------------ | ------------------------------ |
     * | {@link setValue} | Set tick position along Axis. |
     * | {@link setTextFormatter} | Set tick label text using a callback function. |
     * | {@link dispose} | Destroy tick permanently |
     * | {@link setGridStrokeStyle} | Set tick gridline style |
     * | {@link setTickLength} | Set tick line length as pixels |
     * | {@link setTickLabelPadding} | Set padding between tick line and label |
     *
     * **Styling CustomTicks:**
     *
     * Tick gridline can be styled with {@link CustomTick.setGridStrokeStyle}
     *
     * *TickMarker* (label, tick, possible background) are styled via {@link CustomTick.setMarker} as a callback function, like this:
     *
     * ```typescript
     *  CustomTick.setMarker((tickMarker) => tickMarker
     *      // Style TickMarker.
     *      .setTextFillStyle(new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }))
     *      .setFont((font) => font.setStyle( 'italic' ))
     *  )
     * ```
     *
     * See {@link TickMarker} for available customization API.
     *
     * **Styling specific TickMarkers:**
     *
     * When a *custom tick* is created, a *tick marker builder* can be specified.
     * This specifies the shape, and general visual look of the *custom tick*, and can also
     * expose a larger set of customization API for the *tick marker*.
     * To use the specific API, it is required to cast the *tick marker* object to the correct type (*TypeScript* users only):
     *
     * ```typescript
     *  const customTick = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
     *  customTick.setMarker((tickMarker: UIPointableTextBox) => tickMarker
     *      // ^ Above type cast is necessary to access full configuration API of UIPointableTextBox
     *      // Style TickMarker background fill color.
     *      .setBackground((background) => background
     *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0, 100) }))
     *      )
     *  )
     * ```
     *
     * For reference,
     * - CustomTick created with `UIElementBuilders.AxisTickMajor` or `UIElementBuilders.AxisTickMinor` will support API as described by {@link UITick}
     * - CustomTick created with `UIElementBuilders.PointableTextBox` will support API as described by {@link UIPointableTextBox}
     * @public
     */
    export declare abstract class CustomTick extends UIObject implements Disposable {
        /**
         * Axis that CustomTick belongs to.
         * @public
         */
        readonly axis: Axis;
        /**
         * @public
         */
        readonly axisScale: LinearScale1D | LogarithmicScale1D;
        /**
         * @public
         */
        readonly renderingScale: LinearScaleXY;
        /**
         * Sets the position of this custom tick on its Axis
         * @param value - Value in the units of main scale
         * @returns This for fluid interface
         * @remarks  Overrides text of CustomTicks Marker with formated value.
         * @public
         */
        setValue(value: number): this;
        /**
         * Value of CustomTick
         * @public
         */
        getValue(): number;
        /**
         * Set text of CustomTicks' Marker with a formatting function.
         *
         * Example usage:
         *```javascript
         * // Marker shows formatted position of CustomTick on its Axis
         * CustomTick.setTextFormatter((position, customTick) => customTick.axis.formatValue(position))
         * // Marker shows 'Hello world'
         * CustomTick.setTextFormatter((position, customTick) => 'Hello world')
         * ```
         * @param textFormatter - A function of type: *CustomTickTextFormatter*, that defines text of CustomTicks' Marker.
         * @returns Object itself
         * @public
         */
        setTextFormatter(textFormatter: CustomTickTextFormatter): this;
        /**
         * Set tick length as pixels.
         * @param length - Tick length as pixels.
         * @returns Object itself for fluent interface.
         * @public
         */
        setTickLength(length: pixel): this;
        /**
         * Get tick length as pixels.
         * @returns Tick length as pixels.
         * @public
         */
        getTickLength(): pixel;
        /**
         * Set pixel padding between tick line and label.
         * @public
         */
        setTickLabelPadding(padding: pixel): this;
        /**
         * Set rotation of tick label.
         * @param value - Rotation in degrees
         * @returns Object itself
         * @public
         */
        setTickLabelRotation(value: number): this;
        /**
         * Get rotation of tick label.
         * @returns Rotation in degrees
         * @public
         */
        getTickLabelRotation(): number;
        /**
         * Get pixel padding between tick line and label.
         * @public
         */
        getTickLabelPadding(): pixel;
        /**
         * Set length of grid stroke in percents
         * @param length - Grid line length as a % of viewport size
         * @returns This for fluent interface
         * @public
         */
        setGridStrokeLength(length: number): this;
        /**
         * @returns Grid stroke length as a % of the viewport size
         * @public
         */
        getGridStrokeLength(): number;
        /**
         * Set style of grid stroke.
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link DashedLine}
         * - {@link emptyLine}
         *
         * @param value - Grid stroke style
         * @returns This for fluent interface
         * @public
         */
        setGridStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * @returns Grid stroke style as a LineStyle object
         * @public
         */
        getGridStrokeStyle(): LineStyle;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Subscribe `onDispose` event.
         * This event is triggered whenever the Control (Dashboards and all chart types) is disposed.
         *
         * ```typescript
         *  // Example usage
         *
         * Chart.onDispose(() => {
         *   console.log('chert was disposed')
         * })
         *
         * Chart.dispose()
         * ```
         *
         * @param handler - Handler function for event
         * @returns Token of subscription
         * @public
         */
        onDispose(handler: (object: this) => unknown): Token;
        /**
         * Remove event listener from dispose event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offDispose(token: Token): boolean;
        /**
         * Set marker visible or not.
         *
         * @param   visible    - Marker visible?
         * @returns              Object itself
         * @public
         */
        setMarkerVisible(visible: boolean): this;
        /**
         * Get marker visible or not.
         *
         * @returns              Boolean.
         * @public
         */
        getMarkerVisible(): boolean;
        /**
         * Configure *custom ticks* *TickMarker* (label, tick, possible background) via a callback function.
         *
         * **Example usage:**
         *
         * ```typescript
         *  CustomTick.setMarker((tickMarker) => tickMarker
         *      // Style TickMarker.
         *      .setTextFillStyle(new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }))
         *      .setFont((font) => font.setStyle( 'italic' ))
         *  )
         * ```
         *
         * See {@link TickMarker} for available customization API.
         *
         * **Styling specific TickMarkers:**
         *
         * When a *custom tick* is created, a *tick marker builder* can be specified.
         * This specifies the shape, and general visual look of the *custom tick*, and can also
         * expose a larger set of customization API for the *tick marker*.
         * To use the specific API, it is required to cast the *tick marker* object to the correct type (*TypeScript* users only):
         *
         * ```typescript
         *  const customTick = Axis.addCustomTick(UIElementBuilders.PointableTextBox)
         *  customTick.setMarker((tickMarker: UIPointableTextBox) => tickMarker
         *      // ^ Above type cast is necessary to access full configuration API of UIPointableTextBox
         *      // Style TickMarker background fill color.
         *      .setBackground((background) => background
         *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0, 100) }))
         *      )
         *  )
         * ```
         *
         * For reference,
         * - CustomTick created with `UIElementBuilders.AxisTickMajor` will support API as described by {@link UITick}
         * - CustomTick created with `UIElementBuilders.PointableTextBox` will support API as described by {@link UIPointableTextBox}
         * @public
         */
        setMarker(mutator: Mutator<TickMarker>): this;
        /**
         * Get *custom ticks* *TickMarker* (label, tick, possible background).
         * @returns TickMarker object
         * @public
         */
        getMarker(): TickMarker;
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setMouseInteractions(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getMouseInteractions(): boolean;
        /**
         * Set whether `CustomTick` should allocate space on its `Axis`.
         *
         * By default, this is `true`, which means that `Axis` will always make sure it is big enough to fit the tick.
         *
         * By setting to `false`, this particular `CustomTick` can be removed from this behaviour, which can be useful in applications
         * where some custom ticks are only enabled temporarily. Disabling this functionality can prevent the size of the Axis from changing in unwanted ways.
         *
         * ```ts
         *  // Example syntax, disable custom tick space allocation.
         *  CustomTick.setAllocatesAxisSpace(false)
         * ```
         * @param shouldAxisAllocateSpace - Boolean flag.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAllocatesAxisSpace(shouldAxisAllocateSpace: boolean): this;
        /**
         * Get whether `CustomTick` should allocate space on its `Axis`.
         *
         * By default, this is `true`, which means that `Axis` will always make sure it is big enough to fit the tick.
         *
         * By setting to `false`, this particular `CustomTick` can be removed from this behaviour, which can be useful in applications
         * where some custom ticks are only enabled temporarily. Disabling this functionality can prevent the size of the Axis from changing in unwanted ways.
         *
         * @returns Boolean flag.
         * @public
         */
        getAllocatesAxisSpace(): boolean;
        /**
         * Check that customTick fit the main scale
         * @returns Boolean with the result
         * @public
         */
        isInScale(): boolean;
        /**
         * Subscribe to value change event.
         * This event is triggered when {@link setValue} is called.
         *
         * **Example usage:**
         *
         *```javascript
         * // Set onValueChange event
         * CustomTick.onValueChange((tick, num) => {
         *  console.log(num)
         * })
         *
         * // Set customTick value
         * CustomTick.setValue(20)
         *
         * ```
         * @param handler - Function that is called when event is triggered.
         * @param value - Position of CustomTick.
         * @returns Token that can be used to unsubscribe from the event.
         * @public
         */
        onValueChange(handler: (obj: this, value: number) => unknown): Token;
        /**
         * Unsubscribe from value change event.
         *
         * This event is called whenever the position of the *CustomTick* is changed via  **CustomTick.setValue**.
         * @param token - Token that was received when the subscription was created.
         * @returns True if unsubscription was successful.
         * @public
         */
        offValueChange(token: Token): boolean;
    }
    /**
     * End user managed 3D Axis Tick. Custom ticks are just like default ticks, except they can be completely controlled by the end user.
     *
     * For example, their position, text, text fill style, gridline style, etc. everything can be customized.
     * They can be created whenever and destroyed whenever.
     *
     * They are created with {@link Axis3D.addCustomTick} method, and destroyed with {@link dispose} method.
     *
     * ```ts
     *  // Example
     *  const customTick = chart3D.getDefaultAxisX().addCustomTick()
     *      // Tick position on Axis.
     *      .setValue(100)
     *      .setTextFormatter((value) => `Custom tick at ${value.toFixed(1)}`)
     * ```
     *
     * Default 3D Axis ticks can be hidden by selecting empty tick strategy.
     *
     * ```ts
     *  // Remove default ticks.
     *  Chart3D.getDefaultAxisX().setTickStrategy(AxisTickStrategies.Empty)
     * ```
     *
     * @public
     * @privateRemarks  End user interface for 3D custom tick.
     */
    export declare interface CustomTick3D extends AbstractCustomTick {
    }
    /**
     * Interface for function which specifies CustomTick text.
     * @public
     */
    export declare type CustomTickTextFormatter = (value: number, customTick: CustomTick) => string;
    /**
     * *Dashboard* is a component for flexible positioning of multiple *Chart*s efficiently.
     * It is created with {@link LightningChart.Dashboard} method.
     *
     * Upon its creation an amount of *columns* and *rows* is specified. *Charts* and other components can
     * then be placed in cells with given *column* and *row*-locations and sizes
     * (using methods of *Dashboard*. For example: {@link Dashboard.createChartXY}.
     *
     * The *Dashboard* will distribute the available space for *columns* and *rows*, which users can resize
     * with mouse and touch interactions or programmatically.
     * @public
     */
    export declare class Dashboard implements Control, Validatable {
        /**
         * Selector for "relative" _Coordinate System_.
         *
         * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
         * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
         *
         * This selector can be used for two purposes:
         *
         * **Positioning LCJS UI elements in pixels:**
         *
         * ```ts
         *  // Position UI element in pixels by supplying `Control.coordsRelative` as its positioning system.
         *  const textBox = Control.addUIElement(UIElementBuilders.TextBox, Control.coordsRelative)
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 100, y: 20 })
         * ```
         *
         * **Translations between coordinate systems:**
         *
         * Use with {@link translateCoordinate} method to translate coordinates from "relative" to another coordinate system.
         *
         * @public
         */
        readonly coordsRelative: CoordinateSystemRelative;
        /**
         * Selector for "client" _Coordinate System_.
         *
         * This references the coordinate system used in HTML.
         * It starts at top left of the web page and is measured in pixels.
         * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
         *
         * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
         *
         * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
         * For example, in order to:
         * - Position LCJS UI elements in client coordinates
         * - Find client coordinate that matches a location along LCJS Axis or Chart.
         * - etc.
         *
         * See {@link translateCoordinate} for more detailed use case information and example usage.
         *
         * @public
         */
        readonly coordsClient: CoordinateSystemClient;
        /**
         * Public, safe interface for Dashboards rendering engine.
         * @public
         */
        readonly engine: PublicEngine;
        /**
         * Scale that represents dashboard area in percents (0-100).
         *
         * While it is not functionally equal to this, using [[coordsRelative]] coordinate system is preferred (more confidence for long term support)
         * @public
         */
        readonly uiScale: LinearScaleXY;
        /**
         * Scale that represents dashboard area in pixels.
         * @public
         * @deprecated  This method signature is deprecated since v4.2.0. Use [[coordsRelative]] instead. It works exactly the same.
         */
        readonly pixelScale: LinearScaleXY;
        /**
         * Set the minimum and maximum boundaries for dashBoard horizontal size.
         * @param boundary - Single value for static engine size, or a tuple for size range [min, max] in pixels.
         * @public
         */
        setWidth(boundary: number | [number | undefined, number | undefined] | undefined): this;
        /**
         * Set the minimum and maximum boundaries for dashBoard vertical size.
         * @param boundary - Single value applied to both minimum and maximum size, or a tuple for [min, max] size in pixels.
         * @public
         */
        setHeight(boundary: number | [number | undefined, number | undefined] | undefined): this;
        /**
         * Get the minimum and maximum horizontal boundaries used for the Dashboard.
         * @returns Horizontal boundaries as a tuple [minSize, maxSize]
         * @public
         */
        getWidth(): [number | undefined, number | undefined] | undefined;
        /**
         * Get the minimum and maximum vertical boundaries used for the Dashboard.
         * @returns Vertical boundaries as a tuple [minSize, maxSize]
         * @public
         */
        getHeight(): [number | undefined, number | undefined] | undefined;
        /**
         * Set fillStyle of dashboard background.
         * @param fillStyle - FillStyle or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setBackgroundFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fillStyle of dashboard
         * @returns FillStyle
         * @public
         */
        getBackgroundFillStyle(): FillStyle;
        /**
         * Set stroke style of dashboard background.
         * @param value - LineStyle
         * @returns Object itself
         * @public
         */
        setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of dashboard background.
         * @returns LineStyle
         * @public
         */
        getBackgroundStrokeStyle(): LineStyle;
        /**
         * Get theme used for the dashboard.
         * @returns Theme
         * @public
         */
        getTheme(): Theme;
        /**
         * Set style of Dashboard splitters.
         *
         * Note, that highlighted splitters have a separate style {@link setSplitterStyleHighlight}.
         *
         * Example usage:
         *```javascript
         * // Specified LineStyle
         * Dashboard.setSplitterStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
         * // Changed thickness
         * Dashboard.setSplitterStyle((solidLine) => solidLine.setThickness(5))
         * // Hidden
         * Dashboard.setSplitterStyle(emptyLine)
         * ```
         * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
         * @returns Chart itself
         * @public
         */
        setSplitterStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of Dashboard splitters.
         * @returns LineStyle object
         * @public
         */
        getSplitterStyle(): LineStyle;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setSplitterEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getSplitterEffect(): boolean;
        /**
         * Set component highlight animations enabled or not.
         * For most components this is enabled by default.
         *
         * ```ts
         *  // Example usage, disable highlight animations.
         *  component.setAnimationHighlight(false)
         * ```
         *
         * @param   enabled    - Animation enabled?
         * @returns            Object itself
         */
        setAnimationHighlight(enabled: boolean): this;
        /**
         * Get component highlight animations enabled or not.
         *
         * @returns      Animation enabled?
         */
        getAnimationHighlight(): boolean;
        /**
         * Set width of a column in relation to other columns. By default all column widths are `1`.
         *
         * By changing one columns width to `2`, it would make that column allocate twice as much width as others.
         *
         * ```ts
         * // Example, Dashboard with 3 columns with widths (20%, 20%, 60%) of dashboard width
         * dashboard.setColumnWidth( 0, 1 )
         * dashboard.setColumnWidth( 1, 1 )
         * dashboard.setColumnWidth( 2, 3 )
         * ```
         * @param index - Index of the column (starts from 0)
         * @param relativeWidth - Relative width of the column, can be any number.
         * @public
         */
        setColumnWidth(index: number, relativeWidth: number): this;
        /**
         * Get width of a column in relation to other columns. By default all column widths are `1`.
         *
         * Example usage:
         * ```ts
         * dashboard.getColumnWidth( 0 )
         * ```
         * @param index - Index of the column (starts from 0)
         * @returns Relative width of the column.
         * @public
         */
        getColumnWidth(index: number): number;
        /**
         * Set height of a row in relation to other rows. By default all row heights are `1`.
         *
         * By changing one rows height to `2`, it would make that row allocate twice as much height as others.
         *
         * ```ts
         * // Dashboard with 3 rows with heights (20%, 20%, 60%) of dashboard height
         * dashboard.setRowHeight( 0, 1 )
         * dashboard.setRowHeight( 1, 1 )
         * dashboard.setRowHeight( 2, 3 )
         * ```
         * @param index - Index of the row (starts from 0)
         * @param relativeHeight - Relative height of the row
         * @public
         */
        setRowHeight(index: number, relativeHeight: number): this;
        /**
         * Get height of a row in relation to other rows. By default all row heights are `1`.
         *
         * Example usage:
         *```javascript
         * dashboard.getRowHeight( 0 )
         * ```
         * @param index - Index of the row (starts from 0)
         * @public
         */
        getRowHeight(index: number): number;
        /**
         * Get size of control as pixels.
         *
         * For stand-alone component, the size will be equal to the size of its containing HTML \<div\> (`Control.engine.container`)
         *
         * For component inside Dashboard, the size will only include the component itself, so size can be less than the size of containing HTML \<div\>.
         *
         * @returns     Object with x and y properties `{ x: number, y: number }`, where both are pixel values.
         * @public
         */
        getSizePixels(): Point;
        /**
         * Subscribe to `resize` event.
         * This event is triggered whenever the size of dashboard changes (due to document or dashboard resizing).
         *
         * ```typescript
         *  // Example usage,
         *  Dashboard.onResize((_, width, height, engineWidth, engineHeight) => {
         *      console.log('Dashboard resized', 'width', width, 'height', height, 'engineWidth', engineWidth, 'engineHeight', engineHeight)
         *  })
         * ```
         *
         * This event is also triggered whenever dashboard splitter layout is changed, even if actual _dashboard size_ is unchanged.
         *
         * @param handler - Handler function for event
         * @param obj - Panel itself
         * @param width - Width of control in pixels
         * @param height - Height of control in pixels
         * @param engineWidth - Width of controls rendering engine in pixels
         * @param engineHeight - Height of controls rendering engine in pixels
         * @returns Token of subscription
         * @public
         */
        onResize(handler: (obj: this, width: number, height: number, engineWidth: number, engineHeight: number) => void): Token;
        /**
         * Remove event listener from resize event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offResize(token: Token): boolean;
        /**
         * Disable/Enable all animations of the Chart.
         * @param animationsEnabled - Boolean value to enable or disable animations.
         * @returns Chart itself for fluent interface.
         * @public
         */
        setAnimationsEnabled(animationsEnabled: boolean): this;
        /**
         * Get animations disable/enable state.
         * @returns Animations default state.
         * @public
         */
        getAnimationsEnabled(): boolean;
        /**
         * Get all defined cells in the dashboard.
         *
         * Further action can be done by testing the `cell.panel` for the instance type that you want to be interacting with.
         *
         * Example:
         * ```ts
         * const cells = dashboard.getCells()
         *
         * cells.forEach((cell) => {
         *     if (cell.panel instanceof Chart3D) {
         *         cell.panel.setBoundingBox({ x: 2, y: 1, z: 1 })
         *     }
         * })
         * ```
         * @returns All cells with content in dashboard
         * @public
         */
        getCells(): DashboardCell[];
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Subscribe `onDispose` event.
         * This event is triggered whenever the Control (Dashboards and all chart types) is disposed.
         *
         * ```typescript
         *  // Example usage
         *
         * Dashboard.onDispose(() => {
         *   console.log('Dashboard was disposed')
         * })
         *
         * Dashboard.dispose()
         * ```
         *
         * @param handler - Handler function for event
         * @returns Token of subscription
         * @public
         */
        onDispose(handler: (object: this) => unknown): Token;
        /**
         * Remove event listener from dispose event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offDispose(token: Token): boolean;
        /**
         * Subscribe to `inViewChange` event.
         * This event is triggered when the chart transitions from being off-screen to being on-screen and vice versa.
         *
         * @param obj - Dashboard itself
         * @param inView - State of panels visibility
         * @returns Token of subscription
         * @public
         */
        onInViewChange: (handler: (obj: this, inView: boolean) => void) => Token;
        /**
         * Remove event listener from `inViewChange` event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offInViewChange: (token: Token) => boolean;
        /**
         * Find if chart is currently considered to be in the browser viewport.
         * @returns `true` when panel is in view
         */
        getIsInView(): boolean;
        /**
         * Capture rendered state in an image file. Prompts the browser to download the created file.
         *
         * **NOTE: The download might be blocked by browser/plugins as harmful.**
         * To prevent this, only call the method in events tied to user-interactions.
         * From mouse-event handlers, for example.
         *
         * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
         * For supported image formats, compression quality, Etc. refer to:
         *
         * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
         *
         * Example usage:
         *```javascript
         * // Download 'screenshot.png'
         * Dashboard.saveToFile('screenshot')
         * // Attempt download 'maybeNotSupported.bmp'
         * Dashboard.saveToFile('maybeNotSupported', 'image/bmp')
         * // Attempt download jpeg.file with specified compression quality
         * Dashboard.saveToFile('fileName', 'image/jpeg', 0.50)
         * ```
         * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
         *
         * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
         *                          as it is automatically detected from 'type'-argument.
         * @param type - A DOMString indicating the image format. The default format type is image/png.
         * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
         *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
         *                          the default value for image quality is used. The default value is 0.92.
         * @public
         */
        saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
        /**
         * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
         *
         * ```ts
         *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
         *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
         *  // locationRelative is in pixels relative to bottom left corner of the chart
         * ```
         *
         * Relative coordinates can be used for positioning LightningChart JS UI components:
         *
         * ```ts
         *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
         *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
         *      .setOrigin(UIOrigins.LeftBottom)
         *      .setPosition({ x: 20, y: 20 })
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
        /**
         * Translate a coordinate from relative control coordinates to HTML client coordinate system.
         *
         * ```ts
         *  // 10 pixels left and 20 pixels up from controls bottom left corner
         *  const locationRelative = { x: 10, y: 20 }
         *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
         * ```
         *
         * Client coordinates can be used to absolute position HTML elements using CSS, for example.
         *
         * ```ts
         *  myHTMLElement.style.position = 'absolute'
         *  myHTMLElement.style.left = locationClient.clientX
         *  myHTMLElement.style.top = locationClient.clientY
         * ```
         *
         * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
         * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
         *
         * ```ts
         *  LineSeries.add(myData)
         *  requestAnimationFrame(() => {
         *      // translateCoordinate should now consider data added just now.
         *  })
         * ```
         *
         * @public
         */
        translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
        /**
         * Add a stand-alone *UIElement* using a *builder*.
         *
         * **Example usage:**
         *
         * 1) TextBox with default positioning coordinate system.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox )
         *      // Position = [0, 100] as percentages.
         *      .setPosition({ x: 50, y: 50 })
         * ```
         *
         * 2) Position in pixel coordinate system.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox, chart.coordsRelative )
         *      // Position = pixels.
         *      .setPosition({ x: 300, y: 100 })
         * ```
         *
         * 3) Position on Axes.
         *
         * ```typescript
         *  addUIElement( UIElementBuilders.TextBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
         *      // Position = Axis values.
         *      .setPosition({ x: 5, y: 5 })
         * ```
         *
         * @typeParam UIElementType - Type of *UIElement* that is specified by 'builder'-*parameter*.
         *
         * @param builder - *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use {@link UIElementBuilders} for selection.
         * @param scale - Optional parameter for altering the coordinate system used for positioning the UIElement. Defaults to whole Dashboard in percentages [0, 100].
         * @returns Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
         * @public
         */
        addUIElement<UiElementType extends UIPart = UITextBox>(uiElementBuilder?: UIElementBuilder<UiElementType>, scale?: UserScaleDefinition): UiElementType & UIElement;
        /**
         * Add a *legendbox*.
         *
         * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
         * with user interactions, as well as positioned in application code.
         *
         * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
         * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
         *
         * **Legendbox alignment:**
         *
         * Alignment of legendbox can be selected by supplying one of the available {@link LegendBoxBuilders} to `addLegendBox`:
         *
         * ```typescript
         *  // Default (vertical) LegendBox.
         *  const legendBox = ChartXY.addLegendBox()
         *
         *  // Horizontal LegendBox.
         *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
         * ```
         *
         * **Custom Legendbox positioning:**
         *
         * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
         *
         * A custom location can be configured with {@link UIElement} API:
         * - {@link UIElement.setPosition}
         * - {@link UIElement.setOrigin}
         * - {@link UIElement.setMargin}
         *
         * *Position coordinate system* is specified when creating *legendbox*.
         *
         * 1) LegendBox with default positioning coordinate system.
         *
         * ```typescript
         *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
         *      // Position = [0, 100] as percentages.
         *      .setPosition({ x: 50, y: 50 })
         * ```
         *
         * 2) Position in pixel coordinate system.
         *
         * ```typescript
         *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.coordsRelative )
         *      // Position = pixels.
         *      .setPosition({ x: 300, y: 100 })
         * ```
         *
         * 3) Position on Axes.
         *
         * ```typescript
         *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
         *      // Position = Axis values.
         *      .setPosition({ x: 5, y: 5 })
         * ```
         *
         * Inside Dashboard, a {@link UILegendBoxPanel} can also be used for simplified creation of *legendboxes* for several charts.
         *
         * @param builder - *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use {@link LegendBoxBuilders} for selection.
         * @param scale - Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in percentages [0, 100].
         * @returns LegendBox
         * @public
         */
        addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox;
        /**
         * Add new ChartXY to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a chartXY.
         * @returns ChartXY.
         * @public
         */
        createChartXY: <CursorResultTableBackgroundType extends UIBackground>(options: ChartOptions<CursorResultTableBackgroundType>) => ChartXY<CursorResultTableBackgroundType>;
        /**
         * Add new SpiderChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a Spider chart.
         * @returns SpiderChart.
         * @public
         */
        createSpiderChart: <CursorResultTableBackgroundType extends UIBackground>(options: SpiderOptions<CursorResultTableBackgroundType>) => SpiderChart<CursorResultTableBackgroundType>;
        /**
         * Add new PolarChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a PolarChart chart.
         * @returns PolarChart.
         * @public
         */
        createPolarChart: <CursorResultTableBackgroundType extends UIBackground>(options: PolarOptions<CursorResultTableBackgroundType>) => PolarChart<CursorResultTableBackgroundType>;
        /**
         * Add new PieChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a PieChart.
         * @returns PieChart.
         * @public
         */
        createPieChart: <PieChartType extends PieChartTypes = typeof PieChartWithLabelsOnSides>(options: PieOptions<PieChartType>) => InstanceType<PieChartType>;
        /**
         * Add new FunnelChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a FunnelChart.
         * @returns FunnelChart.
         * @public
         */
        createFunnelChart: <FunnelChartType extends FunnelChartTypes = typeof FunnelChartWithLabelsOnSides>(options: FunnelOptions<FunnelChartType>) => InstanceType<FunnelChartType>;
        /**
         * Add new PyramidChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboard's numberOfColumns/Rows.
         * @param options - Options object for creating a PyramidChart.
         * @returns PyramidChart
         * @public
         */
        createPyramidChart: <PyramidChartType extends PyramidChartTypes = typeof PyramidChartWithLabelsOnSides>(options: PyramidOptions<PyramidChartType>) => InstanceType<PyramidChartType>;
        /**
         * Create a container for UI objects on dashboard with specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a UIPanel.
         * @returns Panel.
         * @public
         */
        createUIPanel: (options: DashboardCellOptions) => UIPanel;
        /**
         * Create a new *legend box panel*, a convenience component for placing *legend box items*
         * from multiple different *charts* into a single *row layout*, to dashboard at specified location and span.
         *
         *
         * Refer to {@link UILegendBoxPanel} for more information, like *example usage*.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a *legend box panel*.
         * @returns UILegendBoxPanel.
         * @public
         */
        createLegendBoxPanel: (options: DashboardCellOptions) => UILegendBoxPanel;
        /**
         * Add new GaugeChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a GaugeChart.
         * @returns GaugeChart.
         * @public
         */
        createGaugeChart: <GaugeChartType extends GaugeChartTypes = typeof SolidGauge>(options?: GaugeOptions<GaugeChartType>) => InstanceType<GaugeChartType>;
        /**
         * Add new ZoomBandChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a ZoomBandChart.
         * @returns ZoomBandChart.
         * @public
         */
        createZoomBandChart: (options: ZoomBandChartDashboardOptions) => ZoomBandChart;
        /**
         * Factory for `MapChart`. This chart visualizes a Map of the selected part of the world. Defaults to the entire world.
         * It has built-in *cursor* functionality and supports dynamic region coloring.
         *
         * To learn more about its features, refer to {@link MapChart}.
         *
         * **Dashboard cell configuration:**
         *
         * When inside a `Dashboard`, the chart location relative to the `Dashboard` **must be supplied when it is created**.
         *
         * ```typescript
         *  // Example, dashboard cell configuration.
         *  const chart = Dashboard.createMapChart({
         *      // X location, 0 = left.
         *      columnIndex: 0,
         *      // Y location, 0 = top.
         *      rowIndex: 0,
         *      // Amount of X cells allocated for this chart.
         *      columnSpan: 1,
         *      // Amount of Y cells allocated for this chart.
         *      rowSpan: 1,
         *  })
         * ```
         *
         * **Readonly configuration:**
         *
         * Some properties of `MapChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, specify map type.
         *  const chart = LightningChart.Map({
         *      type: MapTypes.Europe
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `MapChart` specific properties, refer to {@link MapChartOptions}.
         *
         * @param options - Object with readonly configuration arguments for `MapChart`.
         * @returns Created chart.
         * @public
         */
        createMapChart: <SelectedMapType extends MapType, CursorResultTableBackgroundType extends UIBackground>(options: MapChartDashboardOptions<SelectedMapType, CursorResultTableBackgroundType>) => MapChart<SelectedMapType, CursorResultTableBackgroundType>;
        /**
         * Add new Chart3D to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a Chart3D.
         * @returns Chart3D.
         * @public
         */
        createChart3D: (options: Chart3DDashboardOptions) => Chart3D;
        /**
         * Add new DataGrid to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a DataGrid.
         * @returns             DataGrid.
         * @public
         */
        createDataGrid: (options: DataGridDashboardOptions) => DataGrid;
        /**
         * Add new BarChart to dashboard at specified location and span.
         *
         * Throws an error if either column/row index is less than 0 or index + span is more than Dashboards numberOfColumns/Rows.
         * @param options - Options object for creating a BarChart.
         * @returns             BarChart.
         * @public
         */
        createBarChart: (options: BarChartDashboardOptions) => BarChart;
    }
    /**
     * Data structure that describes one cell in a Dashboard.
     *
     * Use `panel` property to get reference to the actual chart or other component that resides in the cell.
     * @public
     */
    export declare interface DashboardCell {
        readonly columnIndex: number;
        readonly rowIndex: number;
        readonly columnSpan: number;
        readonly rowSpan: number;
        readonly panel: DashboardPanel;
    }
    /**
     * Interface for minimum set of parameters required for adding charts / panels to a *dashboard cell*.
     *
     *  Example usage:
     *```javascript
     * // 1x1 component at top left cell
     * { columnIndex: 0, rowIndex: 0, columnSpan: 1, rowSpan: 1 }
     * // 4x1 component at top row
     * { columnIndex: 0, rowIndex: 0, columnSpan: 4, rowSpan: 1 }
     * ```
     * @public
     */
    export declare interface DashboardCellOptions {
        /**
         * Column index on dashboard (X location, 0 = left)
         */
        columnIndex: number;
        /**
         * Row index on dashboard (Y location, 0 = top)
         */
        rowIndex: number;
        /**
         * Column span (X width), default = 1
         */
        columnSpan?: number;
        /**
         * Row span (Y height), default = 1
         */
        rowSpan?: number;
        /**
         * Convenience flag that can be used to enable/disable all animations in a component.
         */
        animationsEnabled?: boolean;
        /**
         * Convenience flag that can be used to disable all animations in a component.
         * @deprecated  Deprecated in v5.0.0. Use `animationsEnabled` instead (note that **value should be inverted from previous applications!**)
         */
        disableAnimations?: boolean;
    }
    /**
     * Interface for readonly configuration of {@link Dashboard}.
     *
     * **Mandatory properties:**
     *
     * - [numberOfColumns]({@link DashboardOptions.numberOfColumns}): Number of *dashboard cells* along horizontal plane.
     * - [numberOfRows]({@link DashboardOptions.numberOfRows}): Number of *dashboard cells* along vertical plane.
     *
     * ```typescript
     *  // Example, Create a 3x3 dashboard.
     *  const dashboard = LightningChart.Dashboard({
     *      // Number of cells in X direction.
     *      numberOfColumns: 3,
     *      // Number of cells in Y direction.
     *      numberOfRows: 3,
     *  })
     * ```
     *
     * To learn about the effects of *columns* / *rows* configuration, please read more here {@link Dashboard}.
     *
     *
     * **Optional extra configuration:**
     *
     * - {@link DashboardOptions.theme}: Specify dashboard color *theme*.
     * - {@link DashboardOptions.disableAnimations}: Convenience flag to disable all animations from dashboard.
     *
     * ```typescript
     *  // Example 1, create dashboard with specified color theme.
     *  const dashboard = LightningChart.Dashboard({
     *      // Number of cells in X direction.
     *      numberOfColumns: 3,
     *      // Number of cells in Y direction.
     *      numberOfRows: 3,
     *      // Select color theme.
     *      theme: Themes.light,
     *  })
     * ```
     * @public
     */
    export declare interface DashboardOptions {
        /**
         * Number of *dashboard cells* along horizontal plane.
         *
         * To learn about the effects of *columns* / *rows* configuration, please read more here {@link Dashboard}.
         */
        readonly numberOfColumns: number;
        /**
         * Number of *dashboard cells* along vertical plane.
         *
         * To learn about the effects of *columns* / *rows* configuration, please read more here {@link Dashboard}.
         */
        readonly numberOfRows: number;
        /**
         * Convenience flag that can be used to enable/disable all animations in a component.
         */
        readonly animationsEnabled?: boolean;
        /**
         * Convenience flag that can be used to disable all animations in a component.
         * @deprecated  Deprecated in v5.0.0. Use `animationsEnabled` instead (note that **value should be inverted from previous applications!**)
         */
        readonly disableAnimations?: boolean;
        /**
         * Theme used to style all elements inside the component.
         * See {@link Themes} for pre-made options.
         */
        readonly theme?: Theme;
    }
    /**
     * A chart or other component that can exist inside a Dashboard cell.
     *
     * Use `instanceof` checks to confirm whether it is of an expected type.
     *
     * ```ts
     *  // Example usage
     *  if (panel instanceof ChartXY) {
     *      // ...
     *  }
     * ```
     * @public
     */
    export declare interface DashboardPanel {
        /**
         * Get minimum size of Panel.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns Point minimum size or undefined if unimplemented
         * @public
         */
        getMinimumSize(): Point | undefined;
        /** @public */
        dispose(): unknown;
    }
    /**
     * Style class for describing a line that is partly hidden and partly visible. The pattern is repetitive and can be configured.
     *
     * Instances of DashedLine, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of DashedLine:**
     * - `thickness`    : thickness of line as pixels.
     * - `fillStyle`    : description of line fill color. The supported fillStyles vary per component.
     * - `pattern`      : description of the repeating pattern of ON and OFF sections that defines the `DashedLine`.
     * - `patternScale` : scaling factor for the length of each repeating stipple pattern.
     *
     * **DashedLine Usage:**
     *
     * Use DashedLine with:
     * - `setStrokeStyle` methods:
     *      * {@link ConstantLine.setStrokeStyle}
     *      * {@link CustomTick.setGridStrokeStyle}
     *      * {@link LineSeries.setStrokeStyle}
     *      * etc.
     *
     * *Watch out!* A common misuse is to attempt styling strokes or borders directly using *fill style* or *color*.
     * Remember, when calling a `setStrokeStyle` method, a *line style* is expected! Carefully observe the order of wrapped styles: *line style \<- fill style \<- color*
     *
     * ```typescript
     *  // Example, set line series stroke style to 1px dashed red.
     *  LineSeries.setStrokeStyle(new DashedLine({
     *      thickness: 1,
     *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }),
     *      patternScale: StipplePatterns.DashedEqual,
     *      patternScale: 1,
     *  }))
     * ```
     *
     * ```ts
     *  // Example, change stroke style to DashedLine without changing color / thickness
     *  LineSeries.setStrokeStyle((stroke) => new DashedLine({
     *      thickness: stroke.getThickness(),
     *      fillStyle: stroke.getFillStyle(),
     *      pattern: StipplePatterns.Dashed,
     *      patternScale: 2,
     *  }))
     * ```
     *
     * **Related information:**
     *
     * For more *line styles*, see:
     * - {@link SolidLine}
     * - {@link emptyLine}
     *
     * @public
     */
    export declare class DashedLine extends DashedLineRecord implements LineStyle, StylePropFuncs<ThisType<DashedLine>, Omit<DashedLineProperties, 'type' | 'lineType'>> {
        /**
         * Construct a DashedLine object, specifying any amount of its properties.
         *
         * ```typescript
         *  // Example, 1px thick dashed red line.
         *  const solidRed = new DashedLine({
         *      thickness: 1,
         *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }),
         *      pattern: StipplePatterns.Dashed,
         *  })
         *
         *  Axis.setStrokeStyle(solidRed)
         * ```
         * @param   props - Object containing any amount of DashedLine properties.
         * @public
         */
        constructor(props?: Partial<Omit<DashedLineProperties, 'type' | 'lineType'>>);
        /**
         * Construct a new line style object based on this one, but with modified fill style.
         *
         * Example (SolidFill):
         * ```javascript
         * // specify new fillstyle
         * lineStyle.setFillStyle( new SolidFill({
         *  color: ColorHex('#F00')
         * }) )
         * // change fillstyle properties
         * lineStyle.setFillStyle(
         *  solidfill => solidfill.setA( 80 )
         * )
         * ```
         * @param   value -  Either a DashedLine object or a function, which will be used to create a new DashedLine based on current value.
         * @returns          New SolidLine object
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): DashedLine;
        /**
         * Get fill style of SolidLine.
         * @returns  FillStyle object
         * @public
         */
        getFillStyle(): FillStyle;
        /**
         * Construct a new DashedLine object based on this one, but with modified thickness.
         *
         * -1 can be used to signify smallest available thickness.
         * With most features, this will result in slightly better GPU performance, but less detailed line.
         *
         * @param   value -  Thickness as pixels.
         * @public
         */
        setThickness(value: number | ImmutableMutator<number>): this;
        /**
         * Get thickness of DashedLine
         * @returns  Thickness as pixels
         * @public
         */
        getThickness(): number;
        /**
         * Construct a new DashedLine object based on this one, but with modified stipple pattern.
         *
         * Use `StipplePatterns` to conveniently select from preset options.
         *
         * ```ts
         *  // Example usage
         *  const modifiedDashedLine = DashedLine.setPattern(StipplePatterns.Dashed)
         * ```
         * @param   value    -     Stipple pattern.
         * @returns                 New DashedLine object.
         * @public
         */
        setPattern(value: StipplePattern | ImmutableMutator<StipplePattern>): this;
        /**
         * Get stipple pattern of the DashedLine object.
         * @returns          -        Stipple pattern.
         * @public
         */
        getPattern(): StipplePattern;
        /**
         * Construct a new DashedLine object based on this one, but with modified stipple pattern scale.
         *
         * Scaling factor for the length of each repeating stipple pattern. By default `5`.
         * @param   value   -    Scaling factor.
         * @returns              New DashedLine object.
         * @public
         */
        setPatternScale(value: number | ImmutableMutator<number>): this;
        /**
         * Get stipple pattern scale of the DashedLine object.
         * @returns                  Stipple pattern scale.
         * @public
         */
        getPatternScale(): number;
    }
    /**
     * Interface for all properties of a DashedLine.
     * @public
     */
    export declare interface DashedLineProperties extends SolidLineStyleProperties {
        /**
         * _Stipple pattern_ that describes the repeating pattern of ON and OFF sections that defines the `DashedLine`.
         *
         * See {@link StipplePattern} for more information.
         *
         * Defaults to `StipplePatterns.DashedEqual`
         */
        pattern: StipplePattern;
        /**
         * Scaling factor for the length of each repeating stipple pattern.
         *
         * Defaults to `3`
         */
        patternScale: number;
    }
    /**
     * @public
     */
    declare const DashedLineRecord: Record_2.Factory<DashedLineProperties>;
    /**
     * Component for visualizing data inside a grid structure using a variety of methods.
     *
     * `DataGrid` can be created in two different ways - to learn more about creation time configuration of `DataGrid`, please refer to:
     * - {@link LightningChart.DataGrid} (stand-alone data grid).
     * - {@link Dashboard.createDataGrid} (data grid inside *dashboard*).
     *
     * `DataGrid` is built from any number of _Cells_, that are positioned across _Columns_, and _Rows_.
     * The number of cells is fully dynamic, and can be changed at any time.
     * Furthermore, cells can be merged to span over more than 1 column and/or row.
     *
     * Examples featuring some use cases of `DataGrid` can be found on the official {@link https://www.lightningchart.com/lightningchart-js-interactive-examples/search.html?t=valuegrid | LightningChart JS Interactive Examples gallery}.
     *
     * **DataGrid features**
     *
     * ## Cell content
     *
     * As mentioned, `DataGrid` is fully dynamic, as in cells can be created and removed at any time.
     * Cells are defined by specifying their {@link DataGridCellContent | _Content_}.
     *
     * Each cell can contain _text_, _numbers_, an _Icon_ or a _Spark Chart_.
     * To learn of _Spark Charts_, see their section below.
     *
     * There are several different methods for specifying cell content, here's a conclusive list:
     *
     * - {@link DataGrid.setCellContent} Set content of 1 cell. This method also allows definition of merged cells.
     * - {@link DataGrid.setColumnContent} Set contents of n cells along a single column.
     * - {@link DataGrid.setRowContent} Set contents of n cells along a single row.
     * - {@link DataGrid.setTableContent} Set contents of many cells by supplying a matrix.
     *
     * Cells can be emptied by setting their content to `undefined`, or completely removed with following methods:
     *
     * - {@link DataGrid.removeCell} Remove 1 cell.
     * - {@link DataGrid.removeColumn} Remove all cells along a single column.
     * - {@link DataGrid.removeRow} Remove all cells along a single row.
     * - {@link DataGrid.removeCells} Remove all cells.
     *
     * ## Cell style
     *
     * Each cell in a `DataGrid` can be styled individually.
     * Each cell has following style properties:
     *
     * - Padding
     * - Borders Visibility
     * - Text FillStyle
     * - Text Font
     * - Content Alignment
     * - Background FillStyle
     * - Highlighting
     *
     * Here are methods for setting the style of existing cells (cells whose content has been defined according to section #1):
     *
     * - {@link DataGrid.setCellPadding} Set padding of 1 cell.
     * - {@link DataGrid.setColumnPaddings} Set padding of all cells along a single column.
     * - {@link DataGrid.setRowPaddings} Set padding of all cells along a single row.
     * - {@link DataGrid.setCellBorders} Set border visibility of 1 cell.
     * - {@link DataGrid.setColumnBorders} Set border visibility of all cells along a single column.
     * - {@link DataGrid.setRowBorders} Set border visibility of all cells along a single row.
     * - {@link DataGrid.setCellTextFillStyle} Set text fill style of 1 cell.
     * - {@link DataGrid.setColumnTextFillStyle} Set text fill style of all cells along a single column.
     * - {@link DataGrid.setRowTextFillStyle} Set text fill style of all cells along a single row.
     * - {@link DataGrid.setCellTextFont} Set text font of 1 cell.
     * - {@link DataGrid.setColumnTextFont} Set text font of all cells along a single column.
     * - {@link DataGrid.setRowTextFont} Set text font of all cells along a single row.
     * - {@link DataGrid.setCellContentAlignment} Set content alignment of 1 cell.
     * - {@link DataGrid.setColumnContentAlignment} Set content alignment of all cells along a single column.
     * - {@link DataGrid.setRowContentAlignment} Set content alignment of all cells along a single row.
     * - {@link DataGrid.setCellBackgroundFillStyle} Set background fill style of 1 cell.
     * - {@link DataGrid.setColumnBackgroundFillStyle} Set background fill style of all cells along a single column.
     * - {@link DataGrid.setRowBackgroundFillStyle} Set background fill style of all cells along a single row.
     * - {@link DataGrid.setCellHighlight} Set highlighting of 1 cell.
     * - {@link DataGrid.setColumnHighlight} Set highlighting of all cells along a single column
     * - {@link DataGrid.setRowHighlight} Set highlighting of all cells along a single row
     *
     * The default style for new cells can be defined separately.
     * These methods both alter the styles of all existing cells, as well as any cells defined afterwards.
     *
     * - {@link DataGrid.setCellsPaddings} Set padding of all existing and future cells.
     * - {@link DataGrid.setCellsBorders} Set border visibility of all existing and future cells.
     * - {@link DataGrid.setCellsTextFillStyle} Set text fill style of all existing and future cells.
     * - {@link DataGrid.setCellsTextFont} Set text font of all existing and future cells.
     * - {@link DataGrid.setCellsAlignment} Set content alignment of all existing and future cells.
     * - {@link DataGrid.setCellsBackgroundFillStyle} Set background fill style of all existing and future cells.
     *
     * Apart from cell-specific styles, there are also more style setters on `DataGrid`, see next section.
     *
     * ## Data Grid style
     *
     * - {@link DataGrid.setGridBackgroundFillStyle} Set fill style of area behind all Data Grid cells.
     * - {@link DataGrid.setCellsBorderStrokeStyle} Set all cells border style. This is not configurable individually per-cell.
     *
     * ## Data Grid sizing
     *
     * By default, the Data Grid size is based on the size of its Cells (fit to content).
     * This can be altered by size instructions on any column, and/or row.
     *
     * - {@link DataGrid.setColumnWidth} Set width of 1 column as pixels.
     * - {@link DataGrid.setRowHeight} Set height of 1 row as pixels.
     *
     * Both of these methods accept several types of instructions:
     *
     * - Hard defined size as pixels `DataGrid.setColumnWidth(0, 200)`
     * - Min size as pixels `DataGrid.setColumnWidth(0, { min: 100 })`
     * - Max size as pixels `DataGrid.setColumnWidth(0, { max: 300 })`
     * - Min/Max range as pixels `DataGrid.setColumnWidth(0, { min: 100, max: 300 })`
     * - Restore default behavior (fit to content) `DataGrid.setColumnWidth(undefined)`
     *
     * ## Spark charts
     *
     * `DataGrid` supports placing miniature charts (Spark Chart) inside any number of cells.
     * These can be used to "show data at a glance".
     *
     * To place a Spark Chart, specify the content of a Cell like normal, but instead of supplying string or number, supply an object description of the Spark Chart:
     *
     * ```ts
     *  // Example, spark line chart
     *  DataGrid.setCellContent(0, 0, {
     *      type: 'spark-line',
     *      data: [0, 10, 6, 4, 9, 8, 3, 6]
     *  })
     * ```
     *
     * To learn of available types of Spark Charts as well as all optional configuration properties, see {@link SparkChart}.
     *
     * To update the data of a Spark Chart, simply redefine the cell content.
     *
     * ## User interactions
     *
     * `DataGrid` allows subscribing to user interaction events like most LightningChart JS components.
     *
     * Important note, for cell mouse interactions to work, their background must have a non empty fill style.
     * This is true by default. To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
     *
     * Use the following methods to attach event handlers to events:
     *
     * - {@link DataGrid.onCellMouseEnter} Event fired when mouse enters any cell in DataGrid (triggered again if different cell is under pointer)
     * - {@link DataGrid.onCellMouseLeave} Event fired when mouse leaves any cell in DataGrid (triggered again if different cell is under pointer)
     * - {@link DataGrid.onCellMouseClick} Event fired when mouse clicks any cell in DataGrid
     * - {@link DataGrid.onCellMouseDoubleClick} Event fired when mouse double clicks enters any cell in DataGrid
     * - {@link DataGrid.onCellMouseDown} Event fired when mouse presses down on any cell in DataGrid
     * - {@link DataGrid.onCellMouseUp} Event fired when mouse releases up on any cell in DataGrid
     * - {@link DataGrid.onCellMouseMove} Event fired when mouse moves above any cell in DataGrid
     * - {@link DataGrid.onCellMouseDrag} Event fired when mouse is dragged while holding a button above any cell in DataGrid
     * - {@link DataGrid.onCellMouseDragStart} Event fired when mouse drag is started on any cell in DataGrid
     * - {@link DataGrid.onCellMouseDragStop} Event fired when mouse drag stops on any cell in DataGrid
     * - {@link DataGrid.onCellMouseWheel} Event fired when mouse is wheeled above any cell in DataGrid
     * - {@link DataGrid.onCellTouchStart} Event fired when touch start event fires above any cell in DataGrid
     * - {@link DataGrid.onCellTouchMove} Event fired when touch move event fires above any cell in DataGrid
     * - {@link DataGrid.onCellTouchEnd} Event fired when touch end event fires above any cell in DataGrid
     *
     * To stop listening to an event, use the respective `off...` method, for example {@link DataGrid.offCellMouseEnter}.
     *
     * @public
     */
    export declare class DataGrid extends Chart {
        /**
         * Get minimum size of Chart.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns  Vec2 minimum size or undefined if unimplemented
         */
        getMinimumSize(): Point | undefined;
        /**
         * Disable/Enable all animations of the Chart.
         *
         * NOTE: Data grid doesn't currently have any built in animations, so this method does not do anything.
         *
         * @returns                  Chart itself for fluent interface.
         * @public
         */
        setAnimationsEnabled(_: boolean | undefined): this;
        /**
         * **Permanently** dispose the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setBackgroundEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getBackgroundEffect(): boolean;
        /**
         * Enable/disable default Data Grid interaction of scrolling up/down on mouse wheel.
         *
         * ```ts
         *  // Example, disable default interaction.
         *  DataGrid.setInteractionScrollOnWheel(false)
         * ```
         * @param   enabled     - Interaction enabled?
         * @returns             Object itself.
         * @public
         */
        setInteractionScrollOnWheel(enabled: boolean): this;
        /**
         * Check whether default Data Grid interaction of scrolling up/down on mouse wheel is enabled or not.
         *
         * @returns             Interaction enabled?
         * @public
         */
        getInteractionScrollOnWheel(): boolean;
        /**
         * Enable/disable default Data Grid interaction of panning on touch.
         *
         * ```ts
         *  // Example, disable default interaction.
         *  DataGrid.setInteractionPanOnTouch(false)
         * ```
         * @param   enabled     - Interaction enabled?
         * @returns             Object itself.
         * @public
         */
        setInteractionPanOnTouch(enabled: boolean): this;
        /**
         * Check whether default Data Grid interaction of panning on touch is enabled or not.
         *
         * @returns             Interaction enabled?
         * @public
         */
        getInteractionPanOnTouch(): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is entered with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseEnter((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseEnter(clbk: MouseEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is entered with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseEnter(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is left with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseLeave((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseLeave(clbk: MouseEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is left with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseLeave(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is clicked with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseClick((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseClick(clbk: MouseEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is clicked with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseClick(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is double clicked with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseDoubleClick((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseDoubleClick(clbk: MouseEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is double clicked with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseDoubleClick(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is pressed with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseDown((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseDown(clbk: MouseEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is pressed with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseDown(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is unpressed with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseUp((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseUp(clbk: MouseEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is unpressed with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseUp(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is moved over with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseMove((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseMove(clbk: MouseEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is moved over with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseMove(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is dragged with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseDrag((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseDrag(clbk: MouseDragStartEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is dragged with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseDrag(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is dragged for first time with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseDragStart((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseDragStart(clbk: MouseDragEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is dragged for first time with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseDragStart(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid dragging stops with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseDragStop((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseDragStop(clbk: MouseDragStopEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid dragging stops with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseDragStop(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is wheeled with mouse.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellMouseWheel((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellMouseWheel(clbk: MouseWheelEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is wheeled with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellMouseWheel(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is touched for first time.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellTouchStart((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellTouchStart(clbk: TouchEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is touched for first time.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellTouchStart(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is touched while moving.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellTouchMove((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellTouchMove(clbk: TouchEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is clicked with mouse.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellTouchMove(token: Token): boolean;
        /**
         * Subscribe to event when a cell in the Data Grid is no longer touched.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.onCellTouchEnd((cell, event) => {
         *      // Event happened. `cell` object describes which cell was interacted with.
         *      console.log(cell, event)
         *  })
         * ```
         *
         * NOTE: Cell mouse events are picked from cell backgrounds.
         * If the cell background fill is hidden by setting it to `emptyFill`, the mouse events are not caught.
         * To attach mouse interactions to a cell without visible background fill, use {@link transparentFill}.
         *
         * @param clbk - Callback function that is triggered upon event.
         * @returns          Token which can be used to unsubscribe from the event.
         * @public
         */
        onCellTouchEnd(clbk: TouchEventHandler<DataGridCell>): Token;
        /**
         * Unsubscribe from event when a cell in the Data Grid is no longer touched.
         *
         * ```ts
         *  // Example usage
         *  const token = DataGrid.onCellMouseEnter(() => {
         *      // Do stuff ...
         *  })
         *
         *  DataGrid.offCellMouseEnter(token)
         * ```
         *
         * @param token - Token which was received when event subscription was made.
         * @returns          True if an event handler was actually removed.
         * @public
         */
        offCellTouchEnd(token: Token): boolean;
        /**
         * Set fill style of the area behind all cells.
         * @param value - Fill style object or function which modifies it.
         * @returns         Object itself for fluent interface.
         * @public
         */
        setGridBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Gets the fill style of the area behind all cells.
         *
         * @returns Current fill style object
         * @public
         */
        getGridBackgroundFillStyle(): FillStyle;
        /**
         * Set content of a single cell at intersection of supplied column and row.
         *
         * This creates a new cell if it doesn't exist, and overrides any previously set content in the cell.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setCellContent(0, 0, 'First Name')
         *      .setCellContent(0, 1, 'John')
         * ```
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param content - Data grid cell content.
         * @public
         * {@label SINGLE_CELL}
         */
        setCellContent(column: number, row: number, content: DataGridCellContent): this;
        /**
         * Merge several cells together and set their content.
         * Any rectangular set of cells can be merged together, which results in the following effects:
         *  - Merged cells have shared content, style, borders and background.
         *      - Altering any of the cells will affect the merged cells as one unit.
         *      - Altering the content of any of the merged cells will undo the merge.
         *  - Merged cells width is equal to the sum of all its columns widths, and vice versa for height.
         *
         * This creates new cells where don't exist, and overrides any previously set content in the cell.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setCellContent(0, 0, 2, 2, 'Big header')
         *      .setCellContent(2, 0, 'Small header 1')
         *      .setCellContent(2, 1, 'Small header 2')
         * ```
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param columnSpan - Number of columns to fuse together.
         * @param rowSpan - Number of rows to fuse together.
         * @param content - Data grid cell content.
         * @returns              Object itself
         * @public
         * {@label MERGED_CELL}
         */
        setCellContent(column: number, row: number, columnSpan: number, rowSpan: number, content: DataGridCellContent): this;
        /**
         * Set contents of cells along a supplied column.
         *
         * This creates new cells where they don't exist, and overrides any previously set content over modified cells.
         *
         * Number of cells is supplied as an Array. If there are more cells that extend further than the supplied Array, they are untouched.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setColumnContent(0, ['First Name', 'Last Name'])
         *      .setColumnContent(1, ['John', 'Smith'])
         * ```
         *
         * @param column - Column index starting from 0.
         * @param content - Array of data grid cell content.
         * @returns              Object itself.
         * @public
         */
        setColumnContent(column: number, content: DataGridCellContent[]): this;
        /**
         * Set contents of cells along a supplied row.
         *
         * This creates new cells where they don't exist, and overrides any previously set content over modified cells.
         *
         * Number of cells is supplied as an Array. If there are more cells that extend further than the supplied Array, they are untouched.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setRowContent(0, ['First Name', 'Last Name'])
         *      .setRowContent(1, ['John', 'Smith'])
         * ```
         *
         * @param row - Row index starting from 0.
         * @param content - Array of data grid cell content.
         * @returns              Object itself.
         * @public
         */
        setRowContent(row: number, content: DataGridCellContent[]): this;
        /**
         * Set contents of a table of cells originating from column 0 and row 0.
         *
         * This creates new cells where they don't exist, and overrides any previously set content over the table area.
         *
         * This does not remove any cell content outside the table area.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setTableContent([
         *      ['First Name', 'Second Name'],
         *      ['John', 'Smith']
         *  ])
         * ```
         * @param content - 2D Array of data grid cell content.
         * @returns              Object itself.
         * @public
         */
        setTableContent(content: DataGridCellContent[][]): this;
        /**
         * Method sets width of a single column in Data Grid.
         *
         * Column width can be specified in several ways; width as pixels, fit to content, minimum width as pixels or maximum width as pixels.
         *
         * ```ts
         *  // Example usage, set first column width to exactly 200 pixels
         *  DataGrid.setColumnWidth(0, 200)
         * ```
         *
         * ```ts
         *  // Example usage, set first column max width to 200 pixels
         *  DataGrid.setColumnWidth(0, { max: 200 })
         * ```
         *
         * @param column - Index of column in Data Grid.
         * @param width - Width of column.
         * @returns         Object itself.
         * @public
         */
        setColumnWidth(column: number, width: number | undefined | {
            min?: number;
            max?: number;
        }): this;
        /**
         * Method sets width of a single row in Data Grid.
         *
         * Row width can be specified in several ways; height as pixels, fit to content, minimum height as pixels or maximum height as pixels.
         *
         * ```ts
         *  // Example usage, set first row height to exactly 200 pixels
         *  DataGrid.setRowHeight(0, 200)
         * ```
         *
         * ```ts
         *  // Example usage, set first row max height to 200 pixels
         *  DataGrid.setRowHeight(0, { max: 200 })
         * ```
         *
         * @param row - Index of row in Data Grid.
         * @param height - Height of row.
         * @returns         Object itself.
         * @public
         */
        setRowHeight(row: number, height: number | undefined | {
            min?: number;
            max?: number;
        }): this;
        /**
         * Set padding of all cells along a specified column.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setColumnPaddings(0, 5) // Sets all paddings to 5.
         *      .setColumnPaddings(0, { top: 2, bottom: 10, left: 5, right: 5 }) // Sets specific paddings.
         * ```
         *
         * @param column - Column index starting from 0.
         * @param padding - Either number as shorthand or @see Padding for padding along configurable directions.
         * @returns              Object itself.
         * @public
         */
        setColumnPaddings(column: number, padding: Partial<Padding> | number): this;
        /**
         * Set padding of all cells along a specified row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setRowPaddings(0, 5) // Sets all paddings to 5.
         *      .setRowPaddings(0, { top: 2, bottom: 10, left: 5, right: 5 }) // Sets specific paddings.
         * ```
         *
         * @param row - Row index starting from 0.
         * @param padding - Either number as shorthand or @see Padding for padding along configurable directions.
         * @returns              Object itself.
         * @public
         */
        setRowPaddings(row: number, padding: Partial<Padding> | number): this;
        /**
         * Set padding of a cell at the intersection of the specified row and column.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setCellPadding(0, 5, 5) // Sets all paddings to 5.
         *      .setCellPadding(0, 10, { top: 2, bottom: 10, left: 5, right: 5 }) // Sets specific paddings.
         * ```
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param padding - Either number as shorthand or @see Padding for padding along configurable directions.
         * @returns              Object itself.
         * @public
         */
        setCellPadding(column: number, row: number, padding: Partial<Padding> | number): this;
        /**
         * Sets the default padding for all cells.
         *
         * ```ts
         *  // Example usage
         *  DataGrid
         *      .setCellsPaddings(5) // Sets all paddings to 5.
         *      .setCellsPaddings({ top: 2, bottom: 10, left: 5, right: 5 }) // Sets specific paddings.
         * ```
         *
         * This method also modifies the default cell padding, which is carried over to any cells that are created afterwards.
         *
         * @param padding - Either number as shorthand or @see Padding for padding along configurable directions.
         * @returns              Object itself.
         * @public
         */
        setCellsPaddings(padding: Partial<Padding> | number): this;
        /**
         * Set selection of visible borders of a single cell at intersection of supplied column and row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setCellBorders(0, 0, {top: false, bottom: true, })
         * ```
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param borders - Object describing the selection of which borders to show, OR undefined as a shorthand for no borders (equivalent to `{top: false, bottom: false, right: false, left: false}`).
         * @public
         */
        setCellBorders(column: number, row: number, borders: DataGridCellBorders | undefined): this;
        /**
         * Set selection of visible borders of a row of cells at the supplied row index.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  DataGrid.setRowBorders(0, {top: false, bottom: true, })
         * ```
         *
         * @param row - Row index starting from 0.
         * @param borders - Object describing the selection of which borders to show, OR undefined as a shorthand for no borders (equivalent to `{top: false, bottom: false, right: false, left: false}`).
         * @public
         */
        setRowBorders(row: number, borders: DataGridCellBorders | undefined): this;
        /**
         * Set selection of visible borders of a column of cells at the supplied column index.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * ```ts
         *  DataGrid.setColumnBorders(0, {top: false, bottom: true, })
         * ```
         *
         * @param column - Column index starting from 0.
         * @param borders - Object describing the selection of which borders to show, OR undefined as a shorthand for no borders (equivalent to `{top: false, bottom: false, right: false, left: false}`).
         * @public
         */
        setColumnBorders(column: number, borders: DataGridCellBorders | undefined): this;
        /**
         * Set the default selection of which borders are shown for all cells.
         * This default setting is overridden by any methods that set explicit borders for 1 or several cells.
         *
         * ```ts
         *  DataGrid.setCellsBorders({top: false, bottom: true, })
         * ```
         *
         * This method also modifies the default cell borders, which is carried over to any cells that are created afterwards.
         *
         * @param borders - Object describing the selection of which borders to show, OR undefined as a shorthand for no borders (equivalent to `{top: false, bottom: false, right: false, left: false}`).
         * @public
         */
        setCellsBorders(borders: DataGridCellBorders | undefined): this;
        /**
         * Set the cell border stroke style for all cells.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setCellsBorderStrokeStyle(new SolidLine({thickness: 2}))
         * ```
         *
         * This applies to all existing cells as well as any cells that are created afterwards.
         *
         * @param value - LineStyle or function which modifies the current LineStyle.
         * @returns              Object itself.
         * @public
         */
        setCellsBorderStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Set text fill style of all cells along a specified column.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setColumnTextFillStyle(column: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set text fill style of all cells along a specified row.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param row - Row index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setRowTextFillStyle(row: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set text fill style of a cell at the intersection of the specified row and column.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setCellTextFillStyle(column: number, row: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Sets the default text fill style for all cells.
         *
         * This method also modifies the default cell text fill style, which is carried over to any cells that are created afterwards.
         *
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setCellsTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set text font of all cells along a specified column.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param value - FontSettings or function which modifies the current FontSettings.
         * @returns              Object itself.
         * @public
         */
        setColumnTextFont(column: number, value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Set text font of all cells along a specified row.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param row - Row index starting from 0.
         * @param value - FontSettings or function which modifies the current FontSettings.
         * @returns              Object itself.
         * @public
         */
        setRowTextFont(row: number, value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Set text font of a cell at the intersection of the specified row and column.
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param value - FontSettings or function which modifies the current FontSettings.
         * @returns              Object itself.
         * @public
         */
        setCellTextFont(column: number, row: number, value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Sets the text font style of all cells.
         *
         * This method also modifies the default cell text font, which is carried over to any cells that are created afterwards.
         *
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @returns              Object itself.
         * @public
         */
        setCellsTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Set cell content alignment of all cells along a specified column.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setColumnContentAlignment(0, 'right-center')
         * ```
         *
         * This does not affect any cells that are defined after the method is called.
         * @param column - Column index starting from 0.
         * @param alignment - Cell content alignment options.
         * @returns              Object itself.
         * @public
         */
        setColumnContentAlignment(column: number, alignment: DataGridCellContentAlignment): this;
        /**
         * Set cell content alignment of all cells along a specified row.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setRowContentAlignment(1, 'top-left')
         * ```
         *
         * This does not affect any cells that are defined after the method is called.
         *
         *
         * @param row - Row index starting from 0.
         * @param alignment - Cell content alignment options.
         * @returns              Object itself.
         * @public
         */
        setRowContentAlignment(row: number, alignment: DataGridCellContentAlignment): this;
        /**
         * Set cell content alignment of a cell at the intersection of the specified row and column.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setCellContentAlignment(1, 2, 'top-left')
         * ```
         *
         * This does not affect any cells that are defined after the method is called.
         *
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param alignment - Cell content alignment options.
         * @returns              Object itself.
         * @public
         */
        setCellContentAlignment(column: number, row: number, alignment: DataGridCellContentAlignment): this;
        /**
         * Sets the default content alignment for all cells.
         *
         * This method also modifies the default cell text alignment, which is carried over to any cells that are created afterwards.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.setCellsContentAlignment('top-left')
         * ```
         *
         * @param alignment - Content alignment options.
         * @returns              Object itself.
         * @public
         */
        setCellsContentAlignment(alignment: DataGridCellContentAlignment): this;
        /**
         * Set background fill style of a single cell at intersection of supplied column and row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @public
         */
        setCellBackgroundFillStyle(column: number, row: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set background fill style of cells at the supplied column.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param column - Column index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @public
         */
        setColumnBackgroundFillStyle(column: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set background fill style of cells at the supplied row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param row - Row index starting from 0.
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @public
         */
        setRowBackgroundFillStyle(row: number, value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set background fill style of all cells.
         *
         * This method also modifies the default cell background fill style, which is carried over to any cells that are created afterwards.
         *
         * @param value - FillStyle or function which modifies the current FillStyle.
         * @public
         */
        setCellsBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Set highlight state of a single cell at intersection of supplied column and row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param column - Column index starting from 0.
         * @param row - Row index starting from 0.
         * @param highlight - Highlight state as number between `0` and `1` or `Boolean`.
         * @public
         */
        setCellHighlight(column: number, row: number, highlight: boolean | number): this;
        /**
         * Set highlight state of cells at the supplied column.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param column - Column index starting from 0.
         * @param highlight - Highlight state as number between `0` and `1` or `Boolean`.
         * @public
         */
        setColumnHighlight(column: number, highlight: boolean | number): this;
        /**
         * Set highlight state of cells at the supplied row.
         *
         * This does not affect any cells that are defined after the method is called.
         *
         * @param row - Row index starting from 0.
         * @param highlight - Highlight state as number between `0` and `1` or `Boolean`.
         * @public
         */
        setRowHighlight(row: number, highlight: boolean | number): this;
        /**
         * Remove the cell at the intersection of the specified column and row.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.removeCell(4,0)
         * ```
         *
         * @param column - Column index starting from 0.
         * @param row - Column index starting from 0.
         * @returns              Object itself.
         * @public
         */
        removeCell(column: number, row: number): this;
        /**
         * Remove all cells along a specified row.
         * Removing a row shifts the row indexes of all cells below the removed row.
         * ```ts
         *  // Example usage
         *  DataGrid.removeRow(5)
         * ```
         *
         * @param row - Column index starting from 0.
         * @returns              Object itself.
         * @public
         */
        removeRow(row: number): this;
        /**
         * Remove all cells along a specified column.
         * Removing a column shifts the column indexes of all cells to the right of the removed column.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.removeColumn(0)
         * ```
         *
         * @param column - Column index starting from 0.
         * @returns              Object itself.
         * @public
         */
        removeColumn(column: number): this;
        /**
         * Removes all cells.
         *
         * ```ts
         *  // Example usage
         *  DataGrid.removeCells()
         * ```
         *
         * @returns              Object itself.
         * @public
         */
        removeCells(): this;
        /**
         * Get last column index in Data Grid, taking into account column span.
         *
         * The returned value identifies the last occupied column index.
         *
         * @returns      Last occupied column index in Data Grid.
         * @public
         */
        getColumnMax(): number;
        /**
         * Get last row index in Data Grid, taking into account row span.
         *
         * The returned value identifies the last occupied row index.
         *
         * @returns      Last occupied row index in Data Grid.
         * @public
         */
        getRowMax(): number;
    }
    /**
     * Description of a single cell in a {@link DataGrid}.
     * @public
     */
    export declare interface DataGridCell {
        column: number;
        row: number;
    }
    /**
     * Data structure that describes border visibility of 1 cell in a {@link DataGrid}.
     *
     * Use with methods:
     *
     * - {@link DataGrid.setCellBorders}
     * - {@link DataGrid.setRowBorders}
     * - {@link DataGrid.setColumnBorders}
     * - {@link DataGrid.setCellsBorders}
     *
     * ```ts
     *  // Example, hide top border and show bottom border from cell at column 1 and row 1.
     *  DataGrid.setCellBorders(1, 1, { top: false, bottom: true })
     * ```
     *
     * @public
     */
    export declare type DataGridCellBorders = {
        top?: boolean;
        bottom?: boolean;
        right?: boolean;
        left?: boolean;
    };
    /**
     * Type definition of {@link DataGrid} cell content.
     *
     * `string`:
     *
     * Display supplied string inside cell. Text fill style, font and alignment can be customized.
     * See documentation of {@link DataGrid} for more details.
     *
     * `number`:
     *
     * Display supplied number inside cell. Text fill style, font and alignment can be customized.
     * See documentation of {@link DataGrid} for more details.
     *
     * `SparkChart`:
     *
     * Place a miniature chart (Spark Chart) inside the cell according to the provided description.
     *
     * ```ts
     *  // Example, spark line chart
     *  DataGrid.setCellContent(0, 0, {
     *      type: 'spark-line',
     *      data: [0, 10, 6, 4, 9, 8, 3, 6]
     *  })
     * ```
     *
     * To learn of available types of Spark Charts as well as all optional configuration properties, see {@link SparkChart}.
     *
     * `Icon`:
     *
     * Show an Icon inside the cell. Icon alignment can be customized with the same method as text.
     *
     * ```ts
     *  // Example, place an Icon inside a data grid cell.
     *  DataGrid.setCellContent(0, 0, myIcon)
     * ```
     *
     * To learn how to load Icons, see {@link PublicEngine.addCustomIcon}.
     *
     * `undefined`:
     *
     * Show nothing inside the cell. This retains style information of the cell, in contrast to {@link DataGrid.removeCell | _removing the cell_}.
     *
     * @public
     */
    export declare type DataGridCellContent = string | number | SparkChart | Icon | undefined;
    /**
     * Type definition of different options to aligning content inside a {@link DataGrid} cell.
     *
     * Use with methods:
     *
     * - {@link DataGrid.setCellContentAlignment}
     * - {@link DataGrid.setRowContentAlignment}
     * - {@link DataGrid.setColumnContentAlignment}
     * - {@link DataGrid.setCellsContentAlignment}
     *
     * ```ts
     *  // Example, apply 'right-center' content alignment in all cells that are currently defined on column 0.
     *  DataGrid.setColumnContentAlignment(0, 'right-center')
     * ```
     *
     * To access all run-time options of `DataGridCellContentAlignment`, see {@link DataGridCellContentAlignmentOptions}
     * @public
     */
    export declare type DataGridCellContentAlignment = EnumToStringUnion<DataGridCellContentAlignmentOptions>;
    /**
     * Enum of different options to aligning content inside a {@link DataGrid} cell.
     *
     * Use with methods:
     *
     * - {@link DataGrid.setCellContentAlignment}
     * - {@link DataGrid.setRowContentAlignment}
     * - {@link DataGrid.setColumnContentAlignment}
     * - {@link DataGrid.setCellsContentAlignment}
     *
     * ```ts
     *  // Example, apply 'right-center' content alignment in all cells that are currently defined on column 0.
     *  DataGrid.setColumnContentAlignment(0, 'right-center')
     * ```
     *
     * This is an enum type, which can be iterated during run time, for example when creating a menu selector for content alignment options.
     * Respective type definition is exported as {@link DataGridCellContentAlignment}.
     *
     * @public
     */
    export declare enum DataGridCellContentAlignmentOptions {
        Center = "center",
        RightCenter = "right-center",
        LeftCenter = "left-center",
        RightTop = "right-top",
        LeftTop = "left-top",
        RightBottom = "right-bottom",
        LeftBottom = "left-bottom",
        CenterTop = "center-top",
        CenterBottom = "center-bottom"
    }
    /**
     * Interface that can be used to define {@link DataGrid} configurations, when inside a {@link Dashboard},
     * that can't be changed after creation.
     * @public
     */
    export declare interface DataGridDashboardOptions extends DashboardCellOptions {
    }
    /**
     * Interface for supplying single XY data-points to a component.
     *
     * The primary way of adding points is the **add()** method. All other methods are for end user utility,
     * and simply transform given data to the format of *add()*. As such, they cause additional performance overhead,
     * so use *add()* whenever possible.
     * @public
     */
    export declare interface DataInput {
        /**
         * Append a single `XY` coordinate or list of coordinates into the *series*.
         *
         * ```ts
         *  // Example syntax
         *  LineSeries.add({ x: 0, y: 100 })
         *
         *  LineSeries.add([
         *      { x: 0, y: 100 },
         *      { x: 10, y: 50 },
         *      { x: 20, y: 75 },
         *  ])
         * ```
         *
         * @param points - Single XY coordinate or list of coordinates.
         * @returns Object itself for fluent interface.
         * @public
         */
        add(points: Point | Point[]): this;
    }
    /**
     * Interface for supplying an Array of High Low data to a component.
     *
     * Given data is expected to be two number Arrays of equal length, which will be transformed into
     * a single array of AreaPoints.
     * This method is for end user utility, and simply transform given data to the format of *add()*.
     * As such, they cause additional performance overhead, so use *add()* whenever possible.
     * @public
     */
    export declare interface DataInputHighLow {
        /**
         * Add an Array of High Low values.
         * Each HighLow value will be paired with an automatically generated HighLow value, based on *step*-argument.
         * **For optimal performance, use add() if possible.**
         * @param arrayHigh - Array of first High values.
         * @param arrayLow - Array of Second Low values
         * @param step - Optional step between each HighLow coordinate. Defaults to 1.
         * @param start - Optional value for first generated HighLow value. Defaults to 0.
         * @returns Object itself for fluent interface.
         * @public
         */
        addArraysHighLow(arrayHigh: number[] | TypedArray, arrayLow: number[] | TypedArray, step?: number, start?: number): this;
    }
    /**
     * Interface for supplying an Array of X data to a component.
     *
     * Given data is expected to be number values, which will be transformed into an array of XY-compatible points.
     * This method is for end user utility, and simply transform given data to the format of *add()*.
     * As such, they cause additional performance overhead, so use *add()* whenever possible.
     * @public
     */
    export declare interface DataInputX {
        /**
         * Append new data points into the series by only supplying X coordinates.
         *
         * ```ts
         *  // Example syntax, number array
         *  LineSeries.addArrayX([ 5, 1, 2, 0 ])
         * ```
         *
         * This method supports binary data input by using *Typed arrays*.
         * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
         *
         * ```ts
         *  // Example syntax, typed array (Float32)
         *  const float32Array = new Float32Array(4)
         *  float32Array[0] = 5
         *  float32Array[1] = 1
         *  float32Array[2] = 2
         *  float32Array[3] = 0
         *  LineSeries.addArrayX(float32Array)
         * ```
         *
         * Each X coordinate will be paired with an automatically generated Y coordinate.
         *
         * By default, this continues from the last data point in the series.
         * However, the behavior of assigning Y coordinates can be controlled with the optional `step` and `start` parameters.
         *
         * @param arrayX - Array of X-values.
         * @param step - Optional step between each Y coordinate. Defaults to 1.
         * @param start - Optional value for first generated Y-value. Defaults to 0.
         * @returns Object itself for fluent interface.
         * @public
         */
        addArrayX(arrayX: number[] | TypedArray, step?: number, start?: number): this;
    }
    /**
     * Interface for supplying Arrays of data to a component.
     *
     * Given data is expected to be two number Arrays of equal length, which will be transformed into a single Array of XY-compatible points.
     * This method is for end user utility, and simply transform given data to the format of *add()*.
     * As such, they cause additional performance overhead, so use *add()* whenever possible.
     * @public
     */
    export declare interface DataInputXY {
        /**
         * Append new data points into the series by supplying X and Y coordinates in two separated arrays.
         *
         * ```ts
         *  // Example syntax, number array
         *  LineSeries.addArraysXY([0, 1, 2, 3], [ 5, 1, 2, 0 ])
         * ```
         *
         * This method supports binary data input by using *Typed arrays*.
         * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
         *
         * ```ts
         *  // Example syntax, typed array (Float32)
         *  const float32Array = new Float32Array(4)
         *  float32Array[0] = 5
         *  float32Array[1] = 1
         *  float32Array[2] = 2
         *  float32Array[3] = 0
         *  LineSeries.addArraysXY([0, 1, 2, 3], float32Array)
         * ```
         *
         * @param arrayX - Array of X-values.
         * @param arrayY - Array of Y-values.
         * @returns Object itself for fluent interface.
         * @public
         */
        addArraysXY(arrayX: number[] | TypedArray, arrayY: number[] | TypedArray): this;
    }
    /**
     * Interface for supplying an Array of Y data to a component.
     *
     * Given data is expected to be number values, which will be transformed into an array of XY-compatible points.
     * This method is for end user utility, and simply transform given data to the format of *add()*.
     * As such, they cause additional performance overhead, so use *add()* whenever possible.
     * @public
     */
    export declare interface DataInputY {
        /**
         * Append new data points into the series by only supplying Y coordinates.
         *
         * ```ts
         *  // Example syntax, number array
         *  LineSeries.addArrayY([ 5, 1, 2, 0 ])
         * ```
         *
         * This method supports binary data input by using *Typed arrays*.
         * If your data comes in any binary format, then using the typed array syntax is recommended for best performance.
         *
         * ```ts
         *  // Example syntax, typed array (Float32)
         *  const float32Array = new Float32Array(4)
         *  float32Array[0] = 5
         *  float32Array[1] = 1
         *  float32Array[2] = 2
         *  float32Array[3] = 0
         *  LineSeries.addArrayY(float32Array)
         * ```
         *
         * Each Y coordinate will be paired with an automatically generated X coordinate.
         *
         * By default, this continues from the last data point in the series.
         * However, the behavior of assigning X coordinates can be controlled with the optional `step` and `start` parameters.
         *
         * @param arrayY - Array of Y-values.
         * @param step - Optional step between each X coordinate. Defaults to 1.
         * @param start - Optional value for first generated X-value. Defaults to 0.
         * @returns Object itself for fluent interface.
         * @public
         */
        addArrayY(arrayY: number[] | TypedArray, step?: number, start?: number): this;
    }
    /**
     * Interface for enabling powerful application specific optimizations if input data follows a *specific pattern*.
     *
     * It is strongly recommended to utilize data patterns whenever possible.
     * The resulting performance can be 10 or even 100 times better when compared to not using data patterns.
     *
     * **When using this flag, it is the users responsibility to ensure that the supplied data abides by the promised pattern**.
     * Invalid input data can result in rendering artifacts or data not being rendered.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, Line Chart with timestamp X values that come directly from a sensor and have some randomness.
     *  // => 'ProgressiveX' can be used
     *  ChartXY.addLineSeries({
     *      dataPattern: {
     *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
     *          pattern: 'ProgressiveX',
     *          // regularProgressiveStep: false => The X step between each consecutive data point is not regular.
     *          regularProgressiveStep: false
     *      }
     *  })
     * ```
     *
     * ```typescript
     *  // Example 2, Line Chart with timestamp X values that always progress by exactly 1 minute (60000 ms).
     *  // => 'ProgressiveX' + regularProgressiveStep can be used
     *  ChartXY.addLineSeries({
     *      dataPattern: {
     *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
     *          pattern: 'ProgressiveX',
     *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
     *          regularProgressiveStep: true
     *      }
     *  })
     * ```
     * @public
     */
    export declare interface DataPattern {
        /**
         * Data pattern selection from a collection of preset options.
         *
         * `'ProgressiveX'` = every data points X value is **higher** than the previous ones X value.
         *
         * `'ProgressiveY'` = every data points Y value is **higher** than the previous ones Y value.
         *
         * `'RegressiveX'` = every data points X value is **lower** than the previous ones X value.
         *
         * `'RegressiveY'` = every data points X value is **lower** than the previous ones Y value.
         */
        pattern: 'ProgressiveX' | 'ProgressiveY' | 'RegressiveX' | 'RegressiveY';
        /**
         * Optional flag that can be used to indicate that the input data points will always progress by a static amount.
         * This is used in conjuction with a Progressive or Regressive `pattern`.
         *
         * For example, if `pattern: 'ProgressiveX'`, and the step between two consecutive data points is always `X = 1`, then this can be set to `regularProgressiveStep: true`.
         *
         * Enabling the `regularProgressiveStep` option when eligible can lead to increased performance,
         * but it is not a very significant difference.
         *
         * When enabled, invalid input data can result in rendering artifacts or data not being rendered.
         * If you see rendering errors, try setting this to `false`, or make sure that your data is indeed "regular progressive":
         *
         * - For `pattern: 'ProgressiveX' or 'RegressiveX'`, ensure that X step between each data point is always the same.
         * - For `pattern: 'ProgressiveY' or 'RegressiveY'`, ensure that Y step between each data point is always the same.
         */
        regularProgressiveStep?: boolean;
        /**
         * Optional flag that can be used to disable automatic grouping of progressive data that is packed **very** tightly together.
         *
         * Even if data grouping is enabled, data will be automatically displayed according to the active zoom level so that the data looks accurate at all times.
         *
         * Set to `true` or omit for maximum performance.
         */
        allowDataGrouping?: boolean;
    }
    /**
     * Interface for a data point that contains an associated numeric data value.
     *
     * Can be used for dynamic per data point coloring when associated with a Color lookup table {@link LUT}.
     *
     * For some series types, dynamic data point coloring might have to be explicitly enabled when the series is created.
     * Refer to series documentation for more detailed information.
     * @public
     */
    export declare interface DataValue {
        /**
         * Numeric value associated with the data point.
         *
         * Can be used for dynamic per data point coloring when associated with a Color lookup table {@link LUT}.
         *
         * For some series types, dynamic data point coloring might have to be explicitly enabled when the series is created.
         * Refer to series documentation for more detailed information.
         */
        readonly value?: number;
    }
    /**
     * Type union of supported methods of defining a formatting behavior for *DateTime TickStrategy*.
     *
     * **1. Intl.DateTimeFormatOptions:**
     *
     *  Use JavaScript API for formatting logic by supplying a *Intl.DateTimeFormatOptions* object. Example usage:
     *
     * ```javascript
     *  // 'January 2015'
     *  { year: 'numeric', month: 'long' }
     * ```
     *
     * For complete documentation of valid keys and values, refer to
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     *
     * **2. Custom formatting function:**
     *
     * Specify custom formatting logic by supplying a *function* that returns a *string*. Example usage:
     *
     * ```javascript
     *  ( value, range ) => {
     *      // 'value' = number position of tick along the *Axis*.
     *      // 'range' = *FormattingRange* object that can be used to find the total range of the *Axis*, if needed.
     *
     *      // Return *string*.
     *      return "any string"
     *  }
     *
     *  ( value ) => {
     *      // JS *Date* API can be used to interpret numeric *Axis* positions as *UTC Date/Time*, exposing a multitude of handy methods.
     *      const date = new Date( value )
     *      return date.toLocaleTimeString()
     *  }
     * ```
     *
     * JS *Date* documentation: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
     * @public
     */
    export declare type DateTimeFormatter = Intl.DateTimeFormatOptions | FormattingFunction;
    /**
     * *Axis Tick Strategy* that is designed for depicting date and time.
     *
     * Axis values are interpreted as UNIX timestamps similarly as with JavaScript Date API.
     *
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
     *
     * Axis interval ranges supported by `DateTImeTickStrategy`:
     * - Minimum: 1 second (`1000`).
     * - Maximum: 1000 years (*really big number*).
     *
     * For reaching Axis ranges smaller than 1 second, {@link TimeTickStrategy} is recommended.
     *
     * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
     *
     * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
     *
     * ```js
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks)
     * ```
     *
     * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
     * see example below for the idea:
     *
     * ```js
     *  // Specify TickStrategy and use callback to style automatic ticks.
     *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (dateTimeTicks) => dateTimeTicks
     *      // All methods of `DateTimeTickStrategy` can be used here for styling ticks.
     *      .setMajorTickStyle((majorTicks) => majorTicks
     *          .setLabelFont((font) => font
     *              .setWeight('bold')
     *          )
     *      )
     *  )
     * ```
     *
     * All available strategies for automatic Axis ticks creation can be referenced via {@link AxisTickStrategies}.
     * @public
     */
    export declare class DateTimeTickStrategy extends DateTimeTickStrategyRecord implements MutableAxisTickStrategy {
        /**
         * Set cursor formatter for this `DateTimeTickStrategy` object.
         *
         * This will override the date time formatting used by:
         * - Default cursor result table formatters.
         * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
         * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
         *
         * ```ts
         *  // Example syntax, specify cursor formatting to display week day, year, month, day, hour and minute.
         *  Axis.setTickStrategy(AxisTickStrategies.DateTime, (ticks) => ticks
         *      .setCursorFormatter((value, range, locale) =>
         *          new Date(value).toLocaleDateString(locale, {
         *              weekday: 'long',
         *              year: 'numeric',
         *              month: 'numeric',
         *              day: 'numeric',
         *              minute: '2-digit',
         *              hour: '2-digit',
         *          })
         *      )
         *  )
         * ```
         * @param formatter - `FormattingFunction` or `undefined` to use default date time cursor formatting.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setCursorFormatter(formatter: FormattingFunction | undefined): this;
        /**
         * Get cursor formatter of this `DateTimeTickStrategy` object.
         *
         * @returns `FormattingFunction` as set by user, or `undefined` to indicate that the default date time cursor formatting is configured.
         * @public
         */
        getCursorFormatter(): FormattingFunction | undefined;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified great tick style.
         *
         * *Great ticks* display the largest Date/Time information for the active time range.
         * There is always exactly one *great tick* in view.
         *
         * Example usage:
         *
         * **Disable great ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setGreatTickStyle( emptyTick )
         * )
         * ```
         *
         * **Set font of great ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setGreatTickStyle(( tickStyle: TickStyle ) => tickStyle
         *             .setLabelFont(( font ) => font
         *                 .setWeight( 'bold' )
         *             )
         *         )
         * )
         * ```
         * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setGreatTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
        /**
         * Get great tick style of this *DateTimeTickStrategy* object.
         *
         * *Great ticks* display the largest Date/Time information for the active time range.
         * There is always exactly one *great tick* in view.
         * @returns Great tick style.
         * @public
         */
        getGreatTickStyle(): TickStyle;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified major tick style.
         *
         * *Major ticks* display the next smaller Date/Time information after *Great ticks*.
         * Often times, they represent the most important information.
         *
         * Example usage:
         *
         * **Set font of major ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setMajorTickStyle(( tickStyle ) => tickStyle
         *             .setLabelFont(( font ) => font
         *                 .setWeight( 'bold' )
         *             )
         *         )
         * )
         * ```
         * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setMajorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
        /**
         * Get major tick style of this *DateTimeTickStrategy* object.
         *
         * *Major ticks* display the next smaller Date/Time information after *Great ticks*.
         * Often times, they represent the most important information.
         * @returns Major tick style.
         * @public
         */
        getMajorTickStyle(): TickStyle;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified minor tick style.
         *
         * *Minor ticks* display the next smaller Date/Time information after *Major ticks*.
         *
         * Example usage:
         *
         * **Disable minor ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setMinorTickStyle( emptyTick )
         * )
         * ```
         *
         * **Set font of minor ticks**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setMinorTickStyle(( tickStyle ) => tickStyle
         *             .setLabelFont(( font ) => font
         *                 .setWeight( 'bold' )
         *             )
         *         )
         * )
         * ```
         * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
         *                              Passing a function only works if the existing style is **not** *emptyTick*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setMinorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
        /**
         * Get minor tick style of this *DateTimeTickStrategy* object.
         *
         * *Minor ticks* display the next smaller Date/Time information after *Major ticks*.
         * @returns Minor tick style.
         * @public
         */
        getMinorTickStyle(): TickStyle;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified locale.
         *
         * The *locale* specifies a geographical, political or cultural region, affecting all formatting of *Tick labels*.
         *
         * All valid values can be found from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
         *
         * Example usage:
         *
         * **Use locale of browser**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setLocale( undefined )
         * )
         * ```
         *
         * **Use specific locale**:
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setLocale('en-US')
         * )
         * ```
         * @param locale - Valid JavaScript Date locale string, that specifies a geographical, political or cultural region.
         *                              All valid values can be found from
         *                              https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setLocale(locale: string | undefined): this;
        /**
         * Get locale of this *DateTimeTickStrategy* object.
         *
         * The *locale* specifies a geographical, political or cultural region, affecting all formatting of *Tick labels*.
         * @returns JavaScript Date locale string, that specifies a geographical, political or cultural region.
         * @public
         */
        getLocale(): string | undefined;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified dateOrigin.
         *
         * By default data-points are interpreted as *UTC dates* (milliseconds since January 1st 1970 GMT+0).
         * If a **dateOrigin** is defined, data-points will instead be interpreted as milliseconds since **dateOrigin**.
         *
         * Specifying a *dateOrigin* can be necessary in applications where there is a long range of date-time data,
         * and high resolution zooming is desired.
         *
         * Example usage:
         *
         * **Application with one day of high-density data starting in year 2020**:
         * ```javascript
         * // Without specifying a dateOrigin, zooming will be limited to minutes with this range.
         * // Milliseconds resolution can be reached by setting the dateOrigin to a Date
         * // that is closer to the actual data (instead of the default 1.1.1970).
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setDateOrigin( new Date( 2020, 0, 1 ) )
         * )
         * ```
         *
         * Check our DateTime Axis Interactive Example for a more thorough example on DateTime TickStrategy usage:
         * https://lightningchart.com/lightningchart-js-interactive-examples/examples/lcjs-example-0020-dateTimeAxis.html
         *
         * @param dateOrigin - A *JavaScript Date* object or *undefined*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setDateOrigin(dateOrigin: Date | undefined): this;
        /**
         * Get the *dateOrigin* of this *DateTimeTickStrategy* object.
         *
         * By default data-points are interpreted as *UTC dates* (milliseconds since January 1st 1970 GMT+0).
         * If a **dateOrigin** is defined, data-points will instead be interpreted as milliseconds since **dateOrigin**.
         * @returns A *JavaScript Date* object or *undefined*.
         * @public
         */
        getDateOrigin(): Date | undefined;
        /**
         * Utility method for setting *formatting function* of all tick levels (great, major, minor).
         *
         * This is applied to every zoom level, so regardless how you zoom the same formatting is used.
         *
         * If this is not desired, formatting for each zoom level can be individually overridden with following methods:
         * - {@link setFormattingDecade}
         * - {@link setFormattingYear}
         * - {@link setFormattingMonth}
         * - {@link setFormattingWeek}
         * - {@link setFormattingDay}
         * - {@link setFormattingHour}
         * - {@link setFormattingMinute}
         * - {@link setFormattingSecond}
         * - {@link setFormattingMilliSecond}
         * - {@link setCursorFormatter}
         *
         * @param greatTickFormattingOptions - Specify function for great ticks.
         * @param majorTickFormattingOptions - Specify function for major ticks.
         * @param minorTickFormattingOptions - Specify function for minor ticks.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormatting(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions?: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Major: Decades**
         * - **Minor: Years**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingDecade(
         *             { year: 'numeric' },
         *             { year: 'numeric' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         *
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingDecade(majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Major: Years**
         * - **Minor: Months**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingYear(
         *             { year: 'numeric' },
         *             { month: 'short' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingYear(majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Years**
         * - **Major: Months**
         * - **Minor: Weeks**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingMonth(
         *             { year: 'numeric' },
         *             { month: 'long' },
         *             { day: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingMonth(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Months**
         * - **Major: Weeks**
         * - **Minor: Days**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingWeek(
         *             { year: 'numeric', month: 'long' },
         *             { day: '2-digit' },
         *             { day: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingWeek(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Weeks**
         * - **Major: Days**
         * - **Minor: Hours**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingDay(
         *             { year: 'numeric', month: 'long' },
         *             { day: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingDay(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Days**
         * - **Major: Hours**
         * - **Minor: Minutes**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingHour(
         *             { year: 'numeric', month: 'long', day: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingHour(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Hours**
         * - **Major: Minutes**
         * - **Minor: Seconds**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingMinute(
         *             { year: 'numeric', month: 'long', day: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit', second: '2-digit' }
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*.
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingMinute(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Minutes**
         * - **Major: Seconds**
         * - **Minor: Milliseconds**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingSecond(
         *             { year: 'numeric', month: 'long', day: '2-digit', hour: '2-digit', minute: '2-digit' },
         *             { hour: '2-digit', minute: '2-digit', second: '2-digit' },
         *             ( value ) => new Date( value ).getUTCMilliseconds(),
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @param minorTickFormattingOptions - Formatting options for *minor ticks*
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingSecond(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined, minorTickFormattingOptions?: DateTimeFormatter | undefined): this;
        /**
         * Construct a new *DateTimeTickStrategy* object based on this one, but with modified formatting options
         * for DateTime ranges where ticks are positioned as follows:
         *
         * - **Great: Seconds**
         * - **Major: Every tenth MilliSecond**
         *
         * Example usage:
         *
         * ```javascript
         * Axis.setTickStrategy(
         *     AxisTickStrategies.DateTime,
         *     ( tickStrategy: DateTimeTickStrategy ) => tickStrategy
         *         .setFormattingMilliSecond(
         *             { year: 'numeric', month: 'long', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' },
         *             ( value ) => new Date( value ).getUTCMilliseconds()
         *         )
         * )
         * ```
         *
         * The used formatting options are dynamically chosen depending on the range of *Axis*, so depending
         * on the application this formatting customization method might not have a visible effect.
         *
         * For more detailed example usage, refer to {@link DateTimeFormatter}.
         * @param greatTickFormattingOptions - Formatting options for *great ticks*.
         * @param majorTickFormattingOptions - Formatting options for *major ticks*
         * @returns New *DateTimeTickStrategy* object.
         * @public
         */
        setFormattingMilliSecond(greatTickFormattingOptions: DateTimeFormatter | undefined, majorTickFormattingOptions: DateTimeFormatter | undefined): this;
    }
    /**
     * Modifiable properties of a DateTime *TickStrategy*.
     *
     * @public
     */
    declare interface DateTimeTickStrategyProperties {
        type: 'date-time-ticks';
        /**
         * Cursor formatter.
         *
         * This controls the date time formatting used by:
         * - Default cursor result table formatters.
         * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
         * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
         *
         * `undefined` means to use default date time cursor formatting.
         *
         * ```ts
         *  // Example value, cursor formatter to display week day, year, month, day, hour and minute.
         *  cursorFormatter: (value, range, locale) =>
         *      new Date(value).toLocaleDateString(locale, {
         *          weekday: 'long',
         *          year: 'numeric',
         *          month: 'numeric',
         *          day: 'numeric',
         *          minute: '2-digit',
         *          hour: '2-digit',
         *      })
         * ```
         */
        readonly cursorFormatter: FormattingFunction | undefined;
        /**
         * Style of Great ticks.
         *
         * To disable great ticks, set to **emptyTick**.
         *
         * **NOTE: Label alignment is overridden, and has no effect on this property.**
         */
        readonly greatTickStyle: TickStyle;
        /**
         * Style of Major ticks.
         */
        readonly majorTickStyle: TickStyle;
        /**
         * Style of Minor ticks.
         *
         * To disable minor ticks, set to **emptyTick**.
         */
        readonly minorTickStyle: TickStyle;
        /**
         * Valid javascript Date locale string, that specifies a geographical, political or cultural region.
         *
         * *undefined* passes the decision making to the browser.
         *
         * For example values, refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
         */
        readonly locale: string | undefined;
        /**
         * Optional "origin date" value.
         *
         * By default data-points are interpreted as *UTC dates* (milliseconds since January 1st 1970 GMT+0).
         * If a **dateOrigin** is defined, data-points will instead be interpreted as milliseconds since **dateOrigin**.
         */
        readonly dateOrigin: Date | undefined;
        /**
         * Formatter options for **major** ticks that are placed on relevant **century** intervals.
         */
        readonly formatOptionsMajorCentury: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **decade** intervals.
         */
        readonly formatOptionsMinorDecade: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **decade** intervals.
         */
        readonly formatOptionsMajorDecade: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **year** intervals.
         */
        readonly formatOptionsMinorYear: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **year** intervals.
         */
        readonly formatOptionsMajorYear: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **month** intervals.
         */
        readonly formatOptionsMinorMonth: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **year** intervals.
         */
        readonly formatOptionsGreatYear: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **month** intervals.
         */
        readonly formatOptionsMajorMonth: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **week** intervals.
         */
        readonly formatOptionsMinorWeek: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **month** intervals.
         */
        readonly formatOptionsGreatMonth: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **week** intervals.
         */
        readonly formatOptionsMajorWeek: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **day** intervals.
         */
        readonly formatOptionsMinorDay: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **week** intervals.
         */
        readonly formatOptionsGreatWeek: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **day** intervals.
         */
        readonly formatOptionsMajorDay: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **hour** intervals.
         */
        readonly formatOptionsMinorHour: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **day** intervals.
         */
        readonly formatOptionsGreatDay: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **hour** intervals.
         */
        readonly formatOptionsMajorHour: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **minute** intervals.
         */
        readonly formatOptionsMinorMinute: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **hour** intervals.
         */
        readonly formatOptionsGreatHour: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **minute** intervals.
         */
        readonly formatOptionsMajorMinute: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **second** intervals.
         */
        readonly formatOptionsMinorSecond: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **minute** intervals.
         */
        readonly formatOptionsGreatMinute: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **second** intervals.
         */
        readonly formatOptionsMajorSecond: DateTimeFormatter;
        /**
         * Formatter options for **minor** ticks that are placed on relevant **millisecond** intervals.
         */
        readonly formatOptionsMinorMillisecond: DateTimeFormatter;
        /**
         * Formatter options for **great** ticks that are placed on relevant **second** intervals.
         */
        readonly formatOptionsGreatSecond: DateTimeFormatter;
        /**
         * Formatter options for **major** ticks that are placed on relevant **millisecond** intervals.
         */
        readonly formatOptionsMajorMilliSecond: DateTimeFormatter;
    }
    /**
     * Default DateTime TickStrategy settings.
     * @public
     */
    declare const DateTimeTickStrategyRecord: Record_2.Factory<DateTimeTickStrategyProperties>;
    /**
     * Default background color for the On-screen menu div element.
     * @public
     */
    export declare const defaultOsmBackgroundColor = "#363636";
    /**
     * Union of Dimensional and Axis Strategies
     * @public
     */
    export declare type DimensionalAxisStrategy = MultidimensionalStrategy & AxisStrategy;
    /**
     * Interface specifies individual sizes for each dimension - width and height.
     * @public
     */
    export declare interface DimensionalEngineSize {
        /**
         * Specifies width of engine.
         */
        readonly width?: EngineDimension;
        /**
         * Specifies height of engine.
         */
        readonly height?: EngineDimension;
    }
    /**
     * Modify Theme to remove any glow effects.
     *
     * ```ts
     *  // Example syntax
     *  const chart = lightningChart().ChartXY({
     *      theme: disableThemeEffects(Themes.cyberSpace)
     *  })
     * ```
     *
     * Internally all this does is the following:
     *
     * ```ts
     *  return { ...theme, effect: undefined }
     * ```
     *
     * If you don't want to disable effects entirely, but only on some components, see:
     *
     * - {@link Theme.effectsText}
     * - {@link Theme.effectsDashboardSplitters}
     * - {@link ChartComponent.setEffect}
     *
     * @param   theme - Theme to modify.
     * @returns         New theme object without glow effects.
     * @public
     */
    export declare const disableThemeEffects: (theme: Theme) => Theme;
    /**
     * Interface for object that can be _disposed_, destroying it permanently.
     * @public
     */
    export declare interface Disposable {
        /**
         * Permanently destroy the component.
         *
         * @returns Object itself for fluent interface.
         * @public
         */
        dispose(): this;
    }
    /**
     * Interface for event methods for tracking when an object is _disposed_.
     * @public
     */
    export declare interface DisposableEvents {
        /**
         * Subscribe to `onDispose` event.
         * This event is triggered whenever the object is disposed.
         *
         * A component can only be disposed by the end user, by calling the `dispose` method on the component or the component which owns it.
         *
         * ```typescript
         *  // Example usage
         *
         * Dashboard.onDispose(() => {
         *   console.log('Dashboard was disposed')
         * })
         *
         * Dashboard.dispose()
         * ```
         *
         * @param handler - Handler function for event
         * @returns Token of subscription
         * @public
         */
        onDispose(handler: () => unknown): Token;
        /**
         * Remove event listener from dispose event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offDispose(token: Token): boolean;
    }
    /**
     * Interface for object that can be dragged by mouse.
     * @public
     */
    export declare interface Draggable {
        /**
         * Set dragging mode of object. Defines how the object can be dragged by mouse.
         *
         * See {@link UIDraggingModes} collection for options.
         * @param draggingMode - DraggingMode or undefined to disable dragging
         * @returns Object itself
         * @public
         */
        setDraggingMode(draggingMode?: UIDraggingModes): this;
        /**
         * Get dragging mode of object.
         * Defines how the object can be dragged by mouse.
         * @returns Object itself
         * @public
         */
        getDraggingMode(): UIDraggingModes;
    }
    /**
     * Type definition for a dynamic mouse style setting.
     * This allows for mouse styles that depend on situation.
     * @param uiElement - UIElement to apply
     * @returns Mouse style as string or undefined
     * @public
     */
    export declare type DynamicUIMouseStyle<T extends UIElement> = (uiElement: T) => string | undefined;
    /**
     * Ease Animation function
     * @param delta - Delta time from start of animation
     * @public
     */
    export declare type Ease = (delta: number) => number;
    /**
     * Type definition of an _Effect Configuration_.
     *
     * A theme can specify an Effect to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     * @public
     */
    export declare type Effect = GlowEffect;
    /**
     * Data type that defines a ellipse shape
     * @public
     */
    export declare interface EllipseDimensions {
        /**
         * X coordinate of ellipses center.
         */
        readonly x: number;
        /**
         * Y coordinate of ellipses center.
         */
        readonly y: number;
        /**
         * X radius of ellipse.
         */
        readonly radiusX: number;
        /**
         * Y radius of ellipse
         */
        readonly radiusY: number;
        /**
         * Optional parameter to control drawing precision.
         * This describes the number of sub divisions the ellipse is split into.
         * Should be a larger number for larger ellipses. Ideally users wouldn't see the step between divisions.
         * Defaults to `72`.
         */
        readonly drawSteps?: number;
    }
    /**
     * Class for series visual that is an Ellipse.
     * @public
     */
    export declare class EllipseFigure extends Figure {
        /**
         * @public
         */
        protected dimensions: EllipseDimensions;
        /**
         * @public
         */
        readonly scale: LinearScaleXY;
        /**
         * Get boundaries that contain figure.
         * @returns Interval<Point>
         * @public
         */
        getBoundaries(): Interval<Point>;
        /**
         * Set new dimensions for figure.
         * @param dimensions - Dimensions
         * @returns Object itself
         * @remarks          Owning series will be informed of change in size, possible initiating scrolling.
         * @public
         */
        setDimensions(dimensions: EllipseDimensions): this;
        /**
         * Get current dimensions of figure.
         * @returns Dimensions
         * @public
         */
        getDimensions(): EllipseDimensions;
        /**
         * Set fill style of Ellipse.
         * @param value - FillStyle object or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of Ellipse.
         * @returns FillStyle object
         * @public
         */
        getFillStyle(): FillStyle;
        /**
         * Set stroke style of Ellipse.
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link emptyLine}
         *
         * @param value - LineStyle object or mutator to modify existing one
         * @returns Object itself
         * @public
         */
        setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of Ellipse.
         * @returns LineStyle object
         * @public
         */
        getStrokeStyle(): LineStyle;
        /**
         * Return some dominant fill style of the figure
         * @returns FillStyle object
         * @public
         */
        getDominantStyle(): FillStyle;
    }
    /**
     * Implementation of EllipseSeries
     * @public
     */
    export declare class EllipseSeries extends FigureSeries<EllipseFigure, EllipseDimensions, LinearScaleXY> {
        /**
         * Add new figure to the series.
         * @param dimensions - Dimensions that figure must represent
         * @returns Created figure
         * @public
         */
        add(dimensions: EllipseDimensions): EllipseFigure;
        /**
         * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
         *
         * ```typescript
         *  // Example usage
         *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
         *      const rectangleDimensions = figure.getDimensionsTwoPoints()
         *      return tableBuilder
         *          .addRow(`Pointing at`, '', series.getName())
         *          .addRow(`X1:`, '', rectangleDimensions.x1)
         *          .addRow(`X2:`, '', rectangleDimensions.x2)
         *          .addRow(`Y1:`, '', rectangleDimensions.y1)
         *          .addRow(`Y2:`, '', rectangleDimensions.y2)
         *  })
         * ```
         *
         * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
         * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
         *
         * ```typescript
         *  // Using TableContentBuilder.
         *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
         *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
         *      tableBuilder
         *          .addRow('Item 0:', '', 'Value 0')
         *          .addRow('Item 1:', '', 'Value 1')
         *          .addRow('Long row that highlights the idea of empty strings')
         *
         *      // After configuration, the table builder must be returned!
         *      return tableBuilder
         *  })
         * ```
         *
         * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
         *
         * The additional values that are supplied to the callback function vary between different chart types,
         * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
         * `Figure Series` receive two extra parameters:
         * 1. `series` | reference to the series itself.
         * 2. `figure` | reference to the pointed *figure*.
         * This type is **generic** - for example, for `RectangleSeries` it is of type `RectangleFigure`.
         *
         * **Related API:**
         *
         * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
         * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
         *
         * @param formatter - Function which builds *ResultTable* content.
         * @returns Object itself
         * @public
         */
        setCursorResultTableFormatter(formatter: FigureSeriesFormatter<EllipseFigure, EllipseSeries>): this;
        /**
         * Get ResultTable Formatter.
         * @returns Function which builds ResultTable content for the Series.
         * @public
         */
        getCursorResultTableFormatter(): FigureSeriesFormatter<EllipseFigure, EllipseSeries>;
    }
    /**
     * Interface for supplying readonly configurations to a {@link EllipseSeries}.
     * @public
     */
    export declare interface EllipseSeriesOptions extends SeriesOptionsXY {
    }
    /**
     * Abstract class which indicates that shape should not be filled.
     *
     * When *emptyFill* is used, the area that would be filled does **NOT** trigger mouse / touch -events, and
     * its rendering process is skipped, which results in saved performance.
     * @public
     */
    export declare class EmptyFill extends EmptyFillRecord implements FillStyle {
    }
    /**
     * Singleton object which indicates that component should not have *fill color*.
     *
     * When *emptyFill* is used, the area that would be filled does **NOT** trigger mouse / touch -events (if this is desired, use a transparent {@link SolidFill} instead).
     *
     * **emptyFill Usage:**
     *
     * Use emptyFill with:
     * - `setFillStyle` methods:
     *      * {@link PointSeries.setPointFillStyle}
     *      * {@link ChartXY.setTitleFillStyle}
     *
     * ```typescript
     *  // Example
     *  PointSeries.setPointFillStyle(emptyFill)
     * ```
     *
     * - {@link SolidLine}, or other *line styles*.
     *
     * ```typescript
     *  // Example, construct a SolidLine.
     *  const lineStyle = new SolidLine({
     *      thickness: 1,
     *      fillStyle: emptyFill
     *  })
     * ```
     *
     * **Related information:**
     *
     * For more *fill styles*, see:
     * - {@link SolidFill}
     * - {@link IndividualPointFill}
     * - {@link PalettedFill}
     * - {@link RadialGradientFill}
     * - {@link LinearGradientFill}
     * - {@link ImageFill}
     * @public
     */
    export declare const emptyFill: EmptyFill;
    /**
     * Interface for all properties of a empty FillStyle.
     * @public
     */
    declare const EmptyFillRecord: Record_2.Factory<{
        type: "fillstyle";
        fillType: "empty";
    }>;
    /**
     * @public
     */
    declare class EmptyLine extends EmptyLineRecord implements LineStyle, StylePropFuncs<ThisType<EmptyLine>, {}> {
        /**
         * @public
         */
        thickness: number;
        /** @public */
        setThickness(thickness: number): this;
        /** @public */
        getThickness(): number;
        /** @public */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * @returns Object itself, because the entire style does not have any color information.
         * @public
         */
        getFillStyle(): EmptyFill;
    }
    /**
     * Singleton object which specifies that a *line* should not be rendered.
     *
     * When *emptyLine* is used, the configured line does **NOT** trigger mouse / touch -events (if this is desired, use a transparent {@link SolidLine} instead).
     *
     * **emptyLine Usage:**
     *
     * Use emptyLine as argument of:
     * - `setStrokeStyle` methods:
     *      * {@link LineSeries.setStrokeStyle}
     *      * {@link Axis.setStrokeStyle}
     *      * {@link CustomTick.setGridStrokeStyle}
     *      * etc.
     *
     * ```typescript
     *  // Example
     *  LineSeries.setStrokeStyle(emptyLine)
     * ```
     *
     * **Related information:**
     *
     * For more *line styles*, see:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * @public
     */
    export declare const emptyLine: EmptyLine;
    /**
     * Interface for all properties of a empty FillStyle.
     * @public
     */
    declare const EmptyLineRecord: Record_2.Factory<{
        type: "linestyle";
        lineType: "empty";
    }>;
    /**
     * *TickStyle* singleton, which can be used to indicate that *Ticks* shouldn't be displayed.
     *
     * Can be used with *TickStrategies*.
     *
     * Example usage:
     * ```javascript
     * // Get Default Y Axis of XY Chart.
     * chart.getDefaultAxisY()
     *   // Modify the Axis' TickStrategy.
     *   .setTickStrategy(
     *      // Using a Numeric TickStrategy, modify it's Styler.
     *      AxisTickStrategies.Numeric, ( numericTickStrategy ) => numericTickStrategy
     *          // Set the Minor TickStyle of the TickStrategy as EmptyTick.
     *          .setMinorTickStyle( emptyTick )
     * )
     * ```
     * @public
     */
    export declare const emptyTick: TickStyle;
    /**
     * Empty UiElement
     * @public
     */
    export declare class EmptyUIElement extends InternalUIElement {
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setMouseInteractions(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getMouseInteractions(): boolean;
    }
    /**
     * Type of dimension for engine; can be a tuple of boundaries, a single static dimension or undefined for container size.
     * When using a tuple to specify boundaries [min, max], actual size for engine will be the size of its container clamped to the specified
     * pixel boundaries. Any of the values inside the tuple can be undefined.
     * Using a single number will set a static size for engine dimension, meaning no resizing of engine will take effect.
     * @public
     */
    export declare type EngineDimension = [number | undefined, number | undefined] | undefined | number;
    /**
     * Interface that can be used to configure rendering Engine of LCJS *charts* and *dashboards*.
     *
     * **Commonly used properties:**
     *
     * - {@link FitEngineToDiv.container | container}: Specify DOM container for chart.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create chart without specifying DOM container. LCJS will automatically append a <div> in the document.
     *  // Recommended for testing, mainly.
     *  const chart = LightningChart.ChartXY({})
     * ```
     *
     * ```typescript
     *  // Example 2, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
     *  const chart = LightningChart.ChartXY({
     *      // Argument can be either *element id* or actual reference to the HTML element.
     *      container: 'my-chart-div'
     *  })
     * ```
     * @public
     */
    export declare type EngineOptions = EngineSettings & (FitEngineToDiv | DimensionalEngineSize);
    /**
     * Interface specifies settings for Engine.
     * @public
     */
    export declare interface EngineSettings {
        /**
         * Max FPS (frames-per-second).
         * Setting this will postpone rendering events that would otherwise happen, if it would result in FPS higher than the value.
         *
         * NOTE: This property can't be used to accurately specify actual FPS as it is dictated by the browser. The purpose for 'maxFps' is
         * to limit unnecessary rendering loads where they are not needed.
         */
        readonly maxFps?: number;
        /**
         * Set preference for anti-aliasing.
         *
         * If set to true or undefined and browser supports anti-aliasing then the chart will be anti-aliased. If set to false or browser
         * doesn't support anti-aliasing then the chart will not be anti-aliased.
         */
        readonly antialias?: boolean;
        /**
         * Set preference for high quality line anti-aliasing.
         *
         * If set to true or undefined and browser supports OES_standard_derivatives or WebGL2 then the non-primitive lines (thickness !== -1) will be anti-aliased. If set to false or browser
         * doesn't support the OES_standard_derivatives extension or WebGl2 then the lines will not be anti-aliased with high quality but the line might me anti-aliased with default hardware anti-aliasing.
         *
         * Setting {@link EngineSettings.antialias} to `false` will also disable line anti-aliasing.
         */
        readonly lineAntiAlias?: boolean;
        /**
         * Set device pixel ratio.
         *
         * This ratio is used to support high DPI devices. This should be set to true when the meta tag "viewport"
         * has been set to "width=device-width" and you want to let the chart automatically determine the device pixel ratio to use.
         * ```html
         * <meta name="viewport" content="width=device-width, initial-scale=1.0">
         * ```
         *
         * Set this to a specific number if you want to use a specific device pixel ratio.
         *
         * By default if this option is not specified the ratio will be automatically decided based on the existence of the viewport meta tag
         * and the content of the tag if found.
         */
        readonly devicePixelRatio?: boolean | number;
        /**
         * *Color theme* for the component.
         *
         * A collection of default implementations can be accessed by {@link Themes}.
         *
         * ```typescript
         *  // Example, specify color theme of chart.
         *  const chart = LightningChart.ChartXY({
         *      theme: Themes.light
         *  })
         * ```
         *
         * For custom color themes, refer to Developer Documentation \> Themes section.
         */
        readonly theme?: Theme;
        /**
         * Pass instructions regarding WebGL (rendering engine framework).
         */
        readonly webgl?: {
            /**
             * Force specific WebGL version to be used.
             *
             * LightningChart JS supports WebGL versions 2 and 1.
             * WebGL 2 is used when available (better performance).
             *
             * If a specific version is selected, then it is always used, or if it is not available then the chart will crash.
             * This can be useful for debugging a specific WebGL version.
             */
            version?: 'webgl1' | 'webgl2';
        };
        /**
         * Specify precision level for interacting on charts with mouse, touch and other pointer devices.
         *
         * The required precision can have a significant effect on charts performance. By default, a relatively low precision is used.
         * When required, the precision can be increased by supplying a different value with this parameter.
         *
         * **Possible values:**
         *
         * - `undefined` | Default picking precision.
         * - `'low'` | Use lower precision than the default. This will result in better performance but less precision with mouse, touch and other pointers.
         * - `'high'` | Use higher precision than the default. This will result in decreased performance but better precision with mouse, touch and other pointers.
         * - `'best'` | Use the best available picking precision. This will result in decreased performance but better precision with mouse, touch and other pointers.
         *
         * **Example usage:**
         *
         * ```ts
         *  // Specify picking precision when a chart or dashboard is created.
         *  const chart = lightningChart().ChartXY({
         *      pickingPrecision: 'high'
         *  })
         * ```
         */
        readonly pickingPrecision?: 'best' | 'high' | 'low' | undefined;
        /**
         * Flag that can be used to disable all user interactions from created chart components.
         *
         * This can be useful in server side rendering applications and also on frontend side when the user interactions are not needed.
         *
         * Disabling user interactions can provide significant benefits to the performance and loading speed of charts.
         *
         * By default, charts are always interactable.
         *
         * ```ts
         *  // Example, create chart without user interactions.
         *  const chart = lightningChart().ChartXY({
         *      interactable: false,
         *  })
         * ```
         */
        readonly interactable?: boolean;
        /**
         * Text snapping to pixel enabled or disabled. By default `true`.
         *
         * Text quality is sharper and clearer with pixel snapping, but in some cases it can show as undesirable "moving" or "bouncing" of text.
         * So far this has been observed in _slowly scrolling applications_. If this becomes an issue in your application, try disabling text pixel snapping like below:
         *
         * ```ts
         *  // Example, disable text pixel snapping
         *  const chart = lightningChart().ChartXY({ textPixelSnappingEnabled: false })
         * ```
         *
         * This is an _experimental_ feature, meaning that if it should become deprecated it will likely be immediately removed even without a major release.
         * However, in this case an alternative method or fix to the issues solved with `textPixelSnappingEnabled` will also be introduced.
         *
         * **If you need to use `textPixelSnappingEnabled` in your application, please consider informing the developers of LightningChart JS at `https://lightningchart.com/js-charts/docs/contact`**
         * You do not need to share any extensive details about yourself, your company or your use case.
         * However, it is important for us to get some idea if users start depending on this property.
         * A simple message like "Hi, I just encountered a problem related to text pixel snapping and had to disable it with the textPixelSnappingEnabled flag." will do perfectly fine.
         *
         * @beta
         */
        readonly textPixelSnappingEnabled?: boolean;
    }
    /**
     * Utility type for creating union string literal types from Enums.
     * @public
     */
    export declare type EnumToStringUnion<T extends string | number> = `${T}`;
    /**
     * Pointer event interface with extra information
     */
    declare interface ExtendedPointerEvent extends PointerEvent {
        /**
         * All current interaction locations
         */
        interactions: Point[];
        /**
         * Flag used to signal the event handling logic to forcefully end the touch event.
         * This flag is mainly used for the OSM feature as we need to manually trigger a touch end event when the touch pointer is crosses over the OSM container.
         */
        forceTouchEnd: boolean;
    }
    /**
     * Abstract figure class for series visuals that are formed of multiple primitive shapes.
     * @public
     */
    export declare abstract class Figure extends UIObject implements Disposable, DisposableEvents {
        /**
         * @public
         */
        readonly scale: ScaleXY;
        /**
         * Get boundaries that contain figure.
         * @returns Interval<Point>
         * @public
         */
        abstract getBoundaries(): Interval<Point>;
        /**
         * Subscribe to highlight object event. This is called whenever an object is highlighted.
         * @param handler - Function that is called when event is triggered.
         * @param isHighlighted - The Highlight state.
         * @returns Token that can be used to unsubscribe from the event.
         * @public
         */
        onHighlight(handler: (obj: this, isHighlighted: boolean) => void): Token;
        /**
         * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
         * @param token - Token that was received when subscribing to the event.
         * @returns True if the unsubscription was successful.
         * @public
         */
        offHighlight(token: Token): boolean;
        /**
         * Return some dominant fill style of the figure
         * @returns FillStyle object
         * @public
         */
        abstract getDominantStyle(): FillStyle;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         * @public
         * @privateRemarks  Override
         */
        setVisible(state: boolean): this;
        /**
         * Subscribe `onDispose` event.
         * This event is triggered whenever the object is disposed.
         *
         * ```typescript
         *  // Example usage
         *
         * Figure.onDispose(() => {
         *   console.log('Figure was disposed')
         * })
         *
         * Figure.dispose()
         * ```
         *
         * @param handler - Handler function for event
         * @returns Token of subscription
         * @public
         */
        onDispose(handler: (object: this) => unknown): Token;
        /**
         * Remove event listener from dispose event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offDispose(token: Token): boolean;
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setMouseInteractions(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getMouseInteractions(): boolean;
    }
    /**
     * Abstract base class for series based on figures.
     * @public
     */
    export declare abstract class FigureSeries<FigureType extends Figure = Figure, InputType extends unknown = unknown, ScaleType extends ScaleXY = ScaleXY> extends SeriesXY<FigureSeriesCursorPoint<FigureType>, ScaleType> {
        /**
         * Clear all previously pushed data points from the *series*.
         *
         * ```ts
         *  // Example usage
         *  LineSeries.clear()
         * ```
         *
         * @returns Object itself for fluent interface.
         * @public
         */
        clear(): this;
        /**
         * Add new figure to the series.
         * @param dimensions - Dimensions that figure must represent
         * @returns Created figure
         * @public
         */
        abstract add(dimensions: InputType): FigureType;
        /**
         * Set style for all figures of series.
         * NOTE: Because the function is applied for each figure added, it is not advised to create any objects inside the function.
         * Instead they should be previously cached and later referred to.
         *
         * Example usage:
         *```javascript
         * // Explicit style
         * // The type of 'figure' is equal to type parameter: FigureType
         * SimpleFigureSeries.setDefaultStyle((figure) => ...)
         * ```
         * @param styler - Styler function that is applied to all existing and newly added segments
         * @returns Object itself
         * @public
         */
        setDefaultStyle(styler: FigureStyler<FigureType>): this;
        /**
         * Method for solving the nearest data point from a given coordinate on screen.
         *
         * ```ts
         *  // Example usage, from mouse move event.
         *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
         *      const result = LineSeries.solveNearestFromScreen(event)
         *  })
         * ```
         *
         * ```ts
         *  // Example usage, arbitrary coordinate on client coordinate system.
         *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
         * ```
         *
         * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
         *
         * @param   location -  Location in HTML client coordinates.
         * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
         * @public
         */
        solveNearestFromScreen(location: CoordinateClient): undefined | FigureSeriesCursorPoint<FigureType>;
        /**
         * Solves the nearest data point to a given coordinate on screen.
         * @param location - Location on screen
         * @returns Undefined or data-structure for positioning of cursors
         * @public
         * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
         */
        solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | FigureSeriesCursorPoint<FigureType>;
        /**
         * @returns Max X value of the series
         * @public
         */
        getXMax(): number;
        /**
         * @returns Min X value of the series
         * @public
         */
        getXMin(): number;
        /**
         * @returns Max Y value of the series
         * @public
         */
        getYMax(): number;
        /**
         * @returns Min Y value of the series
         * @public
         */
        getYMin(): number;
        /**
         * Attach object to an legendBox entry
         * @param entry - Object which has to be attached
         * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
         *                          when its respective Entry is clicked.
         * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
         * @returns Series itself for fluent interface
         * @public
         */
        attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
    }
    /**
     * @public
     */
    declare interface FigureSeriesCursorPoint<FigureType extends Figure> extends CursorPoint {
        /**
         * Pointed figure.
         */
        figure: FigureType;
    }
    /**
     * Interface for a function which builds ResultTable content when pointing at a FigureSeries.
     * @param tableContentBuilder - Builder that is used to build contents of ResultTable.
     *                                  Use addRow() method for adding content.
     * @param series - Series
     * @param segment - Figure that is pointed at. This type is abstract and depends on the type of Series in question.
     *                                  For example, if you are using a BoxSeries this 'figure' will be of type: "BoxFigure".
     * @returns TableContentBuilder that was supplied
     * @public
     */
    export declare type FigureSeriesFormatter<FigureType extends Figure, SeriesType extends FigureSeries<FigureType>> = <T extends TableContentBuilder>(tableContentBuilder: T, series: SeriesType, figure: FigureType) => T;
    /**
     * Type for styler function for Figure
     * @param figure - Figure
     * @public
     */
    export declare type FigureStyler<T extends Figure> = (figure: T) => void;
    /**
     * Base interface for *fill styles*.
     *
     * For implementations with more detailed documentation, see:
     * - {@link SolidFill}
     * - {@link emptyFill}
     * - {@link IndividualPointFill}
     * - {@link PalettedFill}
     * - {@link RadialGradientFill}
     * - {@link LinearGradientFill}
     * - {@link ImageFill}
     * @public
     */
    export declare interface FillStyle {
        /**
         * @public
         */
        readonly type: 'fillstyle';
        /**
         * @public
         */
        readonly fillType: 'solid' | 'empty' | 'image' | 'radial-gradient' | 'linear-gradient' | 'individual' | 'palette';
    }
    /**
     * Interface specifies that Engine should not think about its own size and simply fit itself into
     * an existing element on the document, which should be created by user.
     * @public
     */
    export declare interface FitEngineToDiv {
        /**
         * The DOM Element or its ID that will contain the chart.
         * If there is no such element found, the chart will not work.
         *
         * If nothing was provided, LCJS will automatically append a new DIV element on the document for the chart.
         *
         * **Resizing chart**:
         *
         * When the chart is inside a container managed by user, manual trigger of chart resize is required:
         *
         * ```js
         *  // Example syntax, trigger chart resize on user event.
         *  myResizeEventCallback(() => {
         *      // Trigger chart resize manually.
         *      chart.engine.layout()
         *  })
         * ```
         *
         * For more information, see {@link PublicEngine}.
         */
        readonly container?: HTMLDivElement | string;
    }
    /**
     * Indicates object whose size can be fitted into an arbitrary Vec2
     * @public
     */
    export declare interface Fittable {
        /**
         * Fit object to bounding box.
         * @param bounds - Bounds in pixels
         * @returns Object itself
         * @public
         */
        fitTo(bounds: Point): this;
    }
    /**
     * Auto fitting strategy that tries to fit ResultTable by flipping its origin.
     * @public
     */
    declare class Flip<ResultTableBackgroundType extends UIBackground> extends AutoFitStrategy<ResultTableBackgroundType> {
    }
    /**
     * Interface of all properties of {@link FontSettings}.
     * @public
     */
    export declare interface FontProperties {
        type: 'font';
        /**
         * [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
         *
         * For example, `16`.
         */
        size: number;
        /**
         * [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
         *
         * For example, `'Arial, Helvetica, sans-serif'`.
         */
        family: string;
        /**
         * [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
         *
         * For example, `'bold'`.
         */
        weight: FontWeight;
        /**
         * [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
         *
         * For example, `'italic'`
         */
        style: FontStyle;
        /**
         * [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp).
         *
         * `true` = 'small-caps', `false` = 'normal'.
         */
        variant: boolean;
    }
    /**
     * Style class for describing a *font*.
     *
     * Instances of FontSettings, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of FontSettings:**
     * - `size`: [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
     * - `family`: [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
     * - `weight`: [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
     * - `style`: [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
     * - `variant`: [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp). `true` = 'small-caps', `false` = 'normal'.
     *
     * **FontSettings usage:**
     *
     * Use FontSettings with:
     * - `setFont` methods:
     *      * {@link ChartXY.setTitleFont}
     *      * {@link UITextBox.setTextFont}
     *      * {@link ResultTable.setTextFont}
     *
     * ```typescript
     *  // Example 1, set chart title font with explicit font.
     *  ChartXY.setTitleFont(new FontSettings({
     *      size: 20,
     *      family: 'Arial, Helvetica, sans-serif',
     *      weight: 'bold',
     *      style: 'italic'
     *  }))
     *
     *  // Example 2, override chart title font, specifying only a sub-set of properties.
     *  ChartXY.setTitleFont((font) => font
     *      .setSize(20)
     *  )
     * ```
     *
     * @public
     */
    export declare class FontSettings extends FontSettingsRecord {
        /**
         * Construct a FontSettings object, specifying any amount of its properties.
         *
         * ```typescript
         *  // Example,
         *  const font = new FontSettings({
         *      size: 20,
         *      family: 'Arial, Helvetica, sans-serif',
         *      weight: 'bold',
         *      style: 'italic',
         *  })
         * ```
         *
         * @param props - Object containing any amount of SolidFill properties.
         * @public
         */
        constructor(props?: Partial<FontProperties>);
        /**
         * Create new FontSettings object with different `size`.
         *
         * [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
         *
         * For example, `16`.
         * @param size - Font size.
         * @returns New FontSettings object.
         * @public
         */
        setSize(size: number): this;
        /**
         * Create new FontSettings object with different `family`.
         *
         * [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
         *
         * For example, `'Arial, Helvetica, sans-serif'`.
         * @param family - Font family or list of families.
         * @returns New FontSettings object.
         * @public
         */
        setFamily(family: string): this;
        /**
         * Create new FontSettings object with different `weight`.
         *
         * [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
         *
         * For example, `'bold'`.
         * @param weight - Font weight.
         * @returns New FontSettings object.
         * @public
         */
        setWeight(weight: FontWeight): this;
        /**
         * Create new FontSettings object with different `style`.
         *
         * [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
         *
         * For example, `'italic'`
         * @param style - Font style.
         * @returns New FontSettings object.
         * @public
         */
        setStyle(style: FontStyle): this;
        /**
         * Create new FontSettings object with different `variant`.
         *
         * [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp).
         *
         * `true` = 'small-caps', `false` = 'normal'
         * @param Font - variant.
         * @returns New FontSettings object.
         * @public
         */
        setVariant(smallCaps: boolean): this;
        /**
         * Get font `size`.
         *
         * [CSS font size](https://www.w3schools.com/CSSref/pr_font_font-size.asp).
         *
         * For example, `16`.
         * @returns Font size.
         * @public
         */
        getSize(): number;
        /**
         * Get font `family`.
         *
         * [CSS font family](https://www.w3schools.com/CSSref/pr_font_font-family.asp), or list of font families.
         *
         * For example, `'Arial, Helvetica, sans-serif'`.
         * @returns Font family.
         * @public
         */
        getFamily(): string;
        /**
         * Get font `weight`.
         *
         * [CSS font weight](https://www.w3schools.com/CSSref/pr_font_weight.asp).
         *
         * For example, `'bold'`.
         * @returns Font weight.
         * @public
         */
        getWeight(): FontWeight;
        /**
         * Get font `style`.
         *
         * [CSS font style](https://www.w3schools.com/CSSref/pr_font_font-style.asp).
         *
         * For example, `'italic'`
         * @returns Font style.
         * @public
         */
        getStyle(): FontStyle;
        /**
         * Get font `variant`.
         *
         * [CSS font variant](https://www.w3schools.com/CSSref/pr_font_font-variant.asp).
         *
         * `true` = 'small-caps', `false` = 'normal'.
         * @returns Font variant.
         * @public
         */
        getVariant(): boolean;
    }
    /**
     * Constructor for a Record of FontProperties.
     * @public
     */
    declare const FontSettingsRecord: Record_2.Factory<FontProperties>;
    /**
     * Auto fitting strategy that tries to fit ResultTable by reducing its fontSize
     * @public
     */
    declare class FontSize<ResultTableBackgroundType extends UIBackground> extends AutoFitStrategy<ResultTableBackgroundType> {
    }
    /**
     * Type definition for {@link FontSettings.style} property.
     * @public
     */
    export declare type FontStyle = 'normal' | 'italic' | 'oblique';
    /**
     * Type definition for {@link FontSettings.weight} property.
     * @public
     */
    export declare type FontWeight = 'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900;
    /**
     * Function for formatting a longitude + latitude value into degrees and minutes formatted string.
     * @param longitude - Longitude value.
     * @param latitude - Latitude value.
     * @returns Formatted String.
     * @public
     */
    export declare const formatLongitudeLatitude: (longitude: number, latitude: number) => string;
    /**
     * Format a number to unicode superscript.
     * For example, `10` -\> ``
     *
     * All values behind decimal point are ignored!
     *
     * Please note that Unicode superscript does not necessarily look proper on all fonts.
     * The visual result is heavily font specific.
     * @public
     */
    export declare const formatNumberAsUnicodeSuperscript: (value: number) => string;
    /**
     * Type definition for a *pure* *formatting function*.
     *
     * The formatter is supplied a numeric value, and it formats it into a *string*, that can be displayed
     * on an *Axis tick*, for example.
     * @param value - Numeric value.
     * @param range - Object that represents the possible range for *value*.
     *                          For example, the start-end range of an *Axis*.
     * @returns Value formated as string
     * @public
     */
    export declare type FormattingFunction = (value: number, range: FormattingRange, locale?: string) => string;
    /**
     * Enum-like object for implementations of default Formatting functions.
     * @public
     */
    export declare const FormattingFunctions: {
        /**
         * Formats a number.
         * @param value - Value on range to format
         * @param range - FormatingRange
         * @returns Value formated as string
         * @public
         */
        Numeric: (value: number, range: FormattingRange) => string;
        /**
         * Formats a number by range-dependant rounding and usage of units.
         * @param value - Value on range to format
         * @param range - FormatingRange
         * @returns Value formated as string with units
         * @public
         */
        NumericUnits: (value: number, range: FormattingRange) => string;
        /**
         * Formats number like `"10"`
         *
         * Alternate, built-in formatting for logarithmic ticks.
         * Better suited especially for applications with zooming.
         *
         * ```ts
         *  // Example, enable extreme ticks with exponent formatting
         *  chart
         *      .getDefaultAxisX()
         *      .setTickStrategy(AxisTickStrategies.Numeric, (ticks) =>
         *          ticks
         *              .setMajorFormattingFunction(FormattingFunctions.LogarithmicExponentsRounded)
         *              .setMinorFormattingFunction(FormattingFunctions.LogarithmicExponents)
         *      )
         * ```
         * @public
         */
        LogarithmicExponentsRounded: (value: number, range: FormattingRange, locale?: string, logBase?: 'e' | number) => string;
        /**
         * Formats number like `"210"`
         *
         * Alternate, built-in formatting for logarithmic ticks.
         * Better suited especially for applications with zooming.
         *
         * ```ts
         *  // Example, enable extreme ticks with exponent formatting
         *  chart
         *      .getDefaultAxisX()
         *      .setTickStrategy(AxisTickStrategies.Numeric, (ticks) =>
         *          ticks
         *              .setMajorFormattingFunction(FormattingFunctions.LogarithmicExponentsRounded)
         *              .setMinorFormattingFunction(FormattingFunctions.LogarithmicExponents)
         *      )
         * ```
         * @public
         */
        LogarithmicExponents: (value: number, range: FormattingRange, locale?: string, logBase?: 'e' | number) => string;
        /**
         * Formats number like `"2.1310"`
         *
         * Recommended to be used together with "extreme ticks" when logarithmic ticks are paired with requirement of zooming far in.
         *
         * ```ts
         *  // Example, enable extreme ticks with special formatting
         *  chart
         *      .getDefaultAxisX()
         *      .setTickStrategy(AxisTickStrategies.Numeric, (ticks) =>
         *          ticks
         *              .setExtremeTickStyle(chart.getTheme().xAxisNumericTicks.majorTickStyle)
         *              .setExtremeFormattingFunction(FormattingFunctions.LogarithmicExtreme),
         *      )
         * ```
         * @public
         * @beta
         */
        LogarithmicExtreme: (value: number, range: FormattingRange, locale?: string, logBase?: 'e' | number) => string;
        /**
         * Default formatting function for logarithmic axis.
         * Formats values like `"0.1"`, `"1"`, `"10"` and so on.
         * @public
         * @beta
         */
        LogarithmicNoExponents: (value: number, range: FormattingRange, locale?: string, logBase?: 'e' | number) => string;
    };
    /**
     * Object that represents a range of values.
     * @public
     */
    export declare interface FormattingRange {
        /**
         * Get first value on range.
         *
         * This can be higher than the *end* value, for example, in the case of a *inverted Axis*.
         * @returns Number
         * @public
         */
        getInnerStart(): number;
        /**
         * Get final value on range.
         *
         * This can be smaller than the *start* value, for example, in the case of a *inverted Axis*.
         * @returns Number
         * @public
         */
        getInnerEnd(): number;
    }
    /**
     * Abstract base class for *Funnel Charts*.
     * Visualizes proportions and percentages between categories, by dividing a funnel into proportional segments.
     *
     * Set data using *FunnelChart*.**addSlice( name: string, value: number )**
     *
     * There are multiple implementations of *FunnelChart*, each with their own visual design and *API* for customizing it.
     * List of selectable options can be found in: {@link FunnelChartTypes}
     * @public
     */
    export declare abstract class FunnelChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends Chart implements SlicedCharts<FunnelSlice>, ChartWithCursor<CursorResultTableBackgroundType> {
        /**
         * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
         *
         * **Example usage:**
         *
         * ```typescript
         *  // Example 1, style AutoCursor ResultTable.
         *  FunnelChart.setAutoCursor((autoCursor) => autoCursor
         *      .setResultTable((resultTable) => resultTable
         *          .setOrigin(UIOrigins.LeftTop)
         *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         *          .setTextFont((font) => font
         *              .setSize(12)
         *              .setFamily('sans-serif')
         *          )
         *          .setBackground((background) => background
         *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
         *          )
         *      )
         *  )
         * ```
         *
         * ```typescript
         *  // Example 2, style AutoCursor PointMarker.
         *  FunnelChart.setAutoCursor((autoCursor) => autoCursor
         *      .setPointMarker((marker) => marker
         *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         *          .setSize({ x: 10, y: 10 })
         *          .setStrokeStyle(emptyLine),
         *      ),
         *  )
         * ```
         * @param mutator - Callback function that receives reference to the charts `AutoCursor`.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAutoCursor(mutator: Mutator<AutoCursor<CursorResultTableBackgroundType>>): this;
        /**
         * Get reference to charts `AutoCursor`.
         *
         * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
         *
         * @returns `AutoCursor`.
         * @public
         */
        getAutoCursor(): AutoCursor<CursorResultTableBackgroundType>;
        /**
         * Set chart `AutoCursor` behavior, by selecting a preset option from {@link AutoCursorModes}.
         *
         * Possible values:
         * - `AutoCursorModes.snapToClosest` (default) | *AutoCursor* snaps to closest data point from mouse location.
         * - `AutoCursorModes.onHover` | *AutoCursor* is only shown when it is directly over a *series*. NOTE: Series mouse interactions must be enabled for this to work!
         * - `AutoCursorModes.disabled` | *AutoCursor* is disabled
         *
         * ```typescript
         *  // Example, disable AutoCursor
         *  FunnelChart.setAutoCursorMode(AutoCursorModes.disabled)
         * ```
         *
         * **Related information:**
         *
         * On *series* level, *AutoCursor* behavior can be configured individually for each *series*, and there are also more *series* specific options available.
         * Here is `LineSeries` for example:
         *
         * - {@link Series2D.setCursorEnabled} | configure whether cursor should pick on the series or not.
         * - {@link SeriesXY.setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
         * - {@link LineSeries.setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
         * - {@link SeriesXY.setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
         *
         * @param mode - Selection of *AutoCursor* behavior.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAutoCursorMode(mode: AutoCursorModes): this;
        /**
         * Get `AutoCursor` behavior, from a collection of preset options ({@link AutoCursorModes}).
         * @returns Active selection of *AutoCursor* behavior.
         * @public
         */
        getAutoCursorMode(): AutoCursorModes;
        /**
         * Set *ResultTable* formatter. Can be used to specify the information that is displayed, when hovering mouse/pointer
         * over the chart.
         *
         * ```ts
         *  // Example usage
         *  FunnelChart.setCursorResultTableFormatter((builder, chart, slice, relativeValue) => builder
         *      .addRow(slice.getName())
         *      .addRow(slice.getAnimatedValue().toFixed(2))
         *  )
         * ```
         *
         * @param formatter - Function which builds ResultTable content.
         *                      See definition of {@link SlicedChartResultTableFormatter} for supplied formatting information.
         * @returns Object itself
         * @public
         */
        setCursorResultTableFormatter(formatter: SlicedChartResultTableFormatter): this;
        /**
         * This method is used for the adding slices in the funnel chart.
         * @param title - Funnel slice title
         * @param value - funnel slice value
         * @public
         */
        addSlice(title: string, value: number): FunnelSlice;
        /**
         * This method is used for the adding multiple slices in the funnel chart.
         * @param slices - Array of slices
         * @public
         */
        addSlices(slices: {
            name: string;
            value: number;
        }[]): Array<FunnelSlice>;
        /**
         * Get all Slices of Funnel Chart.
         * NOTE: Manual modifications to returned Array can have unforeseen side-effects.
         * Removing or adding Slices is intended to be done using other APIs (FunnelChart.addSlice, Slice.dispose, ...)
         * @returns Array of Slices
         * @public
         */
        getSlices(): FunnelSlice[];
        /**
         * Set Funnel Head Width
         * @param headWidth - Funnel Head Width range from 0 to 100
         * @returns Funnel Chart itself
         * @public
         */
        setHeadWidth(headWidth: number): this;
        /**
         * Get Funnel Head Width
         * @returns number (0 - 100)
         * @public
         */
        getHeadWidth(): number;
        /**
         * Set Funnel Neck Width
         * @param neckWidth - Funnel Neck Width range from 0 to 100
         * @returns Funnel Chart itself
         * @public
         */
        setNeckWidth(neckWidth: number): this;
        /**
         * Get Funnel Neck Width
         * @returns number (0 - 100)
         * @public
         */
        getNeckWidth(): number;
        /**
         * Set gap between Slice / start of label connector, and end of label connector / Label.
         * @param sliceGap - Gap as pixels. Clamped between [0, 20] !
         * @returns Funnel Chart itself
         * @public
         */
        setSliceGap(sliceGap: pixel): this;
        /**
         * Set FunnelSliceMode. Can be used to select between different drawing approaches for Slices.
         *
         * See {@link FunnelSliceModes} for a collection of options.
         * @param sliceMode - FunnelSliceMode
         * @returns Funnel Chart itself
         * @public
         */
        setSliceMode(sliceMode: FunnelSliceModes): this;
        /**
         * Get FunnelSliceMode. Can be used to select between different drawing approaches for Slices.
         *
         * See {@link FunnelSliceModes} for a collection of options.
         * @returns FunnelSliceMode
         * @public
         */
        getFunnelSliceMode(): FunnelSliceModes;
        /**
         * Attach lookup table (LUT) to fill the slices with Colors based on value.
         *
         * The color for the slice would be selected from a specified *LUT*, which contains the information about gradient steps.
         * After setting LUT to undefined all the slices stay colorized, but no further lookup.
         *
         * LUT class stores information about values and its associated colors,
         * * which provides efficient lookup of the color based on provided value
         * * as well as linear and step interpolation between colors.
         *
         * ``` javascript
         * const funnel = lightningChart()
         *  .Funnel( { type: FunnelChartTypes.LabelsOnSides } )
         *  .setLUT( new LUT (steps: [
         *          { value: 10, color: ColorRGBA( 0, 0, 0 ) },
         *          { value: 20, color: ColorRGBA( 30, 255, 0 ) },
         *          { value: 30, color: ColorRGBA( 60, 204, 0 ) },
         *          { value: 40, color: ColorRGBA( 90, 128, 0 ) },
         *          { value: 50, color: ColorRGBA( 255, 0, 0 ) } ) ],
         *      interpolate: true } )
         * ```
         *
         * @param lut - Lookup table
         * @returns Pie itself for fluent interface
         * @public
         */
        setLUT(value: LUT): this;
        /**
         * Set style of Funnel Slices fill.
         * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Funnel will be assigned an incremental index,
         * which will be used to pick its fill style from this Palette.
         *
         * So, for example... We have a Funnel Chart with 5 Slices, and we give it a Palette with only 3 possible values
         * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
         * Note that this means, that the supplied Palette will have to work in a continuous manner!
         *
         * @param sliceFillStylePalette - Palette for FillStyle objects
         * @returns Funnel Chart itself
         * @public
         */
        setSliceFillStyle(sliceFillStylePalette: Palette<FillStyle>): this;
        /**
         * Get style of Funnel Slices fill.
         * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Funnel will be assigned an incremental index,
         * which will be used to pick its fill style from this Palette.
         *
         * So, for example... We have a Funnel Chart with 5 Slices, and we give it a Palette with only 3 possible values
         * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
         * Note that this means, that the supplied Palette will have to work in a continuous manner!
         *
         * @returns Palette<FillStyle>
         * @public
         */
        getSliceFillStyle(): Palette<FillStyle>;
        /**
         * Set style of Funnel Slices Stroke.
         * @param value - LineStyle object or function which creates a new style based on previous
         * @returns Funnel Chart itself
         * @public
         */
        setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of Funnel Slices Stroke.
         * @returns LineStyle object
         * @public
         */
        getSliceStrokeStyle(): LineStyle;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setSliceEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getSliceEffect(): boolean;
        /**
         * Set sorter of Funnels' Slices as a comparator-function.
         *
         * For some commonly needed default implementations, can refer to SliceSorters-collection.
         * @param sliceSorter - SliceSorter - function which sorts Slices of Funnel with JavaScript API: Array.sort.
         * @returns Funnel Chart itself
         * @public
         */
        setSliceSorter(sliceSorter: SliceSorter<FunnelSlice>): this;
        /**
         * Get sorter of Funnels' Slices as a comparator-function.
         * @returns SliceSorter - function which sorts Slices of Funnel with JavaScript API: Array.sort.
         * @public
         */
        getSliceSorter(): SliceSorter<FunnelSlice>;
        /**
         * Set fill style of Funnel Slices Labels.
         * @param value - FillStyle object or function which creates a new style based on previous
         * @returns Funnel Chart itself
         * @public
         */
        setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of Funnel Slice Labels.
         * @returns FillStyle object
         * @public
         */
        getLabelFillStyle(): FillStyle;
        /**
         * Set font of Slice Labels.
         * @param value - FontSettings or mutator function for existing settings
         * @returns Funnel Chart itself
         * @public
         */
        setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get font of Slice Labels.
         * @returns FontSettings
         * @public
         */
        getLabelFont(): FontSettings;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setLabelEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getLabelEffect(): boolean;
        /**
         * Set formatter of Slice Labels.
         *
         * See {@link SliceLabelFormatters} for a collection of default options.
         * @param labelFormatter - SliceLabelFormatter - function which generates text of Labels per Slice.
         * @returns Funnel Chart itself
         * @public
         */
        setLabelFormatter(labelFormatter: SliceLabelFormatter<FunnelSlice>): this;
        /**
         * Get formatter of Slice Labels.
         * @returns SliceLabelFormatter - function which generates text of Labels per Slice.
         * @public
         */
        getLabelFormatter(): SliceLabelFormatter<FunnelSlice>;
        /**
         * Set if slices should be highlighted on mouse hover / touch. Applies to all Slices.
         * @param state - True if Slices should be highlighted on hover, false if not. This applies to all existing Slices and new Slices added.
         * @public
         */
        setSliceHighlightOnHover(state: boolean): this;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         * @public
         */
        dispose(): this;
    }
    /**
     * Interface for readonly configuration of {@link FunnelChart}.
     *
     * Some properties of `FunnelChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart with specified color theme.
     *  const chart = LightningChart.Funnel({
     *      theme: Themes.light,
     *  })
     * ```
     *
     * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
     *
     * For *standalone* `FunnelChart`, more parameters are documented in {@link LightningChart.Funnel}.
     *
     * For *dashboard* `FunnelChart`, more parameters are documented in {@link Dashboard.createFunnelChart}.
     *
     *
     * **Commonly used properties:**
     *
     * - {@link FunnelChartOptions.type}: Specify visual design of *funnel chart* from a collection of options.
     * - {@link FunnelChartOptions.theme}: Specify chart color *theme*.
     * - {@link FunnelChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create funnel chart with default configuration.
     *  const chart = LightningChart.Funnel({})
     * ```
     *
     * ```typescript
     *  // Example 2, create funnel chart with labels inside slices.
     *  const chart = LightningChart.Funnel({
     *      type: FunnelChartTypes.LabelsInsideSlices
     *  })
     * ```
     *
     * ```typescript
     *  // Example 3, create funnel chart with specified color theme.
     *  const chart = LightningChart.Funnel({
     *      theme: Themes.light,
     *  })
     * ```
     * @public
     */
    export declare interface FunnelChartOptions<FunnelChartType extends FunnelChartTypes = FunnelChartTypes, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
        /**
         * Interface for specifying desired "type" of Funnel Chart.
         * This can be used to select different rendering approaches, mainly reflecting how Slice Labels are positioned.
         *
         * Options are located in {@link FunnelChartTypes}-collection. If undefined, will default to {@link FunnelChartWithLabelsOnSides}.
         */
        type?: FunnelChartType;
        /**
         * Builder for the charts' *auto cursor*.
         *
         * For most use cases, it is not recommended to use this, but rather {@link FunnelChart.setAutoCursor} for a more convenient API.
         * @public
         */
        readonly autoCursorBuilder?: AutoCursor2DBuilder<CursorResultTableBackgroundType>;
    }
    /**
     * Collection of {@link FunnelChart} implementations. Each option can have their own visual design, and *API* for customization of it.
     *
     * This must be specified when the *FunnelChart* is created (or default one will be used).
     *
     * Example usage:
     *```javascript
     * // Create a FunnelChart with default type
     * LightningChart.Funnel()
     * // Create a FunnelChart with specified type
     * LightningChart.Funnel({ type: FunnelChartTypes.LabelsInsideSlices })
     * ```
     * @public
     */
    export declare const FunnelChartTypes: {
        /**
         * Funnel Chart type, where Slice Labels are positioned on the either left or right sides of Chart.
         * The side can be set using setLabelSide
         * Labels are connected to their Slices with lines, which can be styled using unique API for this Funnel Chart type.
         */
        LabelsOnSides: typeof FunnelChartWithLabelsOnSides;
        /**
         * Funnel Chart type, where Slice Labels inside the Slices.
         */
        LabelsInsideSlices: typeof FunnelChartWithLabelsInsideSlices;
    };
    /**
     * Available Funnel Chart types
     * @public
     */
    export declare type FunnelChartTypes = typeof FunnelChartTypes[keyof typeof FunnelChartTypes];
    /**
     * {@link FunnelChart} implementation that draws Slice Labels inside the Slices.
     * Works well when Label texts are short and there are not a lot of Slices, as the actual Funnel has more space.
     * @public
     */
    export declare class FunnelChartWithLabelsInsideSlices extends FunnelChart {
        /**
         * Get minimum size of Panel.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns Point
         * @public
         */
        getMinimumSize(): Point | undefined;
    }
    /**
     * {@link FunnelChart} implementation that draws Slice Labels on its left and right sides.
     * Slices and Labels are connected by 'label connector lines'.
     * @public
     */
    export declare class FunnelChartWithLabelsOnSides extends FunnelChart {
        /**
         * Set style of Label connector lines.
         * @param labelConnectorStyle - LineStyle object
         * @returns Funnel Chart itself
         * @public
         */
        setLabelConnectorStyle(labelConnectorStyle: LineStyle): this;
        /**
         * Get style of Label connector lines.
         * @returns LineStyle object
         * @public
         */
        getLabelConnectorStyle(): LineStyle;
        /**
         * Set gap between Slice / start of label connector, and end of label connector / Label.
         * @param labelConnectorGap - Gap as pixels
         * @returns Funnel Chart itself
         * @public
         */
        setLabelConnectorGap(labelConnectorGap: pixel): this;
        /**
         * Get gap between Slice / start of label connector, and end of label connector / Label.
         * @returns Gap as pixels
         * @public
         */
        getLabelConnectorGap(): number;
        /**
         * Set the side where label should display
         * @param labelSide - Left /Right
         * @returns Funnel Chart itself
         * @public
         */
        setLabelSide(labelSide: FunnelLabelSide): this;
        /**
         * Get the side where label shown
         * @returns The label side
         * @public
         */
        getLabelSide(): FunnelLabelSide;
        /**
         * Get minimum size of Panel.
         * Depending on the type of class this value might be automatically computed to fit different elements.
         * @returns Point minimum size or undefined if unimplemented
         * @public
         */
        getMinimumSize(): Point | undefined;
    }
    /**
     * Options for selecting side of labels in a {@link FunnelChartWithLabelsOnSides}.
     *
     * Use with {@link FunnelChartWithLabelsOnSides.setLabelSide}
     * @public
     */
    export declare enum FunnelLabelSide {
        /**
         * Label Side  - Right
         */
        Right = 0,
        /**
         * Label Side  - Left
         */
        Left = 1
    }
    /**
     * Interface that can be used to define {@link FunnelChart} configurations, when inside a {@link Dashboard}, that can't be changed after creation.
     *
     *  Example usage:
     *```javascript
     * // Funnel Chart with default type
     * undefined
     * // Funnel Chart with specified type
     * { funnelOptions: { type: FunnelChartTypes.LabelsOnSides } }
     * ```
     * @public
     */
    export declare interface FunnelOptions<FunnelChartType extends FunnelChartTypes = FunnelChartTypes> extends DashboardCellOptions, FunnelChartOptions<FunnelChartType> {
    }
    /**
     * Class that represents a single Slice of a Funnel Chart.
     * It is given to users when a Slice is added.
     * @public
     */
    export declare abstract class FunnelSlice extends Slice {
        /**
         * Set value of Slice.
         * @param value - Numeric value
         * @returns Slice itself
         * @public
         */
        abstract setValue(value: number): this;
        /**
         * Get value of Slice.
         * @returns Numeric value
         * @public
         */
        abstract getValue(): number;
    }
    /**
     * Enum for selecting different drawing approaches for {@link FunnelChart}.
     *
     * Use with {@link FunnelChart.setSliceMode}
     * @public
     */
    export declare enum FunnelSliceModes {
        /**
         * Slices **height** represents its relative value inside the Funnel Chart.
         */
        VariableHeight = 0,
        /**
         * Slices **width** represents its relative value inside the Funnel Chart.
         */
        VariableWidth = 1
    }
    /**
     * Event handler for gauge angle interval changed
     * @param obj - Object
     * @param previous - Previous angle interval of the Gauge
     * @param current - Current angle interval of the Gauge
     * @public
     */
    export declare type GaugeAngleIntervalEventHandler<T> = (obj: T, previous: AngleInterval, current: AngleInterval) => void;
    /**
     * Abstract base class for *Gauge Charts*.
     * Gauge charts indicate where your data point(s) falls over a particular range.
     * This chart type is often used in executive dashboard reports to show key business indicators.
     *
     * There are multiple implementations of *GaugeChart*, each with their own visual design and *API* for customizing it.
     * List of selectable options can be found in: {@link GaugeChartTypes}
     * @public
     */
    export declare abstract class GaugeChart<PublicSlice extends GaugeSlice = GaugeSlice, InternalSlice extends GaugeSlice = GaugeSlice> extends Chart {
        /**
         * Set lookup table.
         *
         * Example usage:
         *```javascript
         * // Gauge slice color depending on value
         * SolidGauge.setLUT(new LUT ( { steps: [ { value: 0, color: ColorRGBA( 0, 0, 0 ) },
         *  { value: 500, color: ColorRGBA( 12, 213, 87 ) } ],
         *  interpolate: true })
         * ```
         * @param lut - Lookup table |
         * @returns Gauge itself for fluent interface
         * @public
         */
        abstract setLUT(lut?: LUT): this;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns Object itself for fluent interface
         * @public
         */
        dispose(): this;
    }
    /**
     * Interface for readonly configuration of [GaugeChart](../classes/gaugechart.html).
     *
     * Some properties of `GaugeChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example, create chart with specified color theme.
     *  const chart = LightningChart.Gauge({
     *      theme: Themes.light,
     *  })
     * ```
     *
     * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
     *
     * For *standalone* `GaugeChart`, more parameters are documented in {@link LightningChart.Gauge}.
     *
     * For *dashboard* `GaugeChart`, more parameters are documented in {@link Dashboard.createGaugeChart}.
     *
     *
     * **Commonly used properties:**
     *
     * - {@link GaugeChartOptions.type}: Specify type of *gauge chart*.
     * - {@link GaugeChartOptions.theme}: Specify chart color *theme*.
     * - {@link GaugeChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create chart with default configuration.
     *  const chart = LightningChart.Gauge({})
     * ```
     *
     * ```typescript
     *  // Example 2, create chart with specified color theme.
     *  const chart = LightningChart.Gauge({
     *      theme: Themes.light,
     *  })
     * ```
     * @public
     */
    export declare interface GaugeChartOptions<GaugeChartType extends GaugeChartTypes> extends CommonChartOptions {
        /**
         * Interface for specifying desired "type" of Gauge Chart.
         * This can be used to select different gauge types.
         *
         * **Note, at this time, there is only a single type available, leaving this API effectively unusable.**
         *
         * Options are located in {@link GaugeChartTypes} collection. If undefined, will default to Solid.
         */
        type?: GaugeChartType;
    }
    /**
     * Collection of {@link GaugeChart} implementations. Each option can have their own visual design, and *API* for customization of it.
     *
     * **Note, at this time, there is only a single type available, leaving this API effectively unusable.**
     *
     * This must be specified when the {@link GaugeChart} is created (or default one will be used).
     *
     * Example usage:
     *```javascript
     * // Create a GaugeChart with specified type
     * LightningChart.Gauge({ type: GaugeChartTypes.Solid })
     * ```
     * @public
     */
    export declare const GaugeChartTypes: {
        /**
         * Solid Gauge Chart type, which contains a single slice represents a value within the interval.
         */
        Solid: typeof SolidGauge;
    };
    /**
     * @public
     */
    export declare type GaugeChartTypes = typeof GaugeChartTypes[keyof typeof GaugeChartTypes];
    /**
     * Interface that can be used to define {@link GaugeChart} configurations, when inside a {@link Dashboard}, that can't be changed after creation.
     *
     *  Example usage:
     *```javascript
     * // Gauge Chart* with default type
     * undefined
     * // Gauge Chart* with specified type
     * { gaugeOptions: { **type:** *GaugeChartTypes*.Solid } }
     * ```
     * @public
     */
    export declare interface GaugeOptions<GaugeChartType extends GaugeChartTypes> extends DashboardCellOptions, GaugeChartOptions<GaugeChartType> {
    }
    /**
     * Abstract class of Gauge slice.
     * The slice can be represented as a single or multiples shapes.
     * @public
     */
    export declare abstract class GaugeSlice extends Slice {
        /**
         * Set scale interval.
         * @param start - Start scale value
         * @param end - End scale value
         * @returns Slice for fluent interface
         * @public
         */
        abstract setInterval(start: number, end: number): this;
        /**
         * Set font of interval labels.
         *
         * Example usage:
         *```javascript
         * // Specified FontSettings
         * GaugeSlice.setIntervalLabelsFont(new FontSettings({ size: 24, style: 'italic' }))
         * // Set to bold
         * GaugeSlice.setIntervalLabelsFont((fontSettings) => fontSettings.setWeight('bold'))
         * ```
         *
         * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
         * @returns Chart itself
         * @public
         */
        abstract setIntervalLabelsFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get font of gauge interval labels.
         * @returns FontSettings object for gauge interval labels.
         * @public
         */
        abstract getIntervalLabelsFont(): FontSettings;
        /**
         * Set fill style of interval labels.
         *
         * ```ts
         *  // Example, red interval labels
         *  GaugeSlice.setIntervalLabelsFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
         * @returns Object itself
         * @public
         */
        abstract setIntervalLabelsFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of gauge interval labels.
         * @returns FillStyle object for gauge interval labels.
         * @public
         */
        abstract getIntervalLabelsFillStyle(): FillStyle;
        /**
         * Set interval labels visibility enabled or disabled.
         * @param state - True - labels are enabled, otherwise - disabled.
         * @returns Slice itself for fluent interface.
         * @public
         */
        abstract setIntervalLabelsVisible(state: boolean): this;
        /**
         * Get interval labels visibility state.
         * @returns True - labels are enabled, otherwise - disabled.
         * @public
         */
        abstract getIntervalLabelsVisible(): boolean;
        /**
         * Remove subscription from value change event
         * @param token - Event listener
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offValueChange(token: Token): boolean;
        /**
         * Remove subscription from interval change event
         * @param token - Event listener
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offIntervalChange(token: Token): boolean;
        /**
         * Attach object to an legendBox entry
         * @param entry - Object which has to be attached
         * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
         *                          when its respective Entry is clicked.
         * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
         * @returns Series itself for fluent interface
         * @public
         */
        attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
        /**
         * Method styles an attached entry according to Slice itself.
         * @public
         */
        protected styleAttachedEntry(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): void;
    }
    /**
     * Abstract super class for 2D/3D Axis implementations.
     * @public
     */
    export declare abstract class GenericAxis<ScaleType extends AxisScale, StrategyType extends AbstractAxisStrategy, TickType extends _AbstractAxisTick, TickPlottingVariables extends _AbstractTickPlottingVariables, TickSpecificPlottingVariables> implements AxisState, Hideable, HideableEvents {
        /**
         * @returns Axis title string
         * @public
         */
        getTitle(): string;
        /**
         * Specifies an Axis title string
         * @param title - Axis title as a string
         * @returns Axis itself for fluent interface
         * @public
         */
        setTitle(title: string): this;
        /**
         * @returns Axis title fillstyle
         * @public
         */
        getTitleFillStyle(): FillStyle;
        /**
         * Specifies Axis title FillStyle
         *
         * ```ts
         *  // Example, set title color
         *  Axis.setTitleFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * - To learn more of fill style configurations, see {@link FillStyle}.
         * @param fillStyle - FillStyle of Axis title or mutator to modify existing one
         * @returns Axis itself for fluent interface
         * @public
         */
        setTitleFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get font of axis labels.
         * @returns FontSettings
         * @public
         */
        getTitleFont(): FontSettings;
        /**
         * Set font of Axis title.
         *
         * ```ts
         *  // Example, set font size
         *  Axis.setTitleFont((font) => font.setSize(10))
         * ```
         *
         * - To learn more of font configurations, see {@link FontSettings}.
         *
         * @param value - FontSettings or mutator function for existing settings
         * @returns Object itself
         * @public
         */
        setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Set rotation of Axis title.
         * @param value - Rotation in degrees
         * @returns Object itself
         * @public
         */
        setTitleRotation(value: number): this;
        /**
         * Get rotation of Axis title.
         * @returns Rotation in degrees
         * @public
         */
        getTitleRotation(): number;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setTitleEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getTitleEffect(): boolean;
        /**
         * Set axis interval.
         *
         * Examples:
         *
         * ```ts
         *  // Set interval start and end.
         *  Axis.setInterval({ start: 0, end: 5000 })
         * ```
         *
         * ```ts
         *  // Set interval end only.
         *  Axis.setInterval({ end: 5000 })
         * ```
         *
         * ```ts
         *  // Set interval but don't stop the axis from scrolling
         *  Axis.setInterval({ start: 0, end: 5000, stopAxisAfter: false })
         * ```
         *
         * ```ts
         *  // Set interval with 2000 milliseconds long animation
         *  Axis.setInterval({ start: 0, end: 5000, animate: 2000 })
         * ```
         *
         * @param   opts -  Parameters for axis interval.
         * @returns Object itself for fluent interface
         * @public
         */
        setInterval(opts: AxisIntervalConfiguration): this;
        /**
         * Get the currently applied axis scale interval.
         * @returns Object containing the current start and end of Axis.
         * @public
         */
        getInterval(): AxisInterval;
        /**
         * Set Axis stopped or not.
         *
         * When an Axis is stopped it temporarily prevents the active {@link AxisScrollStrategy | scroll strategy} from changing the Axis interval.
         *
         * Axis can be stopped programmatically using this method, and also by different built in interactions, such as panning/zooming.
         *
         * ```ts
         *  // Example, stop Axis scrolling / fitting.
         *  Axis.setStopped(true)
         * ```
         * @param stopped - Axis stopped
         * @returns         Object itself
         * @public
         */
        setStopped(stopped: boolean): this;
        /**
         * Get Axis stopped or not.
         *
         * When an Axis is stopped it temporarily prevents the active {@link AxisScrollStrategy | scroll strategy} from changing the Axis interval.
         *
         * Axis can be stopped programmatically using this method, and also by different built in interactions, such as panning/zooming.
         *
         * @returns         Axis stopped
         * @public
         */
        getStopped(): boolean;
        /**
         * Register new event listener to event when Axis is stopped or released.
         *
         * This event is triggered when `Axis.setStopped` method is used (and state actually changes), or the Axis is stopped/released by a built-in user interaction.
         *
         * ```ts
         *  // Example, track when Axis is stopped or released.
         *  const token = Axis.onStoppedStateChanged((_, isStopped) => {
         *      console.log({isStopped})
         *  })
         * ```
         *
         * @param listener - Event listener that is called when the event triggers.
         * @returns         Token of event subscription which can be used to remove the event listener using {@link offStoppedStateChanged} method.
         * @public
         */
        onStoppedStateChanged(listener: (obj: this, isStopped: boolean) => unknown): Token;
        /**
         * Remove event listener from event when Axis is stopped or released.
         *
         * This event is triggered when `Axis.setStopped` method is used (and state actually changes), or the Axis is stopped/released by a built-in user interaction.
         *
         * ```ts
         *  // Example, attach and remove event handler.
         *  const token = Axis.onStoppedStateChanged((_, isStopped) => {})
         *
         *  Axis.offStoppedStateChanged(token)
         * ```
         *
         * @public
         */
        offStoppedStateChanged(token: Token): boolean;
        /**
         * Fit axis view to attached series.
         * @param animate - Boolean for animation enabled, or number for animation duration in milliseconds
         * @param stopAxisAfter - If true, stops Axis after fitting
         * @public
         */
        fit(animate?: number | boolean, stopAxisAfter?: boolean): this;
        /**
         * Specify *ScrollStrategy* of the *Axis*. This decides where the *Axis* scrolls based on current view and series boundaries.
         * @param scrollStrategy - *AxisScrollStrategy* or undefined to disable automatic scrolling.
         *                          See {@link AxisScrollStrategies} for all options.
         * @returns Object itself for fluent interface.
         * @public
         */
        setScrollStrategy(scrollStrategy?: AxisScrollStrategy): this;
        /**
         * @returns Current *AxisScrollStrategy*
         * @public
         */
        getScrollStrategy(): AxisScrollStrategy | undefined;
        /**
         * Specifies scroll animation.
         * @param enabled - Boolean flag for whether scrolling should be animated or not.
         * @public
         */
        setAnimationScroll(enabled: boolean | undefined): this;
        /**
         * Specifies zoom animation to use.
         *
         * Example usage:
         *
         * | Desired result              | Argument                                           | Parameters                                                                                                                            |
         * | :-------------------------  | :------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------ |
         * | Change animation            | `setAnimationZoom(AnimationEasings.easeOut, 500)`  | First parameter defines the easing to use for the animation. Second parameter is optional, and defines the duration for the animation |
         * | Disable zooming animations  | `axis.setAnimationZoom(undefined)`                 | Passing **undefined** as the parameter will disable the zooming animations for the Axis.                                              |
         *
         * @param easing - Easing of animation. Undefined disables zoom animations. See 'common/animator.Easings' for defaults
         * @param duration - Optional default duration for zooming animations in milliseconds
         * @public
         */
        setAnimationZoom(easing: AnimationEasing | undefined, duration?: number): this;
        /**
         *  Disable/Enable all animations of the Chart.
         * @param animationsEnabled - Boolean value to enable/disable animations.
         * @returns Axis itself for fluent interface.
         * @public
         */
        setAnimationsEnabled(animationsEnabled: boolean): this;
        /**
         * Get animations disable/enable state.
         * @returns Animations default state.
         * @public
         */
        getAnimationsEnabled(): boolean;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         * @public
         */
        setVisible(state: boolean): this;
        /**
         * Get element visibility.
         *
         * @returns `true` when element is set to be visible and `false` otherwise.
         * @public
         */
        getVisible(): boolean;
        /**
         * Subscribe to on scale change event
         *
         * The onIntervalChange event triggers on change of the interval of an Axis
         * and accept a callback function with 3 parameters that return axis itself, start and end values of the Axis
         *
         * **Example usage**:
         *
         * ```javascript
         * Axis.onIntervalChange((axis, start, end) => {
         *     console.log(`start value: ${start}, end value : ${end}`);
         *   }
         * )
         * ```
         * @param listener - Event listener
         * @param axis - Axis itself
         * @param start - Scale start value
         * @param end - Scale end value
         * @returns Token that is used to unsubscribe from the event
         * @public
         */
        onIntervalChange(listener: (axis: this, start: number, end: number) => void): Token;
        /**
         * Remove subscription from scale change event
         * @param token - Event listener
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offIntervalChange(token: Token): boolean;
        /**
         * Register new event listener to `visibleStateChanged` event.
         *
         * @param listener - Event listener for `visibleStateChanged`
         * @public
         */
        onVisibleStateChanged(listener: VisibleStateChangedHandler<this>): Token;
        /**
         * Remove event listener from `visibleStateChanged`
         * @public
         */
        offVisibleStateChanged(token: Token): boolean;
        /**
         * Enable / disable all interactions of Axis.
         * @param enabled - Interactions enabled or not.
         * @returns Object itself for fluent interface.
         * @public
         */
        abstract setMouseInteractions(enabled: boolean): this;
        /**
         * Format a value along axis to string. Behavior depends on the Axis' TickStrategy.
         * Eq. A DateTime-Axis will interpret 'value' as a Date.
         * @param value - Value along axis
         * @returns Value formated to string
         * @public
         */
        formatValue: (value: number) => string;
    }
    /**
     * @public
     */
    export declare interface GettableText {
        /**
         * Get the text of the entire shape.
         * @returns The entire text string.
         * @public
         */
        getText(): string;
    }
    /**
     * Type definition of an Glow Effect Configuration_.
     *
     * A theme can specify an Effect to add extra visual oomph to chart applications, like Glow effects around data or other components.
     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
     *
     * Theme effect is configured with {@link Theme.effect} property.
     * @public
     */
    export declare class GlowEffect extends GlowEffectRecord implements StylePropFuncs<ThisType<GlowEffect>, Omit<GlowEffectProperties, 'type'>> {
        /**
         * Constructor for a `GlowEffect` object.
         *
         * All parameters are optional, and when omitted fallback to default values.
         *
         * ```ts
         *  // Example, define an GlowEffect object
         *  const glowEffect = new GlowEffect({
         *      color: ColorRGBA(100, 0, 0, 150),
         *      blur: 5,
         *  })
         * ```
         *
         * For details of the available properties, see {@link GlowEffectProperties}
         *
         * @public
         */
        constructor(props?: Partial<GlowEffectProperties>);
        /**
         * Construct a new GlowEffect object based on this one, but with modified spread distance.
         *
         * ```ts
         *  // Example
         *  const glow2 = glow1.setSpread(10)
         * ```
         * @param spread - Spread distance as pixels. Max value is `10`.
         * @returns New GlowEffect object
         * @public
         */
        setSpread(spread: number | ImmutableMutator<number>): this;
        /**
         * Get Glow spread distance as pixels.
         * @returns     Spread distance as pixels.
         * @public
         */
        getSpread(): number;
        /**
         * Construct a new GlowEffect object based on this one, but with modified blur distance.
         *
         * ```ts
         *  // Example
         *  const glow2 = glow1.setBlur(10)
         * ```
         * @param blur - Blur distance as pixels. Max value is `10`.
         * @returns New GlowEffect object
         * @public
         */
        setBlur(blur: number | ImmutableMutator<number>): this;
        /**
         * Get Glow blur distance as pixels.
         * @returns     Blur distance as pixels.
         * @public
         */
        getBlur(): number;
        /**
         * Construct a new GlowEffect object based on this one, but with modified color.
         *
         * ```ts
         *  // Example
         *  const glow2 = glow1.setColor(ColorRGBA(255, 0, 0, 100))
         * ```
         * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
         * @returns New GlowEffect object
         * @public
         */
        setColor(color: Color | ImmutableMutator<Color>): this;
        /**
         * Get Glow color.
         * @returns     Color.
         * @public
         */
        getColor(): Color;
        /**
         * Construct a new GlowEffect object based on this one, but with modified offset distance.
         *
         * ```ts
         *  // Example
         *  const glow2 = glow1.setOffset({ x: 10, y: -10 })
         * ```
         * @param offset - Offset distance as pixels.
         * @returns New GlowEffect object
         * @public
         */
        setOffset(offset: Point | ImmutableMutator<Point>): this;
        /**
         * Get Glow offset distance as pixels.
         * @returns     Offset distance as pixels.
         * @public
         */
        getOffset(): Point;
    }
    /**
     * Interface of all properties of [[GlowEffect]].
     * @public
     */
    declare interface GlowEffectProperties {
        type: 'glow';
        /**
         * Spread distance as pixels.
         *
         * Max value `10`.
         * @public
         */
        spread: number;
        /**
         * Blur distance as pixels.
         *
         * Max value `10`.
         * @public
         */
        blur: number;
        /**
         * Glow color.
         *
         * Assign using {@link ColorRGBA} or any other color factory.
         * Glow intensity can be controlled with color alpha channel.
         *
         * ```ts
         *  // Example, red glow color.
         *  color: ColorRGBA(255, 0, 0, 255)
         * ```
         * @public
         */
        color: Color;
        /**
         * Offset as pixels.
         * @public
         */
        offset: Point;
    }
    /**
     * Constructor for a Record of GlowEffect.
     * @public
     */
    declare const GlowEffectRecord: Record_2.Factory<GlowEffectProperties>;
    /**
     * Common functions for any gradient implementation.
     * @public
     */
    export declare interface Gradient {
        /**
         * Set color stops for the gradient.
         * @param stops - Color Stops
         */
        setColorStops(stops: ColorStop[]): void;
        /**
         * Get current color stops from the gradient.
         */
        getColorStops(): ColorStop[];
    }
    /**
     * Gradient extents
     * @public
     */
    export declare enum GradientExtent {
        closestSide = "closest-side",
        closestCorner = "closest-corner",
        farthestSide = "farthest-side",
        farthestCorner = "farthest-corner"
    }
    /**
     * Gradient Shapes
     * @public
     */
    export declare enum GradientShape {
        circle = "circle",
        ellipse = "ellipse"
    }
    /**
     * Abstract Series class for visualizing a *Heatmap Grid* with static columns and rows count.
     *
     * Implementations:
     * - {@link HeatmapGridSeriesIntensityValues}
     * @public
     */
    export declare abstract class HeatmapGridSeries extends SeriesXY<CursorPoint, LinearScaleXY> implements AttachableWithLUT {
        /**
         * Clear all previous data pushed to the series.
         * @returns Object itself for fluent interface.
         * @public
         */
        clear(): this;
        /**
         * Set style of wireframe.
         *
         * ```js
         *  // Example, disable wireframe.
         *  heatmapSeries.setWireframeStyle(emptyLine)
         * ```
         *
         * ```js
         *  // Example, set wireframe style.
         *  heatmapSeries.setWireframeStyle(new SolidLine({
         *      thickness: 1,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0, 255) })
         *  }))
         * ```
         *
         * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
         * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
         * @returns Series itself for fluent interface.
         * @public
         */
        setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of wireframe.
         *
         * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
         * @returns LineStyle.
         * @public
         */
        getWireframeStyle(): LineStyle;
        /**
         * Set cursor interpolation enabled.
         *
         * If enabled, cursors will display bilinearly interpolated *intensity* values from the four closest heatmap cells
         * to the mouse pointer. Otherwise, cursor will display the nearest actual data point supplied by user.
         *
         * @param state - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setCursorInterpolationEnabled(state: boolean): this;
        /**
         * Get if cursor interpolates solved data-points along series by default.
         * @returns Boolean flag
         * @public
         */
        getCursorInterpolationEnabled(): boolean;
        /**
         * Configure whether *cursors* should pick on this particular *series* or not.
         *
         * ```typescript
         *  // Example, prevent chart auto cursor from snapping to a series.
         *  LineSeries.setCursorEnabled(false)
         * ```
         *
         * **Related API:**
         *
         * - {@link setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
         * This method is not available for all *series* types.
         * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
         * @public
         */
        setCursorEnabled(state: boolean): this;
        /**
         * Set heatmap intensity interpolation mode.
         *
         * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
         *
         * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
         *
         * @param interpolationMode - Heatmap intensity interpolation mode selection.
         * @returns Object itself for fluent interface.
         * @public
         */
        setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
        /**
         * Get heatmap intensity interpolation mode.
         * @returns Heatmap intensity interpolation mode selection.
         * @public
         */
        getIntensityInterpolation(): IntensityInterpolationMode;
        /**
         * Attach object to an legendBox entry
         * @param entry - Object which has to be attached
         * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
         *                          when its respective Entry is clicked.
         * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
         * @returns Series itself for fluent interface
         * @public
         */
        attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
        /**
         * Method for solving the nearest data point from a given coordinate on screen.
         *
         * ```ts
         *  // Example usage, from mouse move event.
         *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
         *      const result = LineSeries.solveNearestFromScreen(event)
         *  })
         * ```
         *
         * ```ts
         *  // Example usage, arbitrary coordinate on client coordinate system.
         *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
         * ```
         *
         * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
         *
         * @param   location -  Location in HTML client coordinates.
         * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
         * @public
         */
        solveNearestFromScreen(location: CoordinateClient, interpolate?: boolean): undefined | CursorPoint;
        /**
         * @public
         * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
         */
        solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
        /**
         * @returns Max X value of the series
         * @public
         */
        getXMax(): number | undefined;
        /**
         * @returns Min X value of the series
         * @public
         */
        getXMin(): number | undefined;
        /**
         * @returns Max Y value of the series
         * @public
         */
        getYMax(): number | undefined;
        /**
         * @returns Min Y value of the series
         * @public
         */
        getYMin(): number | undefined;
    }
    /**
     * Series for visualizing a *Intensity Heatmap Grid* with a static column and grid count. Has API for fast modification of cell values.
     *
     * `HeatmapGridSeriesIntensityValues` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
     *
     * - Heatmap Chart with 1 million data points (`1000x1000`) is cold started in ~0.3 seconds.
     * - Heatmap Chart with 1 million data points (`1000x1000`) is re-populated (change data set) in ~0.050 seconds.
     * - Heatmap Chart with 16 million data points (`4000x4000`) is cold started in ~2.0 seconds.
     * - Heatmap Chart with 16 million data points (`4000x4000`) is re-populated (change data set) in ~0.5 seconds.
     *
     * `HeatmapGridSeriesIntensityValues` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
     * If by increasing the amount of `columns` and `rows` you encounter suddenly weak performance, it is likely that there is not enough RAM memory available.
     *
     * Created with {@link ChartXY.addHeatmapGridSeries}.
     *
     * Frequently used API:
     * - Set intensity data {@link invalidateIntensityValues}
     * - Set fill style {@link setFillStyle}
     * - Set wireframe style {@link setWireframeStyle}
     * - Set intensity interpolation {@link setIntensityInterpolation}
     * - Format auto cursor {@link setCursorResultTableFormatter}
     * @public
     */
    export declare class HeatmapGridSeriesIntensityValues extends HeatmapGridSeries {
        /**
         * Invalidate range of heatmap intensity values starting from first column and row, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link HeatmapGridSeriesIntensityValues.setFillStyle}).
         *
         * ```js
         *  // Example, 3x3 grid full invalidation.
         *  const heatmapGridSeries = ChartXY.addHeatmapGridSeries({
         *      dataOrder: 'columns',
         *      columns: 3,
         *      rows: 3
         *  })
         *
         *  heatmapGridSeries.invalidateIntensityValues([
         *      // Column 1 intensity values.
         *      [0, 0, 0],
         *      // Column 2 intensity values.
         *      [1, 1, 1],
         *      // Column 3 intensity values.
         *      [0, 2, 0],
         *  ])
         * ```
         *
         * Data interpretation basis is defined by {@link HeatmapGridSeriesOptions.dataOrder} property from when the series was created.
         * Can be either list of *columns*, or list of *rows*.
         *
         * `invalidateIntensityValues` can trigger warnings when used controversially.
         * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
         *
         * @param value - Matrix containing intensity values for each data slot of the grid.
         * @returns Object itself for fluent interface.
         * @public
         */
        invalidateIntensityValues(value: number[][]): this;
        /**
         * Invalidate a partial range of heatmap intensity values, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link HeatmapGridSeriesIntensityValues.setFillStyle}).
         *
         * ```js
         *  // Example, 100x10 grid invalidate partial section of grid.
         *
         *  const heatmapGridSeries = ChartXY.addHeatmapGridSeries({
         *      dataOrder: 'columns',
         *      columns: 100,
         *      rows: 10
         *  })
         *
         *  heatmapGridSeries.invalidateIntensityValues({
         *      // Index of first invalidated column.
         *      iColumn: 50,
         *      // Index of first invalidated row.
         *      iRow: 2,
         *      // Intensity values matrix. It's dimensions imply the amount of invalidated columns & rows.
         *      values: [
         *          // 1st invalidated column intensity values.
         *          [1, 1, 1, 1, 1],
         *          // 2nd invalidated column intensity values.
         *          [2, 2, 2, 2, 2],
         *          // 3rd invalidated column intensity values.
         *          [1, 0, 0, 0, 1],
         *          // 4th invalidated column intensity values.
         *          [0, 1, 0, 1, 0],
         *          // 5th invalidated column intensity values.
         *          [0, 0, 1, 0, 0],
         *      ],
         *  })
         * ```
         *
         * `invalidateIntensityValues` can trigger warnings when used controversially.
         * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
         *
         * @param value - Partial invalidation information, where `values` is an intensity value matrix, `iColumn` the first affected column and `iRow` the first affected row.
         * @returns Object itself for fluent interface.
         * @public
         */
        invalidateIntensityValues(value: {
            iColumn: number;
            iRow: number;
            values: number[][];
        }): this;
        /**
         * Set fill style of heatmap series.
         *
         * **Supported fill styles:**
         *
         * {@link PalettedFill}:
         *
         * Colors heatmap fill by looking color up from {@link LUT} based on heatmap *intensity values*.
         *
         * ```js
         *  // Example, color look up by intensity values.
         *  heatmapSeries.setFillStyle(
         *      new PalettedFill({
         *          lut: new LUT({
         *              steps: [
         *                  { value: 0, color: ColorCSS('red') },
         *                  { value: 20, color: ColorCSS('blue') },
         *              ],
         *              interpolate: true,
         *          }),
         *      }),
         *  )
         * ```
         *
         * Assign *intensity values* with {@link invalidateIntensityValues}.
         *
         * Note, Heatmap doesn't currently support {@link LUT.color} (fallback color).
         *
         * {@link SolidFill}:
         *
         * Solid color for all heatmap cells. Supported for debugging purposes mainly.
         *
         * {@link emptyFill}:
         *
         * Disables heatmap fill.
         *
         * ```js
         *  // Example, hide heatmap fill and show wireframe.
         *  heatmapSeries
         *      .setFillStyle(emptyFill)
         *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * @param value - FillStyle object or function which modifies current value.
         * @returns Object itself for fluent interface.
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of series.
         * @returns FillStyle.
         * @public
         */
        getFillStyle(): FillStyle;
        /**
         * Method for customizing contents of ResultTables when pointing at this Series.
         *
         * ```js
         *  HeatmapGridSeries.setCursorResultTableFormatter((builder, series, dataPoint) =>
         *      builder
         *          .addRow('Pointing at')
         *          .addRow(`${dataPoint.x.toFixed(1)}, ${dataPoint.y.toFixed(1)}`)
         *          .addRow(`= ${dataPoint.intensity.toFixed(1)}`),
         *  )
         * ```
         *
         * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
         *
         * @param formatter - Function which builds ResultTable content.
         *                      See definition of {@link HeatmapSeriesFormatterIntensity} for supplied formatting information.
         * @returns Object itself
         * @public
         */
        setCursorResultTableFormatter(formatter: HeatmapSeriesFormatterIntensity): this;
        /**
         * Get ResultTable Formatter.
         * @returns Function which builds ResultTable content for this series type.
         * @public
         */
        getCursorResultTableFormatter(): HeatmapSeriesFormatterIntensity<this>;
    }
    /**
     * Interface describing readonly configurations of a {@link HeatmapGridSeries}.
     *
     * **Required properties:**
     * - {@link columns}
     * - {@link rows}
     *
     * **Optional properties:**
     * - {@link start}
     * - {@link step}
     * - {@link dataOrder}
     * - {@link heatmapDataType}
     * @public
     */
    export declare interface HeatmapGridSeriesOptions<DataType extends 'intensity' = 'intensity'> extends SeriesOptionsXY {
        /**
         * Specify how to interpret grid matrix values supplied by user.
         *
         * `'columns'` -\> Supply lists of "columns"
         *
         * ```typescript
         *  const intensityValues = [
         *      [
         *          0, // Intensity value column = 0, row = 0
         *          0, // Intensity value column = 0, row = 1
         *          0, // Intensity value column = 0, row = n
         *      ],
         *      [
         *          0, // Intensity value column = 1, row = 0
         *          0, // Intensity value column = 1, row = 1
         *          0, // Intensity value column = 1, row = n
         *      ],
         *  ]
         * ```
         *
         * `'rows'` -\> Supply lists of "rows"
         *
         * ```typescript
         *  const intensityValues = [
         *      [
         *          0, // Intensity value row = 0, column = 0
         *          0, // Intensity value row = 0, column = 1
         *          0, // Intensity value row = 0, column = n
         *      ],
         *      [
         *          0, // Intensity value row = 1, column = 0
         *          0, // Intensity value row = 1, column = 1
         *          0, // Intensity value row = 1, column = n
         *      ],
         *  ]
         * ```
         *
         * Defaults to `'columns'`.
         */
        dataOrder?: 'columns' | 'rows';
        /**
         * Selection of format in which heatmap values are supplied.
         *
         * `'intensity'` | numeric value that can be colored with an associated color look up table.
         *
         * Defaults to `'intensity'.`
         */
        heatmapDataType?: DataType;
        /**
         * Amount of *columns* (values on X Axis).
         */
        columns: number;
        /**
         * Amount of *rows* (values on Y Axis).
         */
        rows: number;
        /**
         * Start coordinate of Heatmap on its X and Y Axes.
         *
         * Defaults to `{ x: 0, y: 0 }`
         */
        start?: Point;
        /**
         * Step between each consecutive heatmap value on the X and Y Axes.
         *
         * X = columns,
         * Y = rows
         *
         * Defaults to `{ x: 1, y: 1 }`
         */
        step?: Point;
        /**
         * End coordinate of Heatmap on its X and Y Axes.
         *
         * If both are defined, `end` has priority over `step`.
         */
        end?: Point;
    }
    /**
     * Interface that describes an intensity heatmap data point.
     * @public
     */
    export declare interface HeatmapIntensityDataPoint {
        /**
         * Index of column (grid index on X axis).
         */
        readonly column: number;
        /**
         * Index of row (grid index on Y axis).
         */
        readonly row: number;
        /**
         * Intensity value of heatmap cell.
         */
        readonly intensity: number;
        /**
         * X Axis coordinate.
         *
         * If cursor interpolation is disabled, this will be calculated as the center coordinate of the grid cell.
         *
         * If cursor interpolation is enabled, it will snap to closest coordinate of the grid from the solve location (e.g. mouse location).
         */
        readonly x: number;
        /**
         * Y Axis coordinate.
         *
         * If cursor interpolation is disabled, this will be calculated as the center coordinate of the grid cell.
         *
         * If cursor interpolation is enabled, it will snap to closest coordinate of the grid from the solve location (e.g. mouse location).
         */
        readonly y: number;
    }
    /**
     * Abstract Series class for visualizing a *Heatmap Grid*, with API for pushing data in a scrolling manner (append new data on top of existing data).
     *
     * Implementations:
     * - {@link HeatmapScrollingGridSeriesIntensityValues}
     * @public
     */
    export declare abstract class HeatmapScrollingGridSeries extends SeriesXY<CursorPoint, LinearScaleXY> implements SeriesWithDataCleaning, AttachableWithLUT {
        /**
         * Clear all previous data pushed to the series.
         * @returns Object itself for fluent interface.
         * @public
         */
        clear(): this;
        /**
         * Set style of wireframe.
         *
         * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
         *
         * ```js
         *  // Example, disable wireframe.
         *  heatmapSeries.setWireframeStyle(emptyLine)
         * ```
         *
         * ```js
         *  // Example, set wireframe style.
         *  heatmapSeries.setWireframeStyle(new SolidLine({
         *      thickness: 1,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0, 255) })
         *  }))
         * ```
         * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
         * @returns Series itself for fluent interface.
         * @public
         */
        setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of wireframe.
         *
         * Wireframe is a line grid that highlights the edges of each cell of the heatmap.
         * @returns LineStyle.
         * @public
         */
        getWireframeStyle(): LineStyle;
        /**
         * Set heatmap fill pixel interpolation mode.
         *
         * `'disabled'` or `undefined`: Interpolation disabled; all pixels within a grid cell share the same color.
         *
         * `'bilinear'`: Each pixel is colored individually by *bilinear interpolation*.
         * @param interpolationMode - Heatmap fill pixel interpolation mode selection.
         * @returns Object itself for fluent interface.
         * @public
         */
        setPixelInterpolationMode(interpolationMode: IntensityInterpolationMode | undefined): this;
        /**
         * Get heatmap fill pixel interpolation mode.
         * @returns Heatmap fill pixel interpolation mode selection.
         * @public
         */
        getPixelInterpolationMode(): IntensityInterpolationMode;
        /**
         * Set cursor interpolation enabled.
         *
         * If enabled, cursors will display bilinearly interpolated *intensity* values from the four closest heatmap cells
         * to the mouse pointer. Otherwise, cursor will display the nearest actual data point supplied by user.
         *
         * @param state - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setCursorInterpolationEnabled(state: boolean): this;
        /**
         * Get if cursor interpolates solved data-points along series by default.
         * @returns Boolean flag
         * @public
         */
        getCursorInterpolationEnabled(): boolean;
        /**
         * Configure whether *cursors* should pick on this particular *series* or not.
         *
         * ```typescript
         *  // Example, prevent chart auto cursor from snapping to a series.
         *  LineSeries.setCursorEnabled(false)
         * ```
         *
         * **Related API:**
         *
         * - {@link setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
         * This method is not available for all *series* types.
         * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
         * @public
         */
        setCursorEnabled(state: boolean): this;
        /**
         * Disable automatic data cleaning.
         *
         * ```js
         *  // Example syntax, disable data cleaning.
         *  series.setDataCleaning(undefined)
         * ```
         *
         * @param arg - Data cleaning configuration.
         * @returns Object itself for fluent interface.
         * @public
         */
        setDataCleaning(arg: undefined): this;
        /**
         * Enable automatic data cleaning by `minDataPointCount` configuration.
         *
         * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
         *
         * ```js
         *  // Example syntax for specifying minDataPointCount
         *  series.setDataCleaning({ minDataPointCount: 10000 })
         * ```
         *
         * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
         * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
         *
         * ```js
         *  // Example, enable lazy data cleaning of out of view data.
         *  series.setDataCleaning({ minDataPointCount: 1 })
         * ```
         *
         * @param arg - Data cleaning configuration.
         * @returns Object itself for fluent interface.
         * @public
         */
        setDataCleaning(arg: {
            minDataPointCount: number | undefined;
        }): this;
        /**
         * Enable automatic data cleaning by `maxDataPointCount` configuration.
         *
         *Specifying `maxDataPointCount` results in data cleaning always happening **exactly** when total data amount exceeds the supplied threshold.
         *
         * ```js
         *  // Example syntax for specifying maxDataPointCount
         *  series.setDataCleaning({ maxDataPointCount: 10000 })
         * ```
         *
         * `maxDataPointCount` is usually used in memory limited applications to prevent running out of memory.
         *
         * **`maxDataPointCount` is currently only supported by only select series:**
         * - {@link HeatmapScrollingGridSeries}.
         * - {@link OHLCSeries}.
         *
         * If the feature receives good support and usage from the user base, it might be expanded to all series types in a future release.
         *
         * @param arg - Data cleaning configuration.
         * @returns Object itself for fluent interface.
         * @public
         */
        setDataCleaning(arg: {
            maxDataPointCount: number | undefined;
        }): this;
        /**
         * Attach object to an legendBox entry
         * @param entry - Object which has to be attached
         * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
         *                          when its respective Entry is clicked.
         * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
         * @returns Series itself for fluent interface
         * @public
         */
        attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
        /**
         * Method for solving the nearest data point from a given coordinate on screen.
         *
         * ```ts
         *  // Example usage, from mouse move event.
         *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
         *      const result = LineSeries.solveNearestFromScreen(event)
         *  })
         * ```
         *
         * ```ts
         *  // Example usage, arbitrary coordinate on client coordinate system.
         *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
         * ```
         *
         * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
         *
         * @param   location -  Location in HTML client coordinates.
         * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
         * @public
         */
        solveNearestFromScreen(location: CoordinateClient, interpolate?: boolean): undefined | CursorPoint;
        /**
         * @public
         * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
         */
        solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
        /**
         * @returns Max X value of the series
         * @public
         */
        getXMax(): number;
        /**
         * @returns Min X value of the series
         * @public
         */
        getXMin(): number;
        /**
         * @returns Max Y value of the series
         * @public
         */
        getYMax(): number | undefined;
        /**
         * @returns Min Y value of the series
         * @public
         */
        getYMin(): number | undefined;
    }
    /**
     * Series class for visualizing a *Heatmap Grid*, with API for pushing data in a scrolling manner (append new data on top of existing data).
     *
     * `HeatmapScrollingGridSeriesIntensityValues` is optimized for *massive* amounts of data - here are some reference specs on average PC to give an idea:
     *
     * - Scrolling Heatmap Chart with 2 million incoming data points **per second** (`rows: 2048`, 1000 columns/s) runs consistently and smoothly with 60 FPS and no stuttering. CPU usage stays easily below 40%.
     * - Scrolling Heatmap Chart with 8 million incoming data points **per second** (`rows: 4096`, 2000 columns/s) runs consistently and smoothly with 60 FPS and minor stuttering.
     *
     * `HeatmapScrollingGridSeriesIntensityValues` max data amount is entirely restricted by the client hardware RAM and more specifically amount of RAM usable by the context running LightningChart JS.
     * If performance suddenly plummets at some approximate data threshold, then it is likely that there is not enough RAM available.
     * Use data cleaning configuration and suitable Axis intervals to adjust to your hardware limitations.
     *
     * Each cell of the heatmap grid is associated with a *numeric intensity value*, which can be used in conjuction with a Color look up table ({@link LUT}).
     *
     * Created with {@link ChartXY.addHeatmapScrollingGridSeries}.
     *
     * Frequently used API:
     * - Add intensity data {@link addIntensityValues}
     * - Set fill style {@link setFillStyle}
     * - Set wireframe style {@link setWireframeStyle}
     * - Format auto cursor {@link setCursorResultTableFormatter}
     * - Configure automatic data cleaning {@link setDataCleaning}
     * @public
     */
    export declare class HeatmapScrollingGridSeriesIntensityValues extends HeatmapScrollingGridSeries {
        /**
         * Push a Matrix of *intensity values* into the Heatmap grid.
         * Each value describes one cell in the grid.
         *
         * Order of data is selected when creating the series;
         *
         * `scrollDimension: 'columns'` -\>
         *
         * ```typescript
         *  [
         *      [
         *          0, // Intensity value column = 0, row = 0
         *          0, // Intensity value column = 0, row = 1
         *          0, // Intensity value column = 0, row = n
         *      ],
         *      [
         *          0, // Intensity value column = 1, row = 0
         *          0, // Intensity value column = 1, row = 1
         *          0, // Intensity value column = 1, row = n
         *      ],
         *  ]
         * ```
         *
         * `scrollDimension: 'rows'` -\>
         *
         * ```typescript
         *  [
         *      [
         *          0, // Intensity value row = 0, column = 0
         *          0, // Intensity value row = 0, column = 1
         *          0, // Intensity value row = 0, column = n
         *      ],
         *      [
         *          0, // Intensity value row = 1, column = 0
         *          0, // Intensity value row = 1, column = 1
         *          0, // Intensity value row = 1, column = n
         *      ],
         *  ]
         * ```
         *
         * Example usage:
         *
         * ```typescript
         *  // Create x-scrolling intensity heatmap.
         *  const series = ChartXY.addHeatmapScrollingGridSeries({
         *      heatmapDataType: 'intensity',
         *      scrollDimension: 'columns',
         *      resolution: 5,
         *      start: { x: 0, y: 0 },
         *      step: { x: 1, y: 1 },
         *  })
         *
         *  // Push a column into heatmap.
         *  series.addIntensityValues([
         *      [0, 10, 0, 20, 0]
         *  ])
         * ```
         *
         * `invalidateIntensityValues` can trigger warnings when used controversially.
         * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
         *
         * @param intensityValues - Matrix of *intensity values* - Each array represents a column or row, and each number represents a cell in the grid.
         * @returns Object itself for fluent interface.
         * @public
         */
        addIntensityValues(intensityValues: number[][]): this;
        /**
         * Invalidate existing and/or add new intensity values in the Heatmap grid.
         * The location along scrolling dimension is identified by a **sample index**.
         *
         * Sample index `0` would reference the first sample in the heatmap, whereas `1` the second sample.
         * This allows, for example, the modification of previously pushed heatmap samples.
         *
         * This method is also capable of adding new samples into the heatmap, which happens if the sample index exceeds the currently existing sample count
         * (this can be received with {@link getSampleCount} method).
         *
         * If this method is used to push new samples into the heatmap in a manner where **gaps** form between the new samples and previous ones,
         * the gaps are automatically filled by duplicating the previous last heatmap sample!
         *
         * ```ts
         *  // Example, modify last sample pushed to heatmap
         *  heatmapSeries.invalidateIntensityValues({
         *      iSample: heatmapSeries.getSampleCount() - 1,
         *      values: [[0, 0, 0, 0, 0]]
         *  })
         * ```
         *
         * ```ts
         *  // Example, update 5 samples starting at sample index 2
         *  heatmapSeries.invalidateIntensityValues({
         *      iSample: 2,
         *      values: [
         *          [0, 0, 0],
         *          [0, 0, 0],
         *          [0, 0, 0],
         *          [0, 0, 0],
         *          [0, 0, 0],
         *      ]
         *  })
         * ```
         * @param   arg - Object with sample index and intensity values parameters.
         * @returns     Object itself.
         * @public
         */
        invalidateIntensityValues(arg: {
            iSample: number;
            values: number[][];
        }): this;
        /**
         * Get number of samples that have been pushed into the scrolling heatmap series.
         * For empty heatmap this will be `0`.
         * @returns     Number of samples in the heatmap.
         * @public
         */
        getSampleCount(): number;
        /**
         * Set fill style of heatmap series.
         *
         * **Supported fill styles:**
         *
         * `PalettedFill`:
         *
         * Colors heatmap fill by looking color up from {@link LUT} based on heatmap *intensity values*.
         *
         * ```js
         *  // Example, color look up by intensity values.
         *  heatmapSeries.setFillStyle(
         *      new PalettedFill({
         *          lut: new LUT({
         *              steps: [
         *                  { value: 0, color: ColorCSS('red') },
         *                  { value: 20, color: ColorCSS('blue') },
         *              ],
         *              interpolate: true,
         *          }),
         *      }),
         *  )
         * ```
         *
         * Intensity values are defined when data is pushed in with {@link addIntensityValues} method.
         *
         * Note, Heatmap doesn't currently support {@link LUT.color} (fallback color).
         *
         * - `SolidFill`:
         *
         * Solid color for all heatmap cells. Supported for debugging purposes mainly.
         *
         * `emptyFill`:
         *
         * Disables heatmap fill.
         *
         * ```js
         *  // Example, hide heatmap fill and show wireframe.
         *  heatmapSeries
         *      .setFillStyle(emptyFill)
         *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * @param value - FillStyle object or function which modifies current value.
         * @returns Object itself for fluent interface.
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of series.
         * @returns FillStyle.
         * @public
         */
        getFillStyle(): FillStyle;
        /**
         * Method for customizing contents of ResultTables when pointing at this Series.
         *
         * ```js
         *  HeatmapScrollingGridSeries.setCursorResultTableFormatter((builder, series, dataPoint) =>
         *      builder
         *          .addRow('Pointing at')
         *          .addRow(`${dataPoint.x.toFixed(1)}, ${dataPoint.y.toFixed(1)}`)
         *          .addRow(`= ${dataPoint.intensity.toFixed(1)}`),
         *  )
         * ```
         *
         * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
         *
         * @param formatter - Function which builds ResultTable content.
         *                      See definition of {@link HeatmapSeriesFormatterIntensity} for supplied formatting information.
         * @returns Object itself
         * @public
         */
        setCursorResultTableFormatter(formatter: HeatmapSeriesFormatterIntensity): this;
        /**
         * Get ResultTable Formatter.
         * @returns Function which builds ResultTable content for this series type.
         * @public
         */
        getCursorResultTableFormatter(): HeatmapSeriesFormatterIntensity<this>;
    }
    /**
     * Interface describing readonly configurations of a {@link HeatmapScrollingGridSeries}.
     *
     * **Required properties:**
     * - {@link resolution}
     *
     * **Optional properies:**
     * - {@link start}
     * - {@link step}
     * - {@link scrollDimension}
     * - {@link heatmapDataType}
     * @public
     */
    export declare interface HeatmapScrollingGridSeriesOptions<DataType extends 'intensity' = 'intensity'> extends SeriesOptionsXY {
        /**
         * Select scrolling dimension, as well as how to interpret grid matrix values supplied by user.
         *
         * If `columns` is selected, then there will be no limit on how many *columns* can be pushed to the series, but *rows* amount will be static.
         *
         * If `rows` is selected, then there will be no limit on how many *rows* can be pushed to the series, but *columns* amount will be static.
         *
         * Data order:
         *
         * `'columns'` -\> Supply lists of "columns"
         *
         * ```typescript
         *  const intensityValues = [
         *      [
         *          0, // Intensity value column = 0, row = 0
         *          0, // Intensity value column = 0, row = 1
         *          0, // Intensity value column = 0, row = n
         *      ],
         *      [
         *          0, // Intensity value column = 1, row = 0
         *          0, // Intensity value column = 1, row = 1
         *          0, // Intensity value column = 1, row = n
         *      ],
         *  ]
         * ```
         *
         * `'rows'` -\> Supply lists of "rows"
         *
         * ```typescript
         *  const intensityValues = [
         *      [
         *          0, // Intensity value row = 0, column = 0
         *          0, // Intensity value row = 0, column = 1
         *          0, // Intensity value row = 0, column = n
         *      ],
         *      [
         *          0, // Intensity value row = 1, column = 0
         *          0, // Intensity value row = 1, column = 1
         *          0, // Intensity value row = 1, column = n
         *      ],
         *  ]
         * ```
         *
         * Defaults to `'columns'`.
         */
        scrollDimension?: 'columns' | 'rows';
        /**
         * Static amount of *columns* (cells on X Axis) OR *rows* (cells on Y Axis).
         *
         * This depends on value of `scrollDimension`:
         *
         * `scrollDimension: 'columns'` -\> amount of rows.
         *
         * `scrollDimension: 'rows'` -\> amount of columns.
         */
        resolution: number;
        /**
         * Selection of format in which heatmap values are supplied.
         *
         * `'intensity'` | numeric value that can be colored with an associated color look up table.
         *
         * Defaults to `'intensity'.`
         */
        heatmapDataType?: DataType;
        /**
         * Start coordinate of Heatmap on its X and Y Axes.
         *
         * Defaults to `{ x: 0, y: 0 }`
         */
        start?: Point;
        /**
         * Step between each consecutive heatmap value on the X and Y Axes.
         *
         * X = columns,
         * Y = rows
         *
         * Defaults to `{ x: 1, y: 1 }`
         */
        step?: Point;
    }
    /**
     * Interface for a function which builds ResultTable content when pointing at a HeatmapSeries with numeric *intensity* values.
     * @param tableContentBuilder - Builder that is used to build contents of ResultTable.
     *                                  Use addRow() method for adding content.
     * @param series - Series
     * @param dataPoint - Information about the pointed data point.
     * @returns TableContentBuilder that was supplied
     * @public
     */
    export declare type HeatmapSeriesFormatterIntensity<Series = SeriesXY> = <T extends TableContentBuilder>(tableContentBuilder: T, series: Series, dataPoint: HeatmapIntensityDataPoint) => T;
    /**
     * Component which visibility can be controlled.
     *
     * Resources for hidden elements are not released.
     * Use `dispose` if complete removal of element is preferred over simply hiding it from view
     * @public
     */
    export declare interface Hideable {
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @public
         */
        setVisible: (state: boolean) => this;
        /**
         * Get element visibility.
         *
         * @returns `true` when element is set to be visible and `false` otherwise.
         * @public
         */
        getVisible: () => boolean;
    }
    /**
     * Component which has events for visibility state changes
     * @public
     */
    export declare interface HideableEvents {
        /**
         * Register new event listener to `visibleStateChanged` event
         */
        onVisibleStateChanged: (listener: VisibleStateChangedHandler<unknown>) => Token;
        /**
         * Remove event listener from `visibleStateChanged`
         */
        offVisibleStateChanged: (token: Token) => boolean;
    }
    /**
     * Interface for an object that can be highlighted.
     * @public
     */
    export declare interface Highlightable {
        /**
         * Set state of component highlighting.
         *
         * ```ts
         *  // Example usage
         *
         *  component.setHighlight(true)
         * ```
         *
         * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
         * @returns Object itself
         * @public
         */
        setHighlight(highlight: boolean | number): this;
        /**
         * Get state of component highlighting.
         *
         * @returns Number between 0 and 1, where 1 is fully highlighted.
         * @public
         */
        getHighlight(): number;
        /**
         * Subscribe to highlight object event. This is called whenever an object is highlighted.
         * @param handler - Function that is called when event is triggered.
         * @param highlight - The Highlight state.
         * @returns Token that can be used to unsubscribe from the event.
         * @public
         */
        onHighlight(handler: (obj: this, highlight: boolean | number) => void): Token;
        /**
         * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
         * @param token - Token that was received when subscribing to the event.
         * @returns True if the unsubscription was successful.
         * @public
         */
        offHighlight(token: Token): boolean;
    }
    /**
     * Abstract base class for Axis Highlighters.
     *
     * These components are placed along a single Axis to highlight some area of data.
     * @public
     */
    export declare abstract class Highlighter extends ChartComponent {
        /**
         * @public
         */
        readonly axis: Axis;
    }
    /**
     * Class that describes an _Icon_, a relatively small graphic that can be used with different LightningChart JS components.
     *
     * Icons can be created by supplying a graphic source and optionally a desired size for the Icon.
     *
     * To learn more, see {@link PublicEngine.addCustomIcon}.
     *
     * @public
     */
    export declare class Icon extends IconRecord implements Disposable {
        /**
         * Inform the engine owning the Icon that it is no longer used.
         *
         * Afterwards, there is no guarantee that the Icon will work.
         *
         * It is recommended to dispose all user defined Icons that are no longer needed.
         * In the short term, there is no large significance in retaining Icons that may be temporarily unused.
         * Disposing Icons is recommended more for the long term effects, such as avoiding permanent memory leaks that may show only over long runtimes.
         *
         * ```ts
         *  // Example, inform engine that an Icon is no longer needed.
         *  icon.dispose()
         * ```
         *
         * @returns  The object itself.
         * @public
         */
        dispose(): this;
        /**
         * Construct a new Icon that is otherwise identical to this one, except with modified {@link Icon.width} value.
         *
         * To confirm, **this does not modify the Icon object at all, and returns a reference to a brand new Icon.**
         *
         * @param   width  - Icon width as pixels.
         * @returns          A new Icon object.
         * @public
         */
        setWidth(width: number | undefined): Icon;
        /**
         * Get value of {@link Icon.width} property.
         *
         * This is not equal to the actual visible width of the Icon!
         * There is currently no method for accessing that value.
         *
         * @returns          Icon width value.
         * @public
         */
        getWidth(): number | undefined;
        /**
         * Construct a new Icon that is otherwise identical to this one, except with modified {@link Icon.height} value.
         *
         * To confirm, **this does not modify the Icon object at all, and returns a reference to a brand new Icon.**
         *
         * @param   height - Icon height as pixels.
         * @returns          A new Icon object.
         * @public
         */
        setHeight(height: number | undefined): Icon;
        /**
         * Get value of {@link Icon.height} property.
         *
         * This is not equal to the actual visible height of the Icon!
         * There is currently no method for accessing that value.
         * @returns          Icon height value.
         * @public
         */
        getHeight(): number | undefined;
        /**
         * Construct a new Icon that is otherwise identical to this one, except with modified size.
         *
         * To confirm, **this does not modify the Icon object at all, and returns a reference to a brand new Icon.**
         *
         * @param   width  - Icon width as pixels.
         * @param   height - Icon height as pixels.
         * @returns          A new Icon object.
         * @public
         */
        setSize(width: number, height: number): Icon;
    }
    /**
     * Interface for all properties of an Icon.
     * @public
     */
    export declare interface IconProperties {
        type: 'icon';
        /**
         * Explicit width as pixels, or `undefined` to use source size.
         *
         * If only `width` is specified, then icon height is automatically scaled to maintain source aspect ratio.
         * @public
         */
        width: undefined | number;
        /**
         * Explicit height as pixels, or `undefined` to use source size.
         *
         * If only `height` is specified, then icon width is automatically scaled to maintain source aspect ratio.
         * @public
         */
        height: undefined | number;
    }
    /**
     * Record contractor for IconProperties.
     * @public
     */
    declare const IconRecord: Record_2.Factory<IconProperties & {
    }>;
    /**
     * Style class for describing a *image fill style*.
     *
     * Instances of ImageFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of ImageFill:**
     * - `surroundingColor`: Fill color for the area surrounding the image. Construct a *LCJS color* using one of the many available *factories*:
     *      * {@link ColorRGBA}
     *      * {@link ColorHEX}
     *      * {@link ColorCSS}
     *      * {@link ColorHSV}
     *
     * - `sourceMissingColor`: Fill color used in place of the image when image is loading or image loading has failed. Construct a *LCJS color* using one of the many available *factories*:
     *      * {@link ColorRGBA}
     *      * {@link ColorHEX}
     *      * {@link ColorCSS}
     *      * {@link ColorHSV}
     *
     * - `fitMode`: {@link ImageFitMode} that specifies how the image is placed inside of the element using the ImageFill.
     * - `source`: Image source object. Can be any of `ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement`.
     *
     * **ImageFill Usage:**
     *
     * Use ImageFill with:
     * - `setFillStyle` methods:
     *      * {@link RectangleFigure.setFillStyle}
     *      * {@link ChartXY.setSeriesBackgroundFillStyle}
     *      * {@link ChartXY.setBackgroundFillStyle}
     *      * {@link ChartXY.setZoomingRectangleFillStyle}
     *      * {@link ChartXY.setFittingRectangleFillStyle}
     *      * {@link Chart3D.setBackgroundFillStyle}
     *      * {@link Axis.setOverlayStyle}
     *      * {@link UIBackground.setFillStyle}
     *
     * Example 1:
     * Styling a rectangle figure with an image.
     * ```typescript
     * const myImage = new Image()
     * myImage.src = 'https://example.com/myImage.png'
     * rectangleFigure.setFillStyle(new ImageFill({
     *     source: myImage,
     *     fitMode: ImageFitModes.Stretch
     * }))
     * ```
     *
     * Example 2:
     * Creating a new ImageFill object with a video as the source.
     * ```javascript
     * const myVideo = document.createElement('video')
     * myVideo.autoplay = true
     * myVideo.muted = true
     * myVideo.loop = true
     * myVideo.src = 'https://example.com/myVideo.mp4'
     * myVideo.play()
     * const imageFill = new ImageFill({
     *      source: myVideo,
     *      fitMode: ImageFitModes.Fit
     * })
     * ```
     *
     * **Related information:**
     *
     * For more *fill styles*, see:
     * - {@link emptyFill}
     * - {@link IndividualPointFill}
     * - {@link PalettedFill}
     * - {@link RadialGradientFill}
     * - {@link LinearGradientFill}
     * - {@link SolidFill}
     * @public
     */
    export declare class ImageFill extends ImageFillStyleRecord implements FillStyle {
        /**
         * Construct a new ImageFill object, specifying any amount of its properties.
         *
         * Example 1:
         * Creating a new ImageFill object with an image as the source.
         * ```javascript
         * const myImage = new Image()
         * myImage.src = 'https://example.com/myImage.png'
         * const imageFill = new ImageFill({
         *      source: myImage,
         *      fitMode: ImageFitModes.Stretch
         * })
         * ```
         *
         * Example 2:
         * Creating a new ImageFill object with a video as the source.
         * ```javascript
         * const myVideo = document.createElement('video')
         * myVideo.autoplay = true
         * myVideo.muted = true
         * myVideo.loop = true
         * myVideo.src = 'https://example.com/myVideo.mp4'
         * myVideo.play()
         * const imageFill = new ImageFill({
         *      source: myVideo,
         *      fitMode: ImageFitModes.Fit
         * })
         * ```
         *
         * When a HTMLVideoElement is specified as the source the chart will be constantly rendered while the video is playing.
         *
         * @param props - Object containing any amount of ImageFill properties.
         */
        constructor(props?: Partial<ImageFillStyleProperties>);
        /**
         * Construct a new ImageFill object based on this one, but with different image source.
         *
         * Example:
         * ```javascript
         * const myImg = new Image()
         * myImg.src = 'https://example.com/myImage.png'
         * imageFill.setSource(myImg)
         * ```
         *
         * @param value - TextureSource object
         * @returns New ImageFill object
         * @public
         */
        setSource(value: ImageFillSource): this;
        /**
         * Get image of ImageFill.
         * @returns ImageTexture object
         * @public
         */
        getSource(): ImageFillSource;
        /**
         * Construct a new ImageFill object based on this one, but with modified surrounding color.
         *
         * Surrounding color is used to fill the remaining element when the image doesn't fill the element completely.
         *
         * Example:
         * ```javascript
         * // specify new color
         * imageFill.setSurroundingColor( ColorHEX('#F00') )
         *
         * // change individual color properties
         * imageFill.setSurroundingColor( color => color.setA(80) )
         * ```
         * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
         * @returns New ImageFill object
         * @public
         */
        setSurroundingColor(value: Color | ImmutableMutator<Color>): this;
        /**
         * Get color of ImageFill.
         * @returns Color object
         * @public
         */
        getSurroundingColor(): Color;
        /**
         * Construct a new ImageFill object based on this one, but with modified source missing color.
         *
         * Source missing color is used in place of an image when the image has not been loaded yet or loading of the image has failed.
         *
         * Example:
         * ```javascript
         * // specify new color
         * imageFill.setSourceMissingColor( ColorHEX('#F00') )
         *
         * // change individual color properties
         * imageFill.setSourceMissingColor( color => color.setA(80) )
         * ```
         * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
         * @returns New ImageFill object
         * @public
         */
        setSourceMissingColor(value: Color | ImmutableMutator<Color>): this;
        /**
         * Get source missing color of ImageFill.
         * @returns Color object
         * @public
         */
        getSourceMissingColor(): Color;
        /**
         * Set new image fit mode.
         * @param value - Image fit mode
         * @public
         */
        setFitMode(value: ImageFitMode): this;
        /**
         * Get fit mode of ImageFill.
         * @returns Fit mode
         * @public
         */
        getFitMode(): ImageFitMode;
    }
    /**
     * Types that are accepted as the image source for {@link ImageFill}.
     *
     * Can be any of `ImageBitmap | ImageData | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement`
     *
     * @see ImageFill
     * @public
     */
    export declare type ImageFillSource = TexImageSource | undefined;
    /**
     * Interface for all options of a {@link ImageFill}.
     *
     * See {@link ImageFill}.
     * @see ImageFill
     * @public
     */
    export declare interface ImageFillStyleProperties {
        type: 'fillstyle';
        fillType: 'image';
        /**
         * The image source element to use.
         *
         * Can be any of {@link ImageFillSource}.
         *
         * Most commonly a `HTMLImageElement`.
         *
         * Example:
         * ```javascript
         * const myImage = new Image()
         * myImage.src = 'https://example.com/myImage.png'
         * const imageFill = new ImageFill({
         *      source: myImage
         * })
         * ```
         */
        source: ImageFillSource;
        /**
         * The color filling the area of element not filled by the image.
         */
        surroundingColor: Color;
        /**
         * The color filling element when image is loading or image loading failed.
         */
        sourceMissingColor: Color;
        /**
         * Image fitting mode.
         *
         * Example:
         *
         * ```javascript
         * const imageFill = new ImageFill({
         *      fitMode: ImageFitMode.Stretch
         * })
         * ```
         */
        fitMode: ImageFitMode;
    }
    /**
     * Record contractor for ImageFillFillStyleProperties.
     * @public
     */
    declare const ImageFillStyleRecord: Record_2.Factory<ImageFillStyleProperties>;
    /**
     * Different ways the image might be placed on the element.
     *
     * See {@link ImageFill}.
     * @see ImageFill
     * @public
     */
    export declare enum ImageFitMode {
        /**
         * Ensures that the image fills the full area of the element it's inside of.
         * Will keep image aspect ratio as is.
         * Image might be clipped on the smaller size axis.
         */
        Fill = 0,
        /**
         * Ensures that the image fits in the full area of the element it's inside of.
         * Will keep image aspect ratio as is.
         * Image might be not fill the element fully on the larger size axis.
         */
        Fit = 1,
        /**
         * Ensures that the image fills the full area of the element it's inside of.
         * Image aspect ratio will be distorted if the element aspect ratio is not same as the image aspect ratio.
         */
        Stretch = 2,
        /**
         * Places the image to the center of the full area of the element it's inside of.
         * Image aspect ratio will be kept as is.
         * Image might be clipped or not fill the element on either top/bottom and/or left/right, if the element is not same size as the image.
         */
        Center = 3,
        /**
         * Draws image starting from top left corner of the element it's inside of with exact source size.
         * If the element is larger than the image, then the image will be repeated indefinitely.
         * Can be used for drawing Tileable backgrounds.
         */
        Tile = 4
    }
    /**
     * Type of a mutator function for abstract, immutable object.
     * Function provides functionality for creating a new object based on an existing one.
     * @param object - Reference object
     * @returns New object
     * @public
     */
    export declare type ImmutableMutator<T, B = T> = (object: T) => B;
    /**
     * Interface for a series which contains individually sizeable an rotatable points
     * @Public
     */
    export declare interface IndividualPointed {
        /**
         * Enable or disable individual point sizing.
         *
         * When enabled, size for each point can be provided with the location of the point.
         * ```js
         * pointSeries.add({x: 1, y: 2, size: 10 })
         * ```
         * @param enabled - Boolean state for individual point size enabled
         * @public
         */
        setIndividualPointSizeEnabled(enabled: boolean): this;
        /**
         * Gets if individual point sizing is enabled or not.
         * @public
         */
        getIndividualPointSizeEnabled(): boolean;
        /**
         * Enable or disable individual point rotation.
         *
         * When enabled, rotation for each point can be provided with the location of the point.
         * ```js
         * pointSeries.add({x: 1, y: 2, rotation: 45 })
         * ```
         * @param enabled - Boolean state for individual point size enabled
         * @public
         */
        setIndividualPointRotationEnabled(enabled: boolean): this;
        /**
         * Gets if individual point rotation is enabled or not.
         * @public
         */
        getIndividualPointRotationEnabled(): boolean;
    }
    /**
     * Style class for describing a *individually configured fill color*, enabling users to specify data-point
     * specific colors.
     *
     * Instances of IndividualPointFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of IndividualPointFill:**
     * - `color`: fallback color to be used with data points that were not associated with a color.
     * Construct a *LCJS color* using one of the many available *factories*:
     *      * {@link ColorRGBA}
     *      * {@link ColorHEX}
     *      * {@link ColorCSS}
     *      * {@link ColorHSV}
     *
     * **IndividualPointFill Usage:**
     *
     * IndividualPointFill can be used with a select group of series:
     *
     * - {@link PointSeries.setPointFillStyle | PointSeries}
     * - {@link HeatmapGridSeriesIntensityValues.setFillStyle | HeatmapGridSeriesIntensityValues}
     * - {@link PointSeries3D.setPointStyle | PointSeries3D}
     *
     * ```typescript
     *  // Example, individual points fill color.
     *  PointSeries.setPointFillStyle(new IndividualPointFill())
     * ```
     *
     * **Related information:**
     *
     * For more *fill styles*, see:
     * - {@link SolidFill}
     * - {@link emptyFill}
     * - {@link PalettedFill}
     * - {@link RadialGradientFill}
     * - {@link LinearGradientFill}
     * - {@link ImageFill}
     * @public
     */
    export declare class IndividualPointFill extends VisibleFill {
        /**
         * Construct a IndividualPointFill object, specifying any amount of its properties.
         *
         * ```typescript
         *  // Example, for most cases no arguments are necessary (fallback color will be black).
         *  const individualPointFill = new IndividualPointFill()
         * ```
         *
         * ```typescript
         *  // Example, specify fallback color for data points without associated color.
         *  const individualPointFill = new IndividualPointFill({
         *      color: ColorRGBA( 0, 255, 0 )
         *  })
         * ```
         * @param props - Object containing any amount of IndividualPointFill properties.
         * @public
         */
        constructor(props?: Partial<VisibleFillStyleProperties>);
        /**
         * Construct a new IndividualPointFill object based on this one, but with modified fallback color.
         *
         * Example:
         * ```javascript
         * // specify new color
         * individualfill.setColor( ColorHEX('#F00') )
         *
         * // change individual color properties
         * individualfill.setColor( color => color.setA(80) )
         * ```
         * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
         * @returns New IndividualPointFill object
         * @public
         */
        setFallbackColor(value: Color | ImmutableMutator<Color>): this;
        /**
         * Get Fallback Color of IndividualPointFill.
         * @returns Color object
         * @public
         */
        getFallbackColor(): Color;
    }
    /**
     * Description of intensity interpolation mode for Intensity Heatmap and Surface series.
     *
     * Use with `setIntensityInterpolation` methods.
     *
     * `'disabled'`: Interpolation disabled; draw data exactly as it is.
     *
     * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
     * @public
     */
    export declare type IntensityInterpolationMode = 'disabled' | 'bilinear';
    /**
     * Interface for object that can have mouse-event-subscriptions.
     * @public
     */
    export declare interface Interactable {
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setMouseInteractions(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getMouseInteractions(): boolean;
        /**
         * Subscribe on Mouse Enter event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseEnter(listener: MouseEventHandler<this>): Token;
        /**
         * Subscribe on Mouse Enter leave
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseLeave(listener: AbruptMouseEventHandler<this>): Token;
        /**
         * Subscribe on Mouse Enter click
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseClick(listener: MouseEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Double Click event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseDoubleClick(listener: MouseEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Down event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseDown(listener: MouseEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Up event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseUp(listener: MouseEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Move event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseMove(listener: MouseEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Drag Start event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseDragStart(listener: MouseDragStartEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Drag event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseDrag(listener: MouseDragEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Drag Stop event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseDragStop(listener: MouseDragStopEventHandler<this>): Token;
        /**
         * Subscribe to Mouse Wheel event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onMouseWheel(listener: MouseWheelEventHandler<this>): Token;
        /**
         * Subscribe to Touch Start event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onTouchStart(listener: TouchEventHandler<this>): Token;
        /**
         * Subscribe to Touch Move event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onTouchMove(listener: TouchEventHandler<this>): Token;
        /**
         * Subscribe to Touch End event
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onTouchEnd(listener: TouchEventHandler<this>): Token;
        /**
         * Remove event listener from Mouse Enter Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseEnter(token: Token): boolean;
        /**
         * Remove event listener from Mouse Leave Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseLeave(token: Token): boolean;
        /**
         * Remove event listener from Mouse Click Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseClick(token: Token): boolean;
        /**
         * Remove event listener from Mouse Double Click Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDoubleClick(token: Token): boolean;
        /**
         * Remove event listener from Mouse Down Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDown(token: Token): boolean;
        /**
         * Remove event listener from Mouse Up Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseUp(token: Token): boolean;
        /**
         * Remove event listener from Mouse Move Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseMove(token: Token): boolean;
        /**
         * Remove event listener from Mouse Drag start Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDragStart(token: Token): boolean;
        /**
         * Remove event listener from Mouse Drag Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDrag(token: Token): boolean;
        /**
         * Remove event listener from Mouse Drag stop Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseDragStop(token: Token): boolean;
        /**
         * Remove event listener from Mouse Wheel Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offMouseWheel(token: Token): boolean;
        /**
         * Remove event listener from Touch Start Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offTouchStart(token: Token): boolean;
        /**
         * Remove event listener from Touch Move Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offTouchMove(token: Token): boolean;
        /**
         * Remove event listener from Touch End Event
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offTouchEnd(token: Token): boolean;
    }
    /**
     * Internal interface of Background.
     * Type of UiElement that can be used as a Background of another element.
     * The main requirement for a background is to be fitted to a rectangle of any size.
     * @public
     */
    declare interface InternalBackground extends InternalUIElement, UIBackground, Highlightable {
    }
    /**
     * XY Marker that is basically a static cursor.
     *
     * @remarks
     *
     * Not intended for direct use.
     *
     * @privateRemarks
     *
     * Relic from time before we knew how to separate internal API and public API. Should be refactored away.
     *
     * @public
     */
    declare abstract class InternalChartMarkerXY<ResultTableBackgroundType extends UIBackground> extends ChartMarker<ResultTableBackgroundType, InternalStaticCursorXY<ResultTableBackgroundType>> implements MarkerXY<ResultTableBackgroundType> {
        /**
         * @public
         */
        readonly axisX: Axis;
        /**
         * @public
         */
        readonly axisY: Axis;
        /**
         * Set visibility mode for gridstroke X.
         * @param visibilityMode - Defines when part is visible
         * @returns Object itself
         * @public
         */
        setGridStrokeXVisibility(visibilityMode: UIVisibilityModes): this;
        /**
         * Get visibility mode for gridstroke X.
         * @returns VisibilityMode
         * @public
         */
        getGridStrokeXVisibility(): UIVisibilityModes;
        /**
         * Set visibility mode for gridstroke Y.
         * @param visibilityMode - Defines when part is visible
         * @returns Object itself
         * @public
         */
        setGridStrokeYVisibility(visibilityMode: UIVisibilityModes): this;
        /**
         * Get visibility mode for gridstroke Y.
         * @returns VisibilityMode
         * @public
         */
        getGridStrokeYVisibility(): UIVisibilityModes;
        /**
         * Set visibility mode for tickMarker X.
         * @param visibilityMode - Defines when part is visible
         * @returns Object itself
         * @public
         */
        setTickMarkerXVisibility(visibilityMode: UIVisibilityModes): this;
        /**
         * Get visibility mode for tickMarker X.
         * @returns VisibilityMode
         * @public
         */
        getTickMarkerXVisibility(): UIVisibilityModes;
        /**
         * Set visibility mode for tickMarker Y.
         * @param visibilityMode - Defines when part is visible
         * @returns Object itself
         * @public
         */
        setTickMarkerYVisibility(visibilityMode: UIVisibilityModes): this;
        /**
         * Get visibility mode for tickMarker Y.
         * @returns VisibilityMode
         * @public
         */
        getTickMarkerYVisibility(): UIVisibilityModes;
        /**
         * Set is GridStrokeX cut at cursor location.
         * @param cut - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeXCut(cut: boolean): this;
        /**
         * Get is GridStrokeX cut at cursor location.
         * @returns Boolean flag
         * @public
         */
        getGridStrokeXCut(): boolean;
        /**
         * Set is GridStrokeY cut at cursor location.
         * @param cut - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeYCut(cut: boolean): this;
        /**
         * Get is GridStrokeY cut at cursor location.
         * @returns Boolean flag
         * @public
         */
        getGridStrokeYCut(): boolean;
        /**
         * Set style of x gridstroke
         * @param value - LineStyle object or mutator to modify existing one
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeXStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of x gridstroke
         * @returns LineStyle of gridstroke
         * @public
         */
        getGridStrokeXStyle(): LineStyle;
        /**
         * Set style of y gridstroke
         * @param value - LineStyle object or mutator to modify existing one
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeYStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of y gridstroke
         * @returns LineStyle of gridstroke
         * @public
         */
        getGridStrokeYStyle(): LineStyle;
        /**
         * Mutator function for x tick marker
         * @param mutator - TickMarker mutator function
         * @returns Object itself for fluent interface
         * @public
         */
        setTickMarkerX(mutator: Mutator<TickMarker>): this;
        /**
         * Get x tick marker
         * @returns X customTick of cursor
         * @public
         */
        getTickMarkerX(): TickMarker;
        /**
         * Mutator function for y tick marker
         * @param mutator - TickMarker mutator function
         * @returns Object itself for fluent interface
         * @public
         */
        setTickMarkerY(mutator: Mutator<TickMarker>): this;
        /**
         * Get y tick marker
         * @returns Y customTick of cursor
         * @public
         */
        getTickMarkerY(): TickMarker;
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setMouseInteractions(state: boolean): this;
    }
    /**
     * Internal type for cursor
     * @public
     */
    declare type InternalCursor<ResultTableBackgroundType extends UIBackground> = Cursor<ResultTableBackgroundType> & Disposable;
    /**
     * Internal type used to limit access to PointMarker
     * @public
     */
    declare type InternalPointMarker = UIElement & PointMarker;
    /**
     * Internal ResultTable class.
     * @public
     */
    declare class InternalResultTable<BackgroundClass extends UIBackground = UIBackground> extends UIRowGrid<BackgroundClass> implements ResultTable<BackgroundClass> {
        /**
         * Set displayed data of ResultTable
         * @param content - TableContent
         * @returns Object itself for fluent interface
         * @public
         */
        setContent(content: ResultTableContent): this;
        /**
         * Set text fill style
         * @param value - Fill style object or mutator to modify existing one
         * @returns Object itself for fluent interface
         * @public
         */
        setTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * @returns Current fill style object
         * @public
         */
        getTextFillStyle(): FillStyle;
        /**
         * Set font of Label.
         * @param value - FontSettings or mutator function for existing settings
         * @returns Object itself
         * @public
         */
        setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get font of Label.
         * @returns FontSettings
         * @public
         */
        getTextFont(): FontSettings;
        /**
         * Set rotation of Label.
         * @param value - Rotation in degrees
         * @returns Object itself
         * @public
         */
        setTextRotation(value: number): this;
        /**
         * Get rotation of Label.
         * @returns Rotation in degrees
         * @public
         */
        getTextRotation(): number;
    }
    /**
     * @public
     * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
     */
    declare interface _InternalSeries extends ChartComponent {
    }
    /**
     * @public
     * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
     */
    declare interface _InternalSeriesWithCursor<CursorPointInterface extends CursorPoint = CursorPoint> extends _InternalSeries {
        /**
         * Configure whether *cursors* should pick on this particular *series* or not.
         *
         * ```typescript
         *  // Example, prevent chart auto cursor from snapping to a series.
         *  LineSeries.setCursorEnabled(false)
         * ```
         *
         * **Related API:**
         *
         * - {@link ChartWithCursor.setAutoCursorMode} | configure behavior when auto cursor is visible.
         * @public
         */
        setCursorEnabled(state: boolean): this;
        /**
         * @returns Whether Cursor is enabled or not
         * @public
         */
        getCursorEnabled(): boolean;
    }
    /**
     * Class contains internal implementation of the Solid Gauge Slice.
     * @public
     */
    declare class InternalSolidGaugeSlice extends SolidGaugeSlice {
        /**
         * Animated value.
         */
        private _animatedValue;
        /**
         * @public
         */
        readonly scale: LinearScaleXY;
        /**
         * Set name for the Slice as string.
         * @param name - Slice name as string.
         * @returns Slice itself for fluent interface.
         * @public
         */
        setName(name: string): this;
        /**
         * Set value of Slice.
         * @param value - Numeric value
         * @returns Slice itself
         * @public
         */
        setValue(value: number): this;
        /**
         * Get value of Slice.
         * @returns Numeric value
         * @public
         */
        getValue(): number;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         * @public
         */
        setVisible(state: boolean): this;
        /**
         * Set scale interval.
         * @param start - Start scale value
         * @param end - End scale value
         * @returns this for fluent interface
         * @public
         */
        setInterval(start: number, end: number): this;
        /**
         * Set font of interval labels.
         *
         * Example usage:
         *```javascript
         * // Specified FontSettings
         * InternalSolidGaugeSlice.setIntervalLabelsFont(new FontSettings({ size: 24, style: 'italic' }))
         * // Set to bold
         * InternalSolidGaugeSlice.setIntervalLabelsFont((fontSettings) => fontSettings.setWeight('bold'))
         * ```
         * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
         * @returns Chart itself
         * @public
         */
        setIntervalLabelsFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get font of gauge interval labels.
         * @returns FontSettings object for gauge interval labels.
         * @public
         */
        getIntervalLabelsFont(): FontSettings;
        /**
         * Set fill style of interval labels.
         *
         * ```ts
         *  // Example, red interval labels
         *  GaugeSlice.setIntervalLabelsFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
         * @returns Object itself
         * @public
         */
        setIntervalLabelsFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of gauge interval labels.
         * @returns FillStyle object for gauge interval labels.
         * @public
         */
        getIntervalLabelsFillStyle(): FillStyle;
        /**
         * Set interval labels visibility enabled or disabled.
         * @param state - True - labels are enabled, otherwise - disabled.
         * @returns Slice itself for fluent interface.
         * @public
         */
        setIntervalLabelsVisible(state: boolean): this;
        /**
         * Get interval labels visibility state.
         * @returns True - labels are enabled, otherwise - disabled.
         * @public
         */
        getIntervalLabelsVisible(): boolean;
        /**
         * Set the angle interval of a slice.
         * @param start - Start angle in degrees.
         * @param end - End angle in degrees.
         * @returns Slice itself for fluent interface.
         * @public
         */
        setAngleInterval(start: number, end: number): this;
        /**
         * Set start angle of the slice.
         * @param angle - Min angle in degrees.
         * @returns Slice itself for fluent interface.
         * @public
         */
        setMinAngle(angle: number): this;
        /**
         * Set max angle of the slice.
         * @param angle -
         * @returns Slice itself for fluent interface.
         * @public
         */
        setMaxAngle(angle: number): this;
        /**
         * Set offset margins for the slice in degrees.
         * @param left - Left margin in degrees.
         * @param right - Right margin in degrees.
         * @public
         */
        setMarginInDegrees(left?: number, right?: number): this;
        /**
         * Apply new fill style to slice.
         * @param value - FillStyle for normal state.
         * @returns Slice itself for a fluent interface.
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get animated value of Slice.
         * When value of Slice is changed, the animated value will not update immediately, but after an animation.
         * (if animations are not disabled).
         * @returns Animated value
         * @public
         */
        getAnimatedValue(): number;
    }
    /**
     * Base class for Static cursors.
     * Users should create only using builders, not with constructor
     * @public
     */
    declare class InternalStaticCursor<ResultTableBackgroundType extends UIBackground> extends CursorBase<ResultTableBackgroundType> implements StaticCursor<ResultTableBackgroundType> {
        /**
         * Set position of cursor,
         * moving it without modifying displayed data.
         * @param position - Position on Cursors scale
         * @returns Object itself
         * @public
         */
        setPosition(position: Point): this;
    }
    /**
     * Internal class for static xy cursors.
     * Static cursors are attached to a pair of axes on creation
     * and don't move from there.
     * @public
     */
    declare class InternalStaticCursorXY<ResultTableBackgroundType extends UIBackground> extends InternalStaticCursor<ResultTableBackgroundType> implements CursorXY<ResultTableBackgroundType>, StaticCursor<ResultTableBackgroundType> {
        /**
         * @public
         */
        readonly axisX: Axis;
        /**
         * @public
         */
        readonly axisY: Axis;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         */
        dispose(): this;
        /**
         * Points the Cursor at a given CursorPoint.
         * Updating its position and displayed data.
         * @public
         */
        pointAt(cursorPoint: CursorPoint): this;
        /**
         * Set the position of the Cursor,
         * moving it without modifying displayed data.
         * @public
         */
        setPosition(position: Point): this;
        /**
         * Set is GridStrokeX cut at cursor location.
         * @param cut - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeXCut(cut: boolean): this;
        /**
         * Get is GridStrokeX cut at cursor location.
         * @returns Boolean flag
         * @public
         */
        getGridStrokeXCut(): boolean;
        /**
         * Set is GridStrokeY cut at cursor location.
         * @param cut - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeYCut(cut: boolean): this;
        /**
         * Get is GridStrokeY cut at cursor location.
         * @returns Boolean flag
         * @public
         */
        getGridStrokeYCut(): boolean;
        /**
         * Set style of x gridstroke
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link DashedLine}
         * - {@link emptyLine}
         *
         *
         * @param value - LineStyle object
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeXStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get style of x gridstroke
         * @returns LineStyle of gridstroke
         * @public
         */
        getGridStrokeXStyle(): LineStyle;
        /**
         * Set style of y gridstroke
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link DashedLine}
         * - {@link emptyLine}
         *
         *
         * @param value - LineStyle object
         * @returns Object itself for fluent interface
         * @public
         */
        setGridStrokeYStyle: (value: LineStyle | ImmutableMutator<LineStyle>) => this;
        /**
         * Get style of y gridstroke
         * @returns LineStyle of gridstroke
         * @public
         */
        getGridStrokeYStyle: () => LineStyle;
        /**
         * Set tick marker X visible or not.
         *
         * @param   visible  -   Tick marker X visible?
         * @returns              Object itself
         * @public
         */
        setTickMarkerXVisible(visible: boolean): this;
        /**
         * Get tick marker X visible or not.
         *
         * @returns              Boolean.
         */
        getTickMarkerXVisible(): boolean;
        /**
         * Set tick marker Y visible or not.
         *
         * @param   visible   -  Tick marker Y visible?
         * @returns              Object itself
         * @public
         */
        setTickMarkerYVisible(visible: boolean): this;
        /**
         * Get tick marker Y visible or not.
         *
         * @returns              Boolean.
         */
        getTickMarkerYVisible(): boolean;
        /**
         * Mutator function for x tick marker
         * @param mutator - TickMarker mutator function
         * @returns Object itself for fluent interface
         * @public
         */
        setTickMarkerX(mutator: Mutator<TickMarker>): this;
        /**
         * Mutator function for y tick marker
         * @param mutator - TickMarker mutator function
         * @returns Object itself for fluent interface
         * @public
         */
        setTickMarkerY(mutator: Mutator<TickMarker>): this;
        /**
         * Get x tick marker
         * @returns X customTick of cursor
         * @public
         */
        getTickMarkerX(): TickMarker;
        /**
         * Get y tick marker
         * @returns Y customTick of cursor
         * @public
         */
        getTickMarkerY(): TickMarker;
    }
    /**
     * Internal interface for CustomTicks TickMarkers.
     * @public
     */
    declare interface InternalTickMarker extends TickMarker, CustomizableText {
    }
    /**
     * Base class for UI elements.
     * @public
     */
    declare abstract class InternalUIElement extends UIObject implements UIElement, Disposable, DisposableEvents {
        /**
         * Pixel location of UiElements origin. To get position use getPosition(relativePosition).
         *
         * Coordinate system = position scale (UIElement.scale)
         * @public
         */
        protected position: Point;
        /**
         * @public
         */
        protected origin: Point;
        /**
         * @public
         */
        protected size: Point;
        /**
         * @public
         */
        protected readonly renderingScale: LinearScaleXY;
        /**
         * @public
         */
        readonly scale: ScaleXY;
        /**
         * Set mouse interactions enabled or disabled
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setMouseInteractions(state: boolean): this;
        /**
         * @returns Mouse interactions state
         * @public
         */
        getMouseInteractions(): boolean;
        /**
         * Set theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @param enabled - Theme effect enabled
         * @returns          Object itself.
         * @public
         */
        setEffect(enabled: boolean): this;
        /**
         * Get theme effect enabled on component or disabled.
         *
         * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
         * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
         *
         * ```ts
         *  // Example, disable theme effect from a particular component.
         *  Component.setEffect(false)
         * ```
         *
         * For the most part, theme effects are **enabled** by default on most components.
         *
         * Theme effect is configured with {@link Theme.effect} property.
         *
         * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
         * @public
         */
        getEffect(): boolean;
        /**
         * Set auto dispose behavior for this UI element.
         *
         * Can be used to set a condition, where the UI element is automatically *disposed*, removing it from view.
         *
         * ```ts
         *  // Example, remove UI element when it is larger than 20% of viewport.
         *  UIElement.setAutoDispose({
         *      type: 'max-width',
         *      maxWidth: 0.20,
         *  })
         * ```
         * @param autoDisposeMode - Auto dispose mode.
         * @returns Object itself for fluent interface.
         * @public
         */
        setAutoDispose(autoDisposeMode: AutoDisposeMode): this;
        /**
         * Get auto dispose behavior for this UI element.
         * @returns Auto dispose mode.
         * @public
         */
        getAutoDispose(): AutoDisposeMode;
        /**
         * Returns the size of the UiElements in pixels including any Margins or Paddings
         * @param spaceOfInterest - Parameter to disregard parts of object when calculating the position. Defaults to Margin,
         *                              which includes everything. Should only ever be necessary for sub-classes
         * @returns Object size in pixels
         * @public
         */
        getSize(spaceOfInterest?: UISpace): Point;
        /**
         * Member function that updates the size of the UI elements contents.
         * UiElements should apply this inside 'update'
         * @param sizeInPixels - Size of element in pixels
         * @public
         */
        protected setContentSize(sizeInPixels: Point): void;
        private _margin;
        /**
         * Set margin around object in pixels.
         * @param margin - Number with pixel margins for all sides or datastructure with individual pixel margins
         *                      for each side. Any side can be omitted, only passed values will be overridden.
         * @returns Object itself
         * @public
         */
        setMargin(margin: Partial<MMargin> | number): this;
        /**
         * Get margin around object in pixels.
         * @returns Margin datastructure
         * @public
         */
        getMargin(): Margin;
        /**
         * **Permanently** destroy the component.
         *
         * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
         * **to the component and its children** in application code.
         * ```javascript
         * let chart = ...ChartXY()
         * let axisX = chart.getDefaultAxisX()
         * // Dispose Chart, and remove all references so that they can be garbage-collected.
         * chart.dispose()
         * chart = undefined
         * axisX = undefined
         * ```
         * @returns  Object itself for fluent interface
         * @public
         */
        dispose(): this;
        /**
         * Set element visibility.
         *
         * @param state - `true` when element should be visible and `false` when element should be hidden.
         * @returns Object itself.
         */
        setVisible(state: boolean): this;
        /**
         * Subscribe `onDispose` event.
         * This event is triggered whenever the ChartComponent is disposed.
         *
         * ```typescript
         *  // Example usage
         *
         * figure.onDispose(() => {
         *   console.log('figure was disposed')
         * })
         *
         * figure.dispose()
         * ```
         *
         * @param listener - Event handler function
         * @returns Token of subscription
         * @public
         */
        onDispose(listener: (object: this) => unknown): Token;
        /**
         * Remove event listener from dispose event.
         * @param token - Token of event listener which has to be removed
         * @returns True if the listener is successfully removed and false if it is not found
         * @public
         */
        offDispose(token: Token): boolean;
        /**
         * Sets the position of this UiElement relative to its origin.
         *
         * NOTE: UIElements scale can't be changed apart from when it is created.
         * @param position - Location on the UIElements scale, where its origin should be positioned
         * @returns Object itself
         * @public
         */
        setPosition(position: Point): this;
        /**
         * Returns the position of this UiElement at given location relative to elements size.
         * @param relativePosition - Relative position vector (-1 to 1 which specifies position of origin, 0 is center of the object)
         * @param spaceOfInterest - Parameter to disregard parts of object when calculating the asked position. Defaults to Margin,
         *                              which includes everything. Should only ever be necessary for other UiElements
         * @returns Object itself for fluent itself
         * @public
         */
        getPosition(relativePosition?: Point, spaceOfInterest?: UISpace): Point;
        /**
         * Sets the position origin of this UiElement. Affects how the "position" of UIElement is interpreted.
         *
         * See {@link UIOrigins} for a collection of common arguments in an easy-to-read format.
         * @param Vec2 - with each plane in range [-1, 1], where 0 is middle
         * @returns Object itself
         * @public
         */
        setOrigin(origin: Point): this;
        /**
         * Get the position origin of this UiElement. Affects how the "position" of UIElement is interpreted.
         *
         * @returns Vec2 with each plane in range [-1, 1], where 0 is middle
         * @public
         */
        getOrigin(): Point;
        /**
         * Set dragging mode of object. Defines how the object can be dragged by mouse.
         *
         * See {@link UIDraggingModes}collection for options.
         * @param draggingMode - DraggingMode or undefined to disable dragging
         * @returns Object itself
         * @public
         */
        setDraggingMode(draggingMode?: UIDraggingModes): this;
        /**
         * Get dragging mode of object.
         * Defines how the object can be dragged by mouse.
         * @returns Object itself
         * @public
         */
        getDraggingMode(): UIDraggingModes;
        /**
         * Set mouse style when hovering over UI object.
         * @param mouseStyle - Interface for defining how mouse should look when hovering over UI object
         * @returns Object itself
         * @public
         */
        setMouseStyle(mouseStyle: UIMouseStyle): this;
        /**
         * Get mouse style.
         * @returns Interface for defining how mouse should look when hovering over UI object
         * @public
         */
        getMouseStyle(): UIMouseStyle;
    }
    /**
     * Generic Interval
     * @param min - Start of interval
     * @param max - End of interval
     */
    declare interface Interval<T> {
        readonly min: T;
        readonly max: T;
    }
    /**
     * Interval change event listener.
     * @param slice - Slice
     * @param previous - Previous slice interval
     * @param next - Next slice interval
     * @public
     */
    export declare type IntervalChangeEventListener<S extends GaugeSlice> = (slice: S, previous: SliceInterval, next: SliceInterval) => void;
    /**
     * Color type guard.
     *
     * Use to verify that an unknown object is an instance of {@link Color}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a Color
     * @public
     */
    export declare const isColor: (value: unknown) => value is Color;
    /**
     * Type guard for checking if an object has type of {@link Coordinate3D}.
     * @public
     */
    export declare const isCoordinate3D: (value: unknown) => value is Coordinate3D;
    /**
     * Type guard for checking if an object has type of {@link CoordinateBarChart}.
     * @public
     */
    export declare const isCoordinateBarChart: (value: unknown) => value is CoordinateBarChart;
    /**
     * Type guard for checking if an object has type of {@link CoordinateClient}.
     * @public
     */
    export declare const isCoordinateClient: (value: unknown) => value is CoordinateClient;
    /**
     * Type guard for checking if an object has type of {@link CoordinatePolar}.
     * @public
     */
    export declare const isCoordinatePolar: (value: unknown) => value is PolarPoint;
    /**
     * Type guard for checking if an object has type of {@link CoordinateXY}.
     * @public
     */
    export declare const isCoordinateXY: (value: unknown) => value is CoordinateXY;
    /**
     * DashedLine type guard.
     *
     * Use to verify that an LineStyle is a DashedLine.
     *
     * Example:
     * ```ts
     * line.setStrokeStyle((stroke) => isDashedLine(stroke) ? stroke.setPattern(StipplePatterns.Dashed) : stroke )
     * ```
     *
     * @param value - LineStyle to check
     * @returns Boolean indicating if value is a DashedLine
     * @public
     */
    export declare const isDashedLine: (value: unknown) => value is DashedLine;
    /**
     * DateTimeTickStrategy type guard.
     *
     * Use to verify that an unknown object is an instance of {@link DateTimeTickStrategy}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a DateTimeTickStrategy
     * @public
     */
    export declare const isDateTimeTickStrategy: (value: unknown) => value is DateTimeTickStrategy;
    /**
     * EmptyFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link EmptyFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a EmptyFill
     * @public
     */
    export declare const isEmptyFill: (value: unknown) => value is EmptyFill;
    /**
     * Convenience function for checking if all properties of a tick style are empty.
     *
     * @param value - Object to check
     * @returns Boolean indicating if all styles are empty (label, gridstroke, tickline).
     * @public
     */
    export declare const isEmptyTick: (value: TickStyle) => boolean;
    /**
     * FontSettings type guard.
     *
     * Use to verify that an unknown object is an instance of {@link FontSettings}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a FontSettings
     * @public
     */
    export declare const isFontSettings: (value: unknown) => value is FontSettings;
    /**
     * GlowEffect type guard.
     *
     * Use to verify that an unknown object is an instance of {@link GlowEffect}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a GlowEffect
     * @public
     */
    export declare const isGlowEffect: (value: unknown) => value is GlowEffect;
    /**
     * Icon type guard.
     *
     * Use to verify that an unknown object is an instance of {@link Icon}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a Icon
     * @public
     */
    export declare const isIcon: (value: unknown) => value is Icon;
    /**
     * IndividualPointFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link IndividualPointFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a IndividualPointFill
     * @public
     */
    export declare const isIndividualPointFill: (value: unknown) => value is IndividualPointFill;
    /**
     * LinearGradientFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link LinearGradientFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a LinearGradientFill
     * @public
     */
    export declare const isLinearGradientFill: (value: unknown) => value is LinearGradientFill;
    /**
     * LUT type guard.
     *
     * Use to verify that an unknown object is an instance of {@link LUT}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a LUT
     * @public
     */
    export declare const isLUT: (value: unknown) => value is LUT;
    /**
     * NumericTickStrategy type guard.
     *
     * Use to verify that an unknown object is an instance of {@link NumericTickStrategy}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a NumericTickStrategy
     * @public
     */
    export declare const isNumericTickStrategy: (value: unknown) => value is NumericTickStrategy;
    /**
     * PalettedFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link PalettedFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a PalettedFill
     * @public
     */
    export declare const isPalettedFill: (value: unknown) => value is PalettedFill<LookUpProperty>;
    /**
     * PhongShadingStyle type guard.
     *
     * Use to verify that an unknown object is an instance of {@link PhongShadingStyle}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a PhongShadingStyle
     * @public
     */
    export declare const isPhongShadingStyle: (value: unknown) => value is PhongShadingStyle;
    /**
     * PixelatedPoints3D type guard.
     *
     * Use to verify that an unknown object is an instance of {@link PixelatedPoints3D}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a PixelatedPoints3D
     * @public
     */
    export declare const isPixelatedPoints3D: (value: unknown) => value is PixelatedPoints3D;
    /**
     * RadialGradientFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link RadialGradientFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a RadialGradientFill
     * @public
     */
    export declare const isRadialGradientFill: (value: unknown) => value is RadialGradientFill;
    /**
     * Check if a SeriesXY is of SupportedSeries type.
     * @public
     */
    export declare const isSeriesSupportedByZoomBandChart: (series: SeriesXY) => series is ZoomBandChartSupportedSeries;
    /**
     * SimpleShadingStyle type guard.
     *
     * Use to verify that an unknown object is an instance of {@link SimpleShadingStyle}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a SimpleShadingStyle
     * @public
     */
    export declare const isSimpleShadingStyle: (value: unknown) => value is SimpleShadingStyle;
    /**
     * SolidFill type guard.
     *
     * Use to verify that an unknown object is an instance of {@link SolidFill}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a SolidFill
     * @public
     */
    export declare const isSolidFill: (value: unknown) => value is SolidFill;
    /**
     * SolidLine type guard.
     *
     * Use to verify that an LineStyle is a SolidLine.
     *
     * Example:
     * ```ts
     * line.setStrokeStyle((stroke) => isSolidLine(stroke) ? stroke.setThickness(10) : new SolidLine() )
     * ```
     *
     * @param value - LineStyle to check
     * @returns Boolean indicating if value is a SolidLine
     * @public
     */
    export declare const isSolidLine: (value: unknown) => value is SolidLine;
    /**
     * TickStyle type guard.
     *
     * Use to verify that an unknown object is an instance of {@link TickStyle}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a TickStyle
     * @public
     */
    export declare const isTickStyle: (value: unknown) => value is TickStyle;
    /**
     * TimeTickStrategy type guard.
     *
     * Use to verify that an unknown object is an instance of {@link TimeTickStrategy}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a TimeTickStrategy
     * @public
     */
    export declare const isTimeTickStrategy: (value: unknown) => value is TimeTickStrategy;
    /**
     * TriangulatedPoints3D type guard.
     *
     * Use to verify that an unknown object is an instance of {@link TriangulatedPoints3D}.
     *
     * @param value - Object to check
     * @returns Boolean indicating if value is a TriangulatedPoints3D
     * @public
     */
    export declare const isTriangulatedPoints3D: (value: unknown) => value is TriangulatedPoints3D;
    /**
     * *Legend box* is a component that describes collections of chart components, like series, highlighters, etc.
     *
     * It contains a *title*, and buttons for each attached chart component that display the component name and can be clicked to toggle visibility of that particular component.
     * These buttons are known as *legend box entries*.
     * Additionally, attaching a *series* with an associated *color look-up table* ({@link LUT}) will result in the `LegendBox` automatically visualizing the color look up range.
     *
     * A Legend box can be created with the `addLegendBox` method, which is supported by all *chart* types.
     * For example: {@link ChartXY.addLegendBox}.
     *
     * **Adding items to LegendBox**:
     *
     * Use {@link LegendBox.add} to add a *series* into the *LegendBox* (if chart, or dashboard is supplied, then all contained *series* will be attached).
     *
     * ```typescript
     *  // Example, attach a series to LegendBox.
     *  const mySeries = ChartXY.addLineSeries()
     *  LegendBox.add(mySeries)
     * ```
     *
     * **Configuring LegendBox title**:
     *
     * *LegendBox* has a built-in title component, which can be configured with {@link LegendBox.setTitle}:
     *
     * ```typescript
     *  // Example 1, specify LegendBox title.
     *  LegendBox.setTitle('Groups Legend')
     * ```
     *
     * ```typescript
     *  // Example 2, hide LegendBox title.
     *  LegendBox.setTitle('')
     * ```
     *
     * **Configuring LegendBox entries**
     *
     * When a *series* is attached to *LegendBox*, it creates a `LegendBoxEntry` associated with that *series*.
     * This *entry* shows as a button + label inside the *LegendBox*. All *entries* that currently exist inside a *LegendBox* can be styled with the {@link LegendBox.setEntries} method:
     *
     * ```typescript
     *  // Example, style LegendBoxEntries.
     *  // First attach series to create entries.
     *  LegendBox.add(mySeries)
     *  // Then style each entry using a callback function.
     *  LegendBox.setEntries((entry, component) => entry
     *      .setTextFont((font) => font
     *          .setStyle('italic')
     *      )
     *  )
     * ```
     *
     * See {@link LegendBoxEntry} for available configuration API for each *entry*.
     *
     * Styling an automatically created `UILUTCheckBox` requires a type cast (*TypeScript* users):
     *
     * ```typescript
     *  // Example, styling a UILUTCheckBox that is automatically created when a series with associated LUT is attached.
     *  LegendBox.add(myHeatmapSeries)
     *  // Heatmap series is styled with `PalettedFill` -> style the created UILUTCheckBox using a reference check + type cast.
     *  LegendBox.setEntries((entry, component) => {
     *      if (component === myHeatmapSeries) {
     *          const lutCheckBox = entry as UILUTCheckBox
     *          lutCheckBox
     *              .setLUTLength(200)
     *              .setLUTThickness(30)
     *              .setLUTTextFont((font) => font
     *                  .setSize(10)
     *              )
     *      }
     *  })
     * ```
     * @public
     */
    export declare interface LegendBox<BackgroundType extends UIBackground = UIBackground> extends UIElementWithBackground<BackgroundType> {
        /**
         * Add a dynamic value to LegendBox, creating a group and entries for it depending on type of value.
         * Supports series, charts and dashboards.
         * @param value - Series, Chart or Dashboard
         * @param opts - Optional extra configuration arguments.
         * @returns Object itself.
         * @public
         */
        add(value: Attachable | Chart | Dashboard, opts?: LegendBoxAddOptions): this;
        /**
         * Set text of LegendBox title.
         * @param title - LegendBox title as a string.
         * @returns Object itself for fluent interface.
         * @public
         */
        setTitle(title: string): this;
        /**
         * Get text of LegendBox title.
         * @returns LegendBox title as a string.
         * @public
         */
        getTitle(): string;
        /**
         * Set fill style of LegendBox Title.
         *
         * Example usage:
         *```javascript
         * // Create a new style
         * setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
         * // Change transparency
         * setTitleFillStyle((solidFill) => solidFill.setA(80))
         * // Set hidden
         * setTitleFillStyle(emptyFill)
         * ```
         * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
         * @returns LegendBox itself
         * @public
         */
        setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get fill style of LegendBox Title.
         * @returns FillStyle object
         * @public
         */
        getTitleFillStyle(): FillStyle;
        /**
         * Set font of LegendBox Title.
         *
         * Example usage:
         *```javascript
         * // Create a new FontSettings
         * setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
         * // Change existing settings
         * setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
         * ```
         *
         * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
         * @returns LegendBox itself
         * @public
         */
        setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
        /**
         * Get font of LegendBox title.
         * @returns FontSettings object
         * @public
         */
        getTitleFont(): FontSettings;
        /**
         * Set rotation of LegendBox title.
         * @param value - Rotation in degrees
         * @returns Object itself
         * @public
         */
        setTitleRotation(value: number): this;
        /**
         * Get rotation of LegendBox title.
         * @returns Rotation in degrees
         * @public
         */
        getTitleRotation(): number;
        /**
         * Set style of LegendBoxEntries with a callback function.
         *
         * To set style of Entry matching a specific component, use the `component` parameter with a custom check.
         *
         * **Example usage:**
         *
         * - Style specific series entry only
         *
         * ```typescript
         *  setEntries((entry, component) =>
         *      // Only apply for single series.
         *      component === mySeries &&
         *      entry.setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         *  )
         * ```
         *
         * - Style UILUTCheckBox
         *
         * ```typescript
         *  setEntries((entry, component) =>
         *      // Must check for series with attached LUT
         *      component === myHeatmapSeries &&
         *      // Cast type to UILUTCheckBox
         *      (entry as UILUTCheckBox)
         *          .setLookUpUnit('mm/h')
         *          .setLUTThickness(50)
         *  )
         * ```
         *
         * @param styler - Function that is called for each LegendBoxEntry.
         * @returns Object itself.
         * @public
         */
        setEntries(styler: (entry: LegendBoxEntry, component: Attachable) => unknown): this;
    }
    /**
     * Optional configuration options that can be supplied when adding *entries* to a {@link LegendBox}.
     *
     * ```ts
     *  // Example, prevent toggling visibility on click.
     *  LegendBox.add(component, { toggleVisibilityOnClick: false })
     * ```
     *
     * ```ts
     *  // Example, specify point shape in legend
     *  LegendBox.add(component, { builder: UIElementBuilders.CheckBox.setButtonShape(PointShape.Star) })
     * ```
     *
     * ```ts
     *  // Example, match component style exactly instead of assigning a built-in gradient
     *  LegendBox.add(component, { matchStyleExactly: true })
     * ```
     * @public
     */
    export declare type LegendBoxAddOptions = {
        /**
         * Optional flag that determines whether clicking the LegendBoxEntry will dispose the Attached objects
         *
         * ```ts
         *  // Example, prevent toggling visibility on click.
         *  LegendBox.add(component, { toggleVisibilityOnClick: false })
         * ```
         */
        toggleVisibilityOnClick?: boolean;
        /**
         * Optional builder for custom entry
         *
         * ```ts
         *  // Example, specify point shape in legend
         *  LegendBox.add(component, { builder: UIElementBuilders.CheckBox.setButtonShape(PointShape.Star) })
         * ```
         */
        builder?: UIElementBuilder<LegendBoxEntry>;
        /**
         * By default, entries are assigned a smooth looking gradient based on the component color.
         * If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
         *
         * ```ts
         *  // Example, match component style exactly instead of assigning a built-in gradient
         *  LegendBox.add(component, { matchStyleExactly: true })
         * ```
         */
        matchStyleExactly?: boolean;
    };
    /**
     * Collection of available *LegendBox* *builders*. To build *LegendBox*es you must pass one of these to method: **addLegendBox()**.
     * This method can be accessed through *Charts*, *Dashboard*, Etc.
     *
     * Example usage:
     *```javascript
     * // Create a HorizontalLegendBox on a ChartXY
     * ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
     * // Create a HorizontalLegendBox on a Dashboard
     * Dashboard.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
     * ```
     * @public
     */
    export declare const LegendBoxBuilders: {
        /**
         * Horizontal implementation of *LegendBox*.
         *
         * Example usage:
         *```javascript
         * // Create a Horizontal LegendBox
         * Chart.addUIElement(UIElementBuilders.HorizontalLegendBox)
         * ```
         */
        HorizontalLegendBox: UILegendBoxBuilder;
        /**
         * Vertical implementation of *LegendBox*.
         *
         * Example usage:
         *```javascript
         * // Create a Vertical LegendBox
         * Chart.addUIElement(UIElementBuilders.VerticalLegendBox)
         * ```
         */
        VerticalLegendBox: UILegendBoxBuilder;
    };
    /**
     * Interface for *legendbox entry*.
     *
     * A legendbox entry is a button that resides inside a {@link LegendBox}. A single *entry* is created for each component attached to a *legendbox*.
     * The entry displays the name of this component, and pressing on the entry will toggle the visibility of that component.
     * @public
     */
    export declare type LegendBoxEntry<BackgroundType extends UIBackground = UIBackground> = UICheckBox<BackgroundType>;
    /**
     * Main interface of LCJS, which is used to create all top level components - *charts* and *dashboards*.
     * Reference to `LightningChart` is received with the {@link lightningChart} export, which is also used to supply possible license information, and other top-level configuration:
     *
     * ```typescript
     *  const lcjs = lightningChart({
     *      // Either supply license number, or omit for automatic community license.
     *      // license: 'my-license-number'
     *  })
     *
     *  // Create charts...
     *  const chart = lcjs.ChartXY()
     * ```
     *
     * To get started, browse through the available properties, for example:
     *
     * - {@link LightningChart.ChartXY}.
     * - {@link LightningChart.Chart3D}.
     * - {@link LightningChart.Dashboard}.
     * @public
     */
    export declare interface LightningChart {
        /**
         * Factory for `Dashboard`.
         * Dashboard allows placement of multiple *charts* inside a *grid layout*. Usage of *dashboard* is recommended when applicable,
         * due to increased performance (shared rendering context for all *charts*).
         *
         * To learn more about *dashboard* features, refer to {@link Dashboard}.
         *
         * **Dashboard configuration:**
         *
         * When a *dashboard* is created, the user must specify an amount of *columns* and *rows* for the grid layout.
         * These dimensions can't be changed afterwards, whereas the distribution of width/height between the *columns* and *rows*, can be adjusted at any time.
         *
         * ```typescript
         *  // Example, Create a 3x3 dashboard.
         *  const dashboard = LightningChart.Dashboard({
         *      // Number of cells along horizontal plane.
         *      numberOfColumns: 3,
         *      // Number of cells along vertical plane.
         *      numberOfRows: 3,
         *  })
         * ```
         *
         * To learn about the effects of *columns* / *rows* configuration, please read more here {@link Dashboard}.
         *
         * **Optional extra configuration:**
         *
         * Some extra, optional properties of `Dashboard` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in the same object parameter that is used for supplying `numberOfColumns`, and `numberOfRows`.
         *
         * ```typescript
         *  // Example, create 3x3 dashboard inside DOM element managed by user. The element must be added to the document, before creating the dashboard.
         *  const chart = LightningChart.Dashboard({
         *      // Number of cells along horizontal plane.
         *      numberOfColumns: 3,
         *      // Number of cells along vertical plane.
         *      numberOfRows: 3,
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *dashboard* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `Dashboard` specific properties, refer to {@link DashboardOptions}.
         *
         * **Dashboard examples:**
         *
         * You can find an interactive gallery of different `Dashboard` use cases on our web site [`lightningchart.com`](https://lightningchart.com/lightningchart-js-interactive-examples/search.html?t=dashboard)
         *
         * @param options - Optional object with readonly configuration arguments for `Dashboard`.
         * @returns Created dashboard.
         * @public
         */
        Dashboard: (options: EngineOptions & DashboardOptions) => Dashboard;
        /**
         * Factory for `ChartXY`. This chart visualizes data between two dimensions *X* and *Y*.
         * It has built-in *Axis* functionality, and supports a large set of *series* types.
         *
         * To learn more about its features, refer to {@link ChartXY}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `ChartXY` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.ChartXY({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `ChartXY` specific properties, refer to {@link ChartXYOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `ChartXY`.
         * @returns Created chart.
         * @public
         */
        ChartXY: <CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & ChartXYOptions<CursorResultTableBackgroundType>) => ChartXY<CursorResultTableBackgroundType>;
        /**
         * Factory for `SpiderChart`. This chart visualizes data distributed over several *axes*.
         * *Spider Axes* are layed out in a circle, without any set limit on the amount of axes.
         * It supports a collection of different *series* types.
         *
         * To learn more about its features, refer to {@link SpiderChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `SpiderChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.SpiderChart({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `SpiderChart` specific properties, refer to {@link SpiderChartOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `SpiderChart`.
         * @returns Created chart.
         * @public
         */
        Spider: <CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & SpiderChartOptions<CursorResultTableBackgroundType>) => SpiderChart<CursorResultTableBackgroundType>;
        /**
         * Factory for `PolarChart`. This chart visualizes data in a *Polar coordinate system* ( **angle** + **amplitude** ).
         * It has built-in *Axis* functionality, and supports a collection of different *series* types.
         *
         * To learn more about its features, refer to {@link PolarChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PolarChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Polar({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `PolarChart` specific properties, refer to {@link PolarChartOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `PolarChart`.
         * @returns Created chart.
         * @public
         */
        Polar: <CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & PolarChartOptions<CursorResultTableBackgroundType>) => PolarChart<CursorResultTableBackgroundType>;
        /**
         * Factory for `PieChart`. This chart visualizes proportions and percentages between categories,
         * by dividing a circle into proportional segments.
         *
         * To learn more about its features, refer to {@link PieChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PieChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Pie({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `PieChart` specific properties, refer to {@link PieChartOptions}.
         *
         * **Return type:**
         *
         * `PieChart` return type depends on supplied readonly configuration! Specifically, {@link PieChartOptions.type}.
         *
         * | Configuration `type` | Return chart type |
         * | :------------------- | :---------------- |
         * | `undefined` or omitted | {@link PieChartWithLabelsOnSides} |
         * | `PieChartTypes.LabelsOnSides` | {@link PieChartWithLabelsOnSides} |
         * | `PieChartTypes.LabelsInsideSlices` | {@link PieChartWithLabelsInsideSlices} |
         *
         * @param options - Optional object with readonly configuration arguments for `PieChart`.
         * @returns Created chart.
         * @public
         */
        Pie: <PieChartType extends PieChartTypes = typeof PieChartWithLabelsOnSides>(options?: EngineOptions & PieChartOptions<PieChartType>) => InstanceType<PieChartType>;
        /**
         * Factory for `GaugeChart`. Gauge charts indicate where your data point(s) falls over a particular range.
         * This chart type is often used in executive dashboard reports to show key business indicators.
         *
         * To learn more about its features, refer to {@link SolidGauge}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `GaugeChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Gauge({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `GaugeChart` specific properties, refer to {@link GaugeChartOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `GaugeChart`.
         * @returns Created chart.
         * @public
         */
        Gauge: (options?: EngineOptions & GaugeChartOptions<typeof SolidGauge>) => SolidGauge;
        /**
         * Factory for `FunnelChart`. This chart visualizes proportions and percentages between categories.
         *
         * To learn more about its features, refer to {@link FunnelChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `FunnelChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Funnel({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `FunnelChart` specific properties, refer to {@link FunnelChartOptions}.
         *
         * **Return type:**
         *
         * `FunnelChart` return type depends on supplied readonly configuration! Specifically, {@link FunnelChartOptions.type}.
         *
         * | Configuration `type` | Return chart type |
         * | :------------------- | :---------------- |
         * | `undefined` or omitted | {@link FunnelChartWithLabelsOnSides} |
         * | `FunnelChartTypes.LabelsOnSides` | {@link FunnelChartWithLabelsOnSides} |
         * | `FunnelChartTypes.LabelsInsideSlices` | {@link FunnelChartWithLabelsInsideSlices} |
         *
         * @param options - Optional object with readonly configuration arguments for `FunnelChart`.
         * @returns Created chart.
         * @public
         */
        Funnel: <FunnelChartType extends FunnelChartTypes = typeof FunnelChartWithLabelsOnSides>(options?: EngineOptions & FunnelChartOptions<FunnelChartType>) => InstanceType<FunnelChartType>;
        /**
         * Factory for `PyramidChart`. This chart visualizes proportions and percentages between categories.
         *
         * To learn more about its features, refer to {@link PyramidChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `PyramidChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Pyramid({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `PyramidChart` specific properties, refer to {@link PyramidChartOptions}.
         *
         * **Return type:**
         *
         * `PyramidChart` return type depends on supplied readonly configuration! Specifically, {@link PyramidChartOptions.type}.
         *
         * | Configuration `type` | Return chart type |
         * | :------------------- | :---------------- |
         * | `undefined` or omitted | {@link PyramidChartWithLabelsOnSides} |
         * | `PyramidChartTypes.LabelsOnSides` | {@link PyramidChartWithLabelsOnSides} |
         * | `PyramidChartTypes.LabelsInsideSlices` | {@link PyramidChartWithLabelsInsideSlices} |
         *
         * @param options - Optional object with readonly configuration arguments for `PyramidChart`.
         * @returns Created chart.
         * @public
         */
        Pyramid: <PyramidChartType extends PyramidChartTypes = typeof PyramidChartWithLabelsOnSides>(options?: EngineOptions & PyramidChartOptions<PyramidChartType>) => InstanceType<PyramidChartType>;
        /**
         * Factory for `UIPanel`. This component can only be used to anchor *UI elements* outside of any particular *chart*.
         *
         * To learn more about its features, refer to {@link UIPanel}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `UIPanel` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create panel inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const panel = LightningChart.UIPanel({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-panel-div'
         *  })
         * ```
         *
         * For full list of available properties, refer to {@link EngineOptions}.
         *
         * @param options - Optional object with readonly configuration arguments for `UIPanel`.
         * @returns Created UI panel.
         * @public
         */
        UIPanel: (options?: EngineOptions) => UIPanel;
        /**
         * Factory for `MapChart`. This chart visualizes a Map of the selected part of the world. Defaults to the entire world.
         * It has built-in *cursor* functionality and supports dynamic region coloring.
         *
         * To learn more about its features, refer to {@link MapChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `MapChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, specify map type.
         *  const chart = LightningChart.Map({
         *      type: MapTypes.Europe
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `MapChart` specific properties, refer to {@link MapChartOptions}.
         *
         * **Required resources:**
         *
         * `MapChart` requires external file resources in order to work.
         * These resources are distributed along with the LightningChart JS package (`node_modules/@arction/lcjs/dist/resources`).
         *
         * In order to use `MapChart` the map resources need to be hosted on a file server.
         * When `MapChart` is created, a GET request will be issued to URL: `<resourcesBaseUrl>/maps/<mapDataFile>`.
         *
         * The file server location can be specified by supplying a `resourcesBaseUrl`
         * (see {@link LightningChartOptions.resourcesBaseUrl}).
         *
         * The following table documents which resource files are required based on used *Map type*:
         *
         * | Map type                   | Map data file                             |
         * | :------------------------- | :---------------------------------------- |
         * | `MapTypes.World`           | `'countries_world.json'`                  |
         * | `MapTypes.Europe`          | `'countries_europe.json'`                 |
         * | `MapTypes.NorthAmerica`    | `'countries_northAmerica.json'`           |
         * | `MapTypes.SouthAmerica`    | `'countries_southAmerica.json'`           |
         * | `MapTypes.Africa`          | `'countries_africa.json'`                 |
         * | `MapTypes.Asia`            | `'countries_asia.json'`                   |
         * | `MapTypes.USA`             | `'states_usa.json'`                       |
         * | `MapTypes.Canada`          | `'territoriesProvinces_canada.json'`      |
         * | `MapTypes.Australia`       | `'territories_australia.json'`            |
         *
         * @param options - Optional object with readonly configuration arguments for `MapChart`.
         * @returns Created chart.
         * @public
         */
        Map: <SelectedMapType extends MapType, CursorResultTableBackgroundType extends UIBackground>(options?: EngineOptions & MapChartOptions<SelectedMapType, CursorResultTableBackgroundType>) => MapChart<SelectedMapType, CursorResultTableBackgroundType>;
        /**
         * Factory for `Chart3D`. This chart visualizes data in three dimensions.
         * It has built-in *Axis* and *camera* functionality, and supports a collection of different *series* types.
         *
         * To learn more about its features, refer to {@link Chart3D}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `Chart3D` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.Chart3D({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `Chart3D` specific properties, refer to {@link ChartOptions3D}.
         *
         * @param options - Optional object with readonly configuration arguments for `Chart3D`.
         * @returns Created chart.
         * @public
         */
        Chart3D: (options?: EngineOptions & ChartOptions3D) => Chart3D;
        /**
         * Create a {@link DataGrid} component.
         * This component visualizes data inside a grid structure using a variety of methods, such as text, numbers, spark charts and colored backgrounds.
         *
         * To learn more about its features, refer to {@link DataGrid}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `DataGrid` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create data grid inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const dataGrid = LightningChart.DataGrid({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For the full list of readonly configuration properties, refer to {@link EngineOptions}.
         *
         * @param options - Options object for creating a DataGrid.
         * @returns             DataGrid.
         * @public
         */
        DataGrid: (options?: EngineOptions) => DataGrid;
        /**
         * Create a {@link BarChart} component.
         * Chart type for visualizing categorical data as Bars.
         * Supports Positive and Negative data sets (baseline 0), and Bipolar data sets. These are automatically detected.
         *
         * To learn more about its features, refer to {@link BarChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `BarChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create bar chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.BarChart({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `BarChart` specific properties, refer to {@link BarChartOptions}.
         *
         * @param options - Options object for creating a BarChart.
         * @returns             BarChart.
         * @public
         */
        BarChart: (options?: EngineOptions & BarChartOptions) => BarChart;
        /**
         * Create a {@link ZoomBandChart} component.
         * Chart that is used to display a fully zoomed out view of 1 or more charts or series.
         * It also provides convenient built-in user interactions for interacting with the attached chart(s) that show the zoomed in view.
         *
         * By nature, ZoomBandChart does not host any original data. Rather, it is a duplicate of other data sets in order to simultaneously show both zoomed in view and fully zoomed out view.
         *
         * To learn more about its features, refer to {@link ZoomBandChart}.
         *
         * **Readonly configuration:**
         *
         * Some properties of `ZoomBandChart` can only be configured when it is created. These arguments are all optional,
         * and are wrapped in a single object parameter:
         *
         * ```typescript
         *  // Example, create chart inside DOM element managed by user. The element must be added to the document, before creating the chart.
         *  const chart = LightningChart.ZoomBandChart({
         *      // Argument can be either *element id* or actual reference to the HTML element.
         *      container: 'my-chart-div'
         *  })
         * ```
         *
         * For general *chart* properties, like specifying DOM container, rendering engine configuration, refer to {@link EngineOptions}.
         *
         * For `ZoomBandChart` specific properties, refer to {@link ZoomBandChartOptions}.
         *
         * @param options - Options object for creating a ZoomBandChart.
         * @returns ZoomBandChart.
         * @public
         */
        ZoomBandChart: (options?: EngineOptions & ZoomBandChartOptions) => ZoomBandChart;
        /**
         * Dispose the shared context rendering engine and all of the charts created with it.
         * @public
         */
        dispose(): void;
    }
    /**
     * Function for initializing the LightningChart library.
     *
     * Returns the main interface of LCJS, which is used to create all top level components - *charts* and *dashboards*.
     *
     * ```typescript
     *  const lcjs = lightningChart({
     *      // Either supply license number, or omit for automatic community license.
     *      // license: 'my-license-number'
     *  })
     *
     *  // Create charts...
     *  const chart = lcjs.ChartXY()
     * ```
     *
     * - More information of available chart types and options: {@link LightningChart}
     * - More information of top level *LCJS* configuration (licensing, etc.): {@link LightningChartOptions}
     *
     *
     * @param arg1 - Object containing any properties supported by {@link LightningChartOptions} interface. Most importantly used for supplying *license* information.
     *                  *string* license can be supplied to support old syntax, but **this will be deprecated eventually**, consider using `{ license: 'my-license' }` syntax instead.
     * @param arg2 - Additional information for license verification. Only required by Application Deployment license.
     *                  Consider using `{ licenseInformation: ... }` arg1 syntax instead.
     * @returns A *LightningChart* object for creating *Charts* and components.
     * @public
     */
    export declare const lightningChart: (arg1?: LightningChartOptions | string, arg2?: AppDeploymentLicenseInformation) => LightningChart;
    /**
     * Interface for configuring LightningChart JS initialization, before any charts or series are created.
     *
     * Supplied when {@link lightningChart |`lightningChart`} function is called:
     *
     * ```typescript
     *  const lcjs = lightningChart({
     *      // Either supply license number, or omit for automatic community license.
     *      // license: 'my-license-number'
     *  })
     *
     *  // Create charts...
     *  const chart = lcjs.ChartXY()
     * ```
     * @public
     */
    export declare interface LightningChartOptions {
        /**
         * Optional development or deployment license. If omitted, a community license will be used.
         */
        license?: string;
        /**
         * Additional information for license verification. Only required by Application Deployment license.
         */
        licenseInformation?: AppDeploymentLicenseInformation;
        /**
         * Optionally supplieable data structure for overriding mouse buttons that trigger user interactions.
         *
         * See {@link OverrideInteractionMouseButtons} for full list of supported overrides.
         *
         * Example usage:
         *
         * - Swap ChartXY panning and zoom/fit mouse buttons.
         *
         * ```typescript
         *  const lcjs = lightningChart({
         *      // LightningChartOptions
         *      overrideInteractionMouseButtons: {
         *          chartXYPanMouseButton: 0, // LMB
         *          chartXYRectangleZoomFitMouseButton: 2, // RMB
         *      }
         *  })
         *
         *  // Create charts...
         *  const chart = lcjs.ChartXY()
         * ```
         */
        overrideInteractionMouseButtons?: OverrideInteractionMouseButtons;
        /**
         * Specify URL path to file server that hosts LightningChart JS resources.
         *
         * LightningChart JS is distributed along with some resource files, which are required for select features only:
         * - {@link MapChart} (`resources/maps/`)
         * - {@link OnScreenMenu} (`resources/osm/`)
         * - Themes with background pictures (`resources/themes`)
         *
         * When any of these features are used, the user has to ensure that the necessary resources are hosted on a file server where LightningChart JS can fetch them.
         * In official LightningChart JS example frameworks, templates and projects, this setup is usually done beforehand.
         *
         * _Example local file server with `http-server` from `node_modules`:_
         *
         * ```
         *  npm i --global http-server
         *  cd node_modules/@arction/lcjs/dist/resources
         *  http-server --cors
         * ```
         *
         * ```js
         *  const lcjs = lightningChart({
         *      resourcesBaseUrl: 'http://127.0.0.1:8081', // <--- or whichever port http-server assigned.
         *  })
         * ```
         *
         * **Node Js:**
         *
         * When using LightningChart JS in Node JS environment with [lcjs-headless](https://github.com/Arction/lcjs-headless) you will need to provide a path to the resource files.
         * This path needs to be provided with syntax `fs:<path>`. For example:
         *
         * ```js
         *  const lcjs = lightningChart({
         *      resourcesBaseUrl: `fs:${path.resolve(__dirname, 'node_modules', '@arction', 'lcjs', 'dist', 'resources')}`
         *  })
         * ```
         *
         * **Troubleshooting:**
         *
         * If LightningChart JS can't fetch any required resource, it will result in an error.
         * Here is a list of common resource issues:
         *
         * **1. Resources are not hosted.**
         *
         * In LightningChart JS template projects, the hosting of resources is built-in.
         * However, in users own projects, it is the users responsibility to setup a file server for LightningChart JS resources if they are required.
         *
         * **2. Resources server URL is wrong.**
         *
         * Please make sure that the configured `resourcesBaseUrl` points to URL landing inside `resources` folder.
         *
         * `resourcesBaseUrl` should not end with a `'/'`.
         * For example, `'http://127.0.0.1:8081'` is a valid value. `'http://127.0.0.1:8081/'` might result in an error.
         *
         * **3. Request is CORS blocked.**
         *
         * A common issue especially when first starting development / testing.
         * For example, when hosting `resources` folder with `http-server` *npm module*, the extra `cors` flag must be supplied.
         *
         * ```bash
         *  cd node_modules/@arction/lcjs/dist/resources
         *  http-server --cors
         * ```
         */
        resourcesBaseUrl?: string;
        /**
         * Optional configuration for instructing desired reaction to warnings that can have small side-effects, like decreasing performance or which might indicate issues in application code.
         *
         * By default these warnings are enabled, which might result in some output to browser console, stdout or such channels.
         *
         * By setting `warnings` to `false`, this kind of warnings can be disabled.
         *
         * ```js
         *  // Example syntax, disable low-level warnings.
         *  const chart = lightningChart({
         *      warnings: false
         *  }).ChartXY()
         * ```
         */
        warnings?: boolean;
        /**
         * Options for shared context rendering.
         */
        sharedContextOptions?: {
            /**
             * Provide specific canvas element to use for rendering.
             *
             * Allows for more complex layout scenarios. Needed when HTML content is both under and above the charts.
             */
            canvas?: HTMLCanvasElement | string;
            /**
             * Prevent LCJS from adding it's default CSS styles to the canvas element.
             *
             * Can be useful in more complex layout scenarios.
             */
            noCanvasStyles?: boolean;
            /**
             * Disable LCJS automatically moving the canvas with scrolling to keep it in static position relative to browser viewport.
             *
             * Can be useful in more complex layout scenarios.
             */
            noCanvasTransform?: boolean;
            /**
             * Pass instructions regarding WebGL (rendering engine framework).
             */
            webgl?: {
                /**
                 * Force specific WebGL version to be used.
                 *
                 * LightningChart JS supports WebGL versions 2 and 1.
                 * WebGL 2 is used when available (better performance).
                 *
                 * If a specific version is selected, then it is always used, or if it is not available then the chart will crash.
                 * This can be useful for debugging a specific WebGL version.
                 */
                version?: 'webgl1' | 'webgl2';
            };
            /**
             * Set preference for anti-aliasing.
             *
             * If set to true or undefined and browser supports anti-aliasing then the chart will be anti-aliased. If set to false or browser
             * doesn't support anti-aliasing then the chart will not be anti-aliased.
             */
            antialias?: boolean;
            /**
             * Device pixel ratio to use for composing the charts to final canvas.
             * Can be different from the pixel ratio used to render the charts.
             */
            devicePixelRatio?: boolean | number;
            /**
             * Disable automatic stacking order updates.
             *
             * Only used when not using individual canvas rendering method.
             *
             * This can improve performance on large dom trees when stacking of charts on top of each other is not required.
             *
             * Set to `false` to disable.
             * Enabled by default.
             */
            useStackingOrder?: boolean;
            /**
             * Enable the usage of individual canvas rendering.
             *
             * This rendering method provides better support for more complex web site layouts. The tradeoff is that on some browsers it adds significant overhead slowing down rendering.
             *
             * When enabled, each chart will have it's own canvas placed inside of the given container. This allows normal CSS and HTML layout usage to create complex overlapping layouts.
             *
             * The default rendering method uses a single canvas to render all charts. This provides a lot more consistent performance but comes with the drawback of making overlapping layouts harder to do and sometimes impossible.
             */
            useIndividualCanvas?: boolean;
        };
    }
    /**
     * Super class for LineSeries3D and PointLineSeries3D.
     *
     * Sub-classes only differ on joint styling logic.
     * @public
     */
    export declare abstract class LineAndPointSeries3D extends Series3D implements XYZDataInput, AttachableWithLUT {
        /**
         * Set stroke style of Series.
         *
         * Supported line styles:
         * - {@link SolidLine}
         *
         * ```ts
         *  // Example syntax, specify LineStyle
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
         *  }))
         * ```
         *
         * ```ts
         *  // Example syntax, change active LineStyle
         *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(5))
         * ```
         *
         * Use `-1` thickness to enable primitive line rendering.
         * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
         * ```typescript
         *  LineSeries3D.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
         * ```
         *
         * - **Supported fill styles:**
         *
         * {@link SolidFill}:
         *
         * Solid color for entire line series.
         *
         * ```ts
         *  // Example, solid colored line.
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
         *  }))
         * ```
         *
         * To learn more about available *Color* factories, see {@link ColorRGBA}
         *
         * {@link PalettedFill}:
         *
         * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
         *
         * ```ts
         *  // Example, dynamic color by Y coordinates
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new PalettedFill({
         *          lookUpProperty: 'y',
         *          lut: new LUT({
         *              interpolate: true,
         *              steps: [
         *                  { value: 0, color: ColorRGBA(255, 0, 0) },
         *                  { value: 100, color: ColorRGBA(0, 255, 0) },
         *              ]
         *          })
         *      })
         *  }))
         * ```
         *
         * To learn more about Color lookup tables, see {@link LUT}.
         *
         * - **Primitive 3D line rendering**
         *
         * `LineSeries3D` has a special feature for drawing *primitive* line sets.
         *
         * When enabled, this will draw all line segments as exactly 1 pixel thick on the monitor (regardless of distance from camera).
         *
         * As a benefit, this is considerably lighter on the GPU, which is especially good with mobile and laptop devices with weak GPUs.
         *
         * *Primitive* drawing is enabled by setting stroke thickness to `-1`:
         *
         * ```ts
         *  // Enable primitive 3D line drawing.
         *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(-1))
         * ```
         *
         * - **Other information**
         *
         * In 3D, line thickness is not configured exactly as pixels (since the size of pixel is not affected by distance from camera).
         *
         * However, for usage convenience, you can consider line thickness in 3D as pixels just the same as 2D,
         * even if the resulting visualization will have some differences.
         *
         * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
         * @returns Object itself for fluent interface.
         * @public
         */
        setStrokeStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
        /**
         * Get normal line style (not highlighted).
         * @returns LineSeriesStyle3D
         * @public
         */
        getStrokeStyle(): LineSeriesStyle3D;
        /**
         * Add point or array of points to the series.
         * @param data - Point3D or array of points
         * @returns Object itself for fluent interface
         * @public
         */
        add(data: Point3D | Point3D[]): this;
        /**
         * Clear all previously pushed data points from the *series*.
         *
         * ```ts
         *  // Example usage
         *  LineSeries.clear()
         * ```
         *
         * @returns Object itself for fluent interface.
         * @public
         */
        clear(): this;
        /**
         * Get amount of points that series currently has.
         * @returns Number of points
         * @public
         */
        getPointAmount(): number;
        /**
         * Attach object to an legendBox entry
         * @param entry           -  Object which has to be attached
         * @param toggleVisibilityOnClick   -    Flag that indicates whether the Attachable should be hidden or not,
         *                          when its respective Entry is clicked.
         * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
         * @returns Object itself for fluent interface
         * @public
         */
        attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
    }
    /**
     * Linear Gradient fill style.
     *
     * Instances of LinearGradientFill are *immutable*, meaning that its setters don't modify the object,
     * but instead return a completely new modified object.
     * @public
     */
    export declare class LinearGradientFill extends LinearGradientFillStyleRecord implements Gradient, FillStyle {
        /** @public */
        constructor(props?: Partial<LinearGradientFillStyleProperties>);
        /**
         * Set color stops for the gradient.
         * @param stops - Color Stops
         * @public
         */
        setColorStops(stops: ColorStop[]): this;
        /**
         * Get current color stops from the gradient.
         * @public
         */
        getColorStops(): ColorStop[];
        /**
         * Set the angle of the gradient line in degrees or radians.
         * @param angle - Angle in degrees or radians. 0 degrees/radians is up. Clockwise rotation.
         * @param isRadians - Pass `true` if the angle provided is in radians.
         * @public
         */
        setAngle(angle: number, isRadians?: boolean): this;
        /**
         * Get the angle of the gradient line in degrees or radians.
         * @param isRadians - Pass `true` if radians is wanted.
         * @public
         */
        getAngle(isRadians?: boolean): number;
    }
    /**
     * Factory for creating a LinearGradientFill palette.
     * @param colorPalettes - Collection of default colors from PaletteFactory
     * @param amount - Amount of colors in the palette
     * @param angle - Angle for the Linear Gradient. Set to 90 degrees by default.
     * @returns A new LinearGradientFill palette
     * @public
     */
    export declare const LinearGradientFillPalette: (colorPalettes: PaletteFactory<Color>, amount: number, angle?: number, color?: Color) => Palette<FillStyle>;
    /**
     * Interface for all properties of a LinearGradient.
     * @public
     */
    export declare interface LinearGradientFillStyleProperties {
        type: 'fillstyle';
        fillType: 'linear-gradient';
        /**
         * Gradient Color stops
         */
        stops: ColorStop[];
        /**
         * Gradient angle in degrees
         */
        angle: number;
    }
    /**
     * Record contractor for LinearGradientFillStyleProperties.
     * @public
     */
    declare const LinearGradientFillStyleRecord: Record_2.Factory<LinearGradientFillStyleProperties>;
    /**
     * Implementation of Linear rendering Scale.
     * @public
     */
    declare class LinearScale1D extends ViewportScale1D {
        /**
         * Translate a pixel position on the viewport into corresponding coordinate on the Scale.
         * ( Viewport -\> Axis ).
         * @param viewportPosition - Position on viewport as pixels.
         * @returns Respective coordinate on Scale.
         */
        _getValueFromPixels(viewportPosition: pixel): number;
        /**
         * @returns Scale pixel size
         * @public
         */
        getPixelSize(): number;
        /**
         * Method that computes what pixel size the Scale would have, given its inner interval was equal to a supplied value.
         * @param innerInterval - Supposed inner interval.
         * @returns Pixel size.
         */
        _computePixelSize(innerInterval: number): number;
    }
    /**
     * Implementation of ScaleXY for a combination of two Linear Scales.
     *
     * Should be used in XY scales with only Linear scales (e.g. UI scales and Axis scales when no logarithmic scales are specified).
     */
    declare class LinearScaleXY extends ScaleXY<LinearScale1D> {
    }
    /**
     * Interface for a series which contains lines
     * @public
     */
    export declare interface Lined {
        /**
         * Set lines style
         * @param value - Line style object or function which modifies it
         * @returns Series object (self)
         * @public
         */
        setStrokeStyle: (value: LineStyle | ImmutableMutator<LineStyle>) => this;
        /**
         * @returns Current lines style
         * @public
         */
        getStrokeStyle: () => LineStyle;
    }
    /**
     * Series type for visualizing a list of {@link Point}s (pair of X and Y coordinates),
     * with a continuous stroke. `LineSeries` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in tens of millions range is rendered in a matter of seconds.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * **Creating LineSeries:**
     *
     * `LineSeries` are created with {@link ChartXY.addLineSeries} method.
     *
     * Some properties of `LineSeries` can only be configured when it is created. These arguments are all optional,
     * and are wrapped in a single object parameter:
     *
     * ```typescript
     *  // Example,
     *  const lineSeries = ChartXY.addLineSeries({
     *      // Specify non-default X Axis to attach series to.
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * To learn about available properties, refer to {@link LineSeriesOptions}.
     *
     * **Frequently used methods:**
     *
     * - Append data points to series | {@link add}
     * - Remove all data points from series | {@link clear}
     * - Configure style of line stroke | {@link setStrokeStyle}
     * - Configure automatic cursor interpolation between data points | {@link setCursorInterpolationEnabled}
     * - Configure cursor enabled | {@link setCursorEnabled}
     * - Configure basis of solving nearest data point for cursor | {@link setCursorSolveBasis}
     * - Destroy series permanently | {@link dispose}
     * - Configure automatic data cleaning | {@link setDataCleaning}
     * - Solve nearest data point from specified location | {@link solveNearestFromScreen}
     *
     * @public
     */
    export declare class LineSeries extends BasicSeries<Point, LinearScaleXY> implements Lined, AttachableWithLUT {
        /**
         * Append a single `XY` coordinate or list of `XY` coordinates into the *series*.
         *
         * ```ts
         *  // Example syntax
         *  LineSeries.add({ x: 0, y: 100 })
         *
         *  LineSeries.add([
         *      { x: 0, y: 100 },
         *      { x: 10, y: 50 },
         *      { x: 20, y: 75 },
         *  ])
         * ```
         *
         * For more methods of appending data into series, see:
         *
         * - {@link addArrayY} | Append only Y coordinates.
         * - {@link addArrayX} | Append only X coordinates.
         * - {@link addArraysXY} | Append X and Y coordinates in separate arrays.
         *
         * **Data gaps**
         *
         * When using {@link LineSeries}, {@link AreaSeries} or other series types which connect data points together,
         * the connections between specific data points can be removed by adding gap data points.
         *
         * A gap data point is specified by using `Number.NaN` as either X or Y coordinate.
         *
         * ```ts
         *  // Example, data gap syntax.
         *  LineSeries.add([
         *      { x: 0, y: 10 },
         *      { x: 1, y: 12 },
         *      { x: 2, y: Number.NaN },
         *      { x: 3, y: 15 },
         *      { x: 4, y: 20 }
         *  ])
         * ```
         *
         * **Additional extra data point properties**
         *
         * There is also a set of extra properties that can be supplied for each data point:
         *
         * - `value`    | Associate data point with a value. Can be used for paletted line coloring, see {@link LineSeriesOptions.individualLookupValuesEnabled} for more details.
         *
         * ```ts
         *  // Example, data point with `value` property
         *  LineSeries.add({
         *      x: 0,
         *      y: 0,
         *      value: 62.5
         *  })
         * ```
         *
         * @param points - Single XY coordinate or list of coordinates.
         * @returns Object itself for fluent interface.
         * @public
         */
        add(points: Point | Point[]): this;
        /**
         * Set mouse interactions enabled or disabled.
         * Disabling mouse-interactions will naturally prevent mouse-driven highlighting from ever happening.
         *
         * Line series mouse interactions are disabled by default.
         * @param state - Specifies state of mouse interactions
         * @returns Object itself for fluent interface
         * @public
         */
        setMouseInteractions(state: boolean): this;
        /**
         * Set stroke style of Series.
         *
         * Supported line styles:
         * - {@link SolidLine}
         * - {@link DashedLine}
         * - {@link emptyLine}
         *
         * ```ts
         *  // Example syntax, specify LineStyle
         *  LineSeries.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
         *  }))
         * ```
         *
         * ```ts
         *  // Example syntax, change active LineStyle
         *  LineSeries.setStrokeStyle((stroke) => stroke.setThickness(5))
         * ```
         *
         * Use `-1` thickness to enable primitive line rendering.
         * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
         * ```typescript
         *  LineSeries.setStrokeStyle((stroke) => stroke.setThickness(-1))
         * ```
         *
         * **Supported fill styles:**
         *
         * {@link SolidFill}:
         *
         * Solid color for entire line series.
         *
         * ```ts
         *  // Example, solid colored line.
         *  LineSeries.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
         *  }))
         * ```
         *
         * To learn more about available *Color* factories, see {@link ColorRGBA}
         *
         * {@link PalettedFill}:
         *
         * Line series supports following look-up modes: `x`, `y` and `value`.
         *
         * `lookUpProperty: 'x' | 'y'`:
         *
         * Color line stroke dynamically based on `x` or `y` coordinate.
         *
         * ```ts
         *  // Example, dynamic color by Y coordinates
         *  LineSeries.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new PalettedFill({
         *          lookUpProperty: 'y',
         *          lut: new LUT({
         *              interpolate: true,
         *              steps: [
         *                  { value: 0, color: ColorRGBA(255, 0, 0) },
         *                  { value: 100, color: ColorRGBA(0, 255, 0) },
         *              ]
         *          })
         *      })
         *  }))
         * ```
         *
         * To learn more about Color lookup tables, see {@link LUT}.
         *
         * `lookUpProperty: 'value'`:
         *
         * Color line stroke dynamically based on separately supplied `value` data set.
         *
         * `value`s are specified when adding data points with {@link add} method.
         *
         * ```ts
         *  // Example, dynamic color by Value data set
         *  LineSeries
         *      .setStrokeStyle(new SolidLine({
         *           thickness: 2,
         *           fillStyle: new PalettedFill({
         *               lookUpProperty: 'value',
         *               lut: new LUT({
         *                   interpolate: true,
         *                   steps: [
         *                       { value: 0, color: ColorRGBA(255, 0, 0) },
         *                       { value: 100, color: ColorRGBA(0, 255, 0) },
         *                   ]
         *               })
         *           })
         *      }))
         *      .add([ {x: 0, y: 0, value: 0}, {x: 1, y: 10, value: 100} ])
         * ```
         *
         * **Data point value properties have to be explicitly enabled before they can be used**, see {@link LineSeriesOptions.individualLookupValuesEnabled} for more details.
         *
         * To learn more about Color lookup tables, see {@link LUT}.
         *
         * {@link LinearGradientFill}:
         *
         * Color line stroke with a linear configurable gradient palette.
         *
         * ```ts
         *  // Example, linear gradient line color
         *  LineSeries.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new LinearGradientFill()
         *  }))
         * ```
         *
         * To learn more about linear gradient configurations, see {@link LinearGradientFill}.
         *
         * {@link RadialGradientFill}:
         *
         * Color line stroke with a radial configurable gradient palette.
         *
         * ```ts
         *  // Example, radial gradient line color
         *  LineSeries.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new RadialGradientFill()
         *  }))
         * ```
         *
         * To learn more about radial gradient configurations, see {@link RadialGradientFill}.
         *
         * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
         * @returns Object itself for fluent interface.
         * @public
         */
        setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get stroke style of Series.
         * @returns LineStyle object
         * @public
         */
        getStrokeStyle(): LineStyle;
        /**
         * Disable automatic data cleaning.
         *
         * ```js
         *  // Example syntax, disable data cleaning.
         *  series.setDataCleaning(undefined)
         * ```
         *
         * @param arg - Data cleaning configuration.
         * @returns Object itself for fluent interface.
         * @public
         */
        setDataCleaning(arg: undefined): this;
        /**
         * Enable automatic data cleaning by `minDataPointCount` configuration.
         *
         * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
         *
         * ```js
         *  // Example syntax for specifying minDataPointCount
         *  series.setDataCleaning({ minDataPointCount: 10000 })
         * ```
         *
         * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
         * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
         *
         * ```js
         *  // Example, enable lazy data cleaning of out of view data.
         *  series.setDataCleaning({ minDataPointCount: 1 })
         * ```
         *
         * @param arg - Data cleaning configuration.
         * @returns Object itself for fluent interface.
         * @public
         */
        setDataCleaning(arg: {
            minDataPointCount: number | undefined;
        }): this;
        /**
         * Set *progressive data cleaning threshold*.
         *
         * This feature allows configuring automatic data cleaning in infinitely scrolling applications.
         *
         * **This feature is only intended for *progressive data patterns*!**
         * To learn of `LineSeries` *data patterns*, refer to {@link LineSeriesOptions.dataPattern}.
         *
         * The *data cleaning threshold* is a position on a single *Axis* (either X or Y) of the series.
         * All data that exists *behind* this threshold, can be cleaned at any convenient time by the rendering engine, releasing memory for more data.
         *
         * The behavior of *data cleaning threshold* is based on the `pattern` argument supplied to {@link LineSeriesOptions.dataPattern}:
         *
         * - `'ProgressiveX'`   -\> *data cleaning threshold* is a position on X Axis. All data points whose `X` coordinate is *less* than the *threshold*, can be cleaned.
         * - `'RegressiveX'`    -\> *data cleaning threshold* is a position on X Axis. All data points whose `X` coordinate is *more* than the *threshold*, can be cleaned.
         * - `'ProgressiveY'`   -\> *data cleaning threshold* is a position on Y Axis. All data points whose `Y` coordinate is *less* than the *threshold*, can be cleaned.
         * - `'RegressiveY'`    -\> *data cleaning threshold* is a position on Y Axis. All data points whose `Y` coordinate is *more* than the *threshold*, can be cleaned.
         *
         * **Example usage:**
         *
         * - Infinitely streaming Line Chart.
         *
         * ```typescript
         *  const series = chart.addLineSeries({
         *      dataPattern: {
         *          // Specify progressive X data.
         *          pattern: 'ProgressiveX'
         *      }
         *  })
         *
         *  // Setup progressive scrolling X Axis.
         *  chart.getDefaultAxisX().setScrollStrategy(AxisScrollStrategies.progressive).setInterval(-1000, 0)
         *
         *  // Setup infinite data stream.
         *  let x = 0
         *  setInterval(() => {
         *      series.add({ x, y: Math.random() * 100 })
         *      x += 1
         *      // Move data cleaning threshold dynamically behind series data to allow data cleaning of old data.
         *      const dcThreshold = series.getXMax() - 1000
         *      series.setDataCleaning({progressiveDataCleaningThreshold: dcThreshold})
         *  }, 1000 / 60)
         * ```
         *
         * @param dataCleaningThreshold - Data cleaning threshold value or `undefined` to disable data cleaning based on *threshold*.
         * @returns Object itself.
         * @public
         */
        setDataCleaning(arg: {
            progressiveDataCleaningThreshold: number | undefined;
        }): this;
        /**
         * Set if cursor interpolates solved data-points along series by default.
         *
         * ```typescript
         *  // Example, disable default interpolation of progressiveX line series.
         *  const series = ChartXY.addLineSeries({
         *      dataPattern: {
         *          pattern: 'ProgressiveX'
         *      }
         *  })
         *      .setCursorInterpolationEnabled(false)
         * ```
         *
         * Cursor interpolation is only supported with a collection of configuration combinations:
         *
         * - *Freeform data* + *cursor solve basis* = `'nearest'`
         * - *ProgressiveX data* + *cursor solve basis* = `'nearestX'`
         * - *ProgressiveY data* + *cursor solve basis* = `'nearestY'`
         *
         * With any other combination, or if cursor interpolation is disabled, the closest actual data point will be selected.
         *
         * **Related information:**
         * - Information about specifying series *data pattern* {@link LineSeriesOptions.dataPattern}
         * - *Cursor solve basis* {@link LineSeries.setCursorSolveBasis}
         *
         * **Related API:**
         *
         * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
         * - {@link setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
         * - {@link setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
         * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
         *
         * @param state - Boolean flag
         * @returns Object itself for fluent interface
         * @public
         */
        setCursorInterpolationEnabled(state: boolean): this;
        /**
         * Get if cursor interpolates solved data-points along series by default.
         *
         * Cursor interpolation is only supported if the `LineSeries` follows a *progressive data-pattern*, refer to {@link ChartXY.addLineSeries} for
         * more information on *data-patterns*.
         * @returns Boolean flag
         * @public
         */
        getCursorInterpolationEnabled(): boolean;
        /**
         * Set basis of solving data point nearest to a given location from this series.
         *
         * Default configuration is `'nearest-x'`.
         *
         * ```typescript
         *  // Example, configure series cursor to snap to closest data point along both X and Y dimensions.
         *  LineSeries.setCursorSolveBasis('nearest')
         * ```
         *
         * **Related API:**
         *
         * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
         * - {@link setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
         * - {@link setCursorInterpolationEnabled} | configure automatic cursor interpolation between data points enabled.
         * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
         *
         * @param basis - String describing the desired solve behavior.
         * @public
         */
        setCursorSolveBasis(basis: 'nearest' | 'nearest-x' | 'nearest-y'): this;
        /**
         * Get basis of solving data point nearest to a given location from this series.
         *
         * Default configuration is `'nearest'`.
         *
         * @returns String describing the desired solve behavior.
         * @public
         */
        getCursorSolveBasis(): 'nearest' | 'nearest-x' | 'nearest-y';
        /**
         * Attach object to an legendBox entry
         * @param entry - Object which has to be attached
         * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
         *                          when its respective Entry is clicked.
         * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
         * @returns Series itself for fluent interface
         * @public
         */
        attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
        /**
         * Method for solving the nearest data point from a given coordinate on screen.
         *
         * ```ts
         *  // Example usage, from mouse move event.
         *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
         *      const result = LineSeries.solveNearestFromScreen(event)
         *  })
         * ```
         *
         * ```ts
         *  // Example usage, arbitrary coordinate on client coordinate system.
         *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
         * ```
         *
         * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
         *
         * @param   location -  Location in HTML client coordinates.
         * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
         * @public
         */
        solveNearestFromScreen(location: CoordinateClient, interpolate?: boolean): undefined | CursorPoint;
        /**
         * Solves the nearest data point to a given coordinate on screen.
         * @param location - Location on screen
         * @returns Undefined or data-structure for positioning of cursors
         * @public
         * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
         */
        solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
    }
    /**
     * Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke.
     *
     * `LineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
     *
     * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
     * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
     *
     * **Creating LineSeries3D:**
     *
     * `LineSeries3D` are created with {@link Chart3D.addLineSeries} method.
     *
     * ```typescript
     *  // Example syntax, create line series 3D
     *  const lineSeries3D = Chart3D.addLineSeries()
     * ```
     *
     * **Frequently used methods:**
     *
     * - Append data points to series | {@link add}
     * - Remove all data points from series | {@link clear}
     * - Configure style of line stroke | {@link setStrokeStyle}
     * - Destory series permanently | {@link dispose}
     *
     * **Color shading style**.
     *
     * By default, `LineSeries3D` uses _Phong_ shading style.
     *
     * This can be changed with `LineSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
     *
     * **Related information:**
     *
     * To combine line stroke with markers over each data coordinate, {@link PointLineSeries3D} can be used.
     * @public
     */
    export declare class LineSeries3D extends LineAndPointSeries3D {
        /**
         * Set stroke style of Series.
         *
         * ```ts
         *  // Example syntax, specify LineStyle
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
         *  }))
         * ```
         *
         * ```ts
         *  // Example syntax, change active LineStyle
         *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(5))
         * ```
         *
         * Use `-1` thickness to enable primitive line rendering.
         * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
         * ```typescript
         *  LineSeries3D.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
         * ```
         *
         * - **Supported fill styles:**
         *
         * {@link SolidFill}:
         *
         * Solid color for entire line series.
         *
         * ```ts
         *  // Example, solid colored line.
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
         *  }))
         * ```
         *
         * To learn more about available *Color* factories, see {@link ColorRGBA}
         *
         * {@link PalettedFill}:
         *
         * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
         *
         * ```ts
         *  // Example, dynamic color by Y coordinates
         *  LineSeries3D.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new PalettedFill({
         *          lookUpProperty: 'y',
         *          lut: new LUT({
         *              interpolate: true,
         *              steps: [
         *                  { value: 0, color: ColorRGBA(255, 0, 0) },
         *                  { value: 100, color: ColorRGBA(0, 255, 0) },
         *              ]
         *          })
         *      })
         *  }))
         * ```
         *
         * To learn more about Color lookup tables, see {@link LUT}.
         *
         * - **Primitive 3D line rendering**
         *
         * `LineSeries3D` has a special feature for drawing *primitive* line sets.
         *
         * When enabled, this will draw all line segments as exactly 1 pixel thick on the monitor (regardless of distance from camera).
         *
         * As a benefit, this is considerably lighter on the GPU, which is especially good with mobile and laptop devices with weak GPUs.
         *
         * *Primitive* drawing is enabled by setting stroke thickness to `-1`:
         *
         * ```ts
         *  // Enable primitive 3D line drawing.
         *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(-1))
         * ```
         *
         * - **Other information**
         *
         * In 3D, line thickness is not configured exactly as pixels (since the size of pixel is not affected by distance from camera).
         *
         * However, for usage convenience, you can consider line thickness in 3D as pixels just the same as 2D,
         * even if the resulting visualization will have some differences.
         *
         * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
         * @returns Object itself for fluent interface.
         * @public
         */
        setStrokeStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
    }
    /**
     * Interface for readonly configuration of {@link LineSeries}.
     *
     * **Commonly used properties:**
     * - {@link LineSeriesOptions.xAxis}: Attach series on non-default X Axis.
     * - {@link LineSeriesOptions.yAxis}: Attach series on non-default Y Axis.
     * - {@link LineSeriesOptions.dataPattern}: Enable powerful application specific optimizations if input data follows a *specific pattern*.
     *
     * **Example usage:**
     *
     * ```typescript
     *  // Example 1, create series with default configuration.
     *  const series = ChartXY.addLineSeries({})
     * ```
     *
     * ```typescript
     *  // Example 2, attach series to non-default X Axis.
     *  const series = ChartXY.addLineSeries({
     *      xAxis: myNonDefaultAxisX
     *  })
     * ```
     *
     * ```typescript
     *  // Example 3, specify progressive X data pattern for enabling application specific optimizations.
     *  const series = ChartXY.addLineSeries({
     *      dataPattern: {
     *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
     *          pattern: 'ProgressiveX',
     *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
     *          regularProgressiveStep: true,
     *      }
     *  })
     * ```
     *
     * See also {@link ChartXY.addLineSeries}.
     * @public
     */
    export declare interface LineSeriesOptions extends SeriesOptionsXY {
        /**
         * Interface for enabling powerful application specific optimizations if input data follows a *specific pattern*.
         *
         * See {@link DataPattern} to learn if your data is eligible for such optimizations.
         *
         * **Example usage:**
         *
         * ```typescript
         *  // Example, Line Chart with timestamp X values that always progress by exactly 1 minute (60000 ms).
         *  // => 'ProgressiveX' + regularProgressiveStep can be used
         *  ChartXY.addLineSeries({
         *      dataPattern: {
         *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
         *          pattern: 'ProgressiveX',
         *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
         *          regularProgressiveStep: true,
         *      }
         *  })
         * ```
         */
        dataPattern?: DataPattern;
        /**
         * Flag that can be used to enable data points `value` property on top of `x` and `y`.
         * By default this is disabled.
         *
         * This feature can be used to color data points individually by dynamic color look up.
         *
         * If required, this must be enabled **when the series is created**.
         *
         * ```ts
         *  // Example, enable LineSeries data `value` property.
         *  const lineSeries = chart.addLineSeries({
         *      individualLookupValuesEnabled: true
         *  })
         *
         *  // 'value' property can now be included in data points.
         *  lineSeries.add([
         *      { x: 0, y: 0, z: 0, value: 5 }
         *  ])
         * ```
         *
         * `individualLookupValuesEnabled` must be enabled in order to style `LineSeries` with {@link PalettedFill} of `lookUpProperty: 'value'`.
         *
         * ```ts
         *  // Example, enable line coloring based on `value` property.
         *  lineSeries.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new PalettedFill({
         *          lookUpProperty: 'value',
         *          lut: new LUT({
         *              interpolate: true,
         *              steps: [
         *                  { value: 0, color: ColorRGBA(255, 0, 0) },
         *                  { value: 100, color: ColorRGBA(0, 255, 0) },
         *              ]
         *          })
         *      })
         *  }))
         * ```
         */
        individualLookupValuesEnabled?: boolean;
    }
    /**
     * Type union of LineStyle types supported by LineSeries3D.
     *
     * Supports only `PalettedFill` and `SolidFill` fill styles!
     * @public
     */
    export declare type LineSeriesStyle3D = SolidLine;
    /**
     * Base interface for *line styles*.
     *
     * For implementations with more detailed documentation, see:
     * - {@link SolidLine}
     * - {@link DashedLine}
     * - {@link emptyLine}
     * @public
     */
    export declare interface LineStyle {
        /**
         * @public
         */
        readonly type: 'linestyle';
        /**
         * @public
         */
        readonly lineType: 'solid' | 'empty' | 'dashed';
        /**
         * Construct a new LineStyle object based on this one, but with modified thickness.
         *
         * -1 can be used to signify smallest available thickness.
         * With most features, this will result in slightly better GPU performance, but less detailed line.
         *
         * @param thickness - Thickness as pixels.
         * @public
         */
        setThickness(thickness: number): this;
        /**
         * Get thickness of the LineStyle
         * @returns Thickness as pixels
         * @public
         */
        getThickness(): number;
        /**
         * Construct a new LineStyle object based on this one, but with modified fill style.
         *
         * Example (SolidFill):
         * ```javascript
         * // specify new fillstyle
         * solidLineStyle.setFillStyle( new SolidFill({
         *  color: ColorHex('#F00')
         * }) )
         * // change fillstyle properties
         * solidLineStyle.setFillStyle(
         *  solidfill => solidfill.setA( 80 )
         * )
         * ```
         * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
         * @returns New LineStyle object
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): LineStyle;
        /**
         * Get fill style of the LineStyle.
         * @returns FillStyle object
         * @public
         */
        getFillStyle(): FillStyle;
    }
    /**
     * Implementation of Logarithmic rendering Scale.
     * @public
     */
    declare class LogarithmicScale1D extends ViewportScale1D {
    }
    /**
     * Type union of possible values for 'lookUpProperty' configuration of a {@link PalettedFill}.
     *
     * Points to a property to be used when picking colours from a Look Up Table.
     *
     * - **"value"**: LUT value is taken from a separate value that can be set by user by some Series-specific logic.
     * - **"x"**: LUT value is taken directly from data points X coordinate.
     * - **"y"**: LUT value is taken directly from data points Y coordinate.
     * - **"z"**: LUT value is taken directly from data points Z coordinate.
     *
     * Use alongside {@link PalettedFill} and {@link LUT}.
     * @public
     */
    export declare type LookUpProperty = 'value' | 'x' | 'y' | 'z';
    /**
     * Style class for describing a *table of colors* with associated lookup values (numbers).
     *
     * Instances of LUT, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
     * but instead return a completely new modified object.
     *
     * **Properties of LUT:**
     * - `steps`: List of color steps (color + number value pair).
     * - `interpolate`: `true` enables automatic linear interpolation between color steps.
     *
     * **LUT Behavior:**
     *
     * Example 1, LUT with *interpolation disabled*.
     *
     * ```typescript
     *  const lut = new LUT({
     *      steps: [
     *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
     *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
     *      ],
     *      interpolate: false
     *  })
     * ```
     *
     * | Lookup Value | Color |
     * |--------------|-------|
     * | value \< 10         | black |
     * | 10 \<= value \< 100  | red   |
     * | 100 \<= value       | green |
     *
     *
     * Example 2, LUT with *interpolation enabled*.
     *
     * ```typescript
     *  const lut = new LUT({
     *      steps: [
     *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
     *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
     *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
     *      ],
     *      interpolate: true
     *  })
     * ```
     *
     * | Lookup Value | Color |
     * |--------------|-------|
     * | value \<= 0         | black |
     * | 0 \< value \< 10     | interpolated between black and red |
     * | 10 \< value \< 100   | interpolated between red and green |
     *
     *
     * **LUT Usage:**
     *
     * Use *LUT* with:
     * - {@link PalettedFill} for styling *series* based on different lookup values (user supplied data, x/y/z coordinates, ...)
     * - Sliced charts for styling slices dynamically based on their value
     *      * {@link PieChart.setLUT}
     *      * {@link GaugeChart.setLUT}
     *      * {@link PyramidChart.setLUT}
     *      * {@link FunnelChart.setLUT}
     *
     * @public
     */
    export declare class LUT extends LUTRecord {
        /**
         * Construct a LUT object, specifying any amount of its properties.
         *
         * Example 1, LUT with *interpolation disabled*.
         *
         * ```typescript
         *  const lut = new LUT({
         *      steps: [
         *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
         *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
         *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
         *      ],
         *      interpolate: false
         *  })
         * ```
         *
         * Example 2, LUT with *interpolation enabled*.
         *
         * ```typescript
         *  const lut = new LUT({
         *      steps: [
         *          { value: 0, color: ColorRGBA( 0, 0, 0 ) },
         *          { value: 10, color: ColorRGBA( 255, 0, 0 ) },
         *          { value: 100, color: ColorRGBA( 0, 255, 0 ) }
         *      ],
         *      interpolate: true
         *  })
         * ```
         *
         * @param props - Object containing any amount of LUT properties.
         * @public
         */
        constructor(options: LUTOptions);
        /**
         * Set new collection of LUT steps.
         * @param steps - Collection of color-value pairs.
         * @public
         */
        setSteps(steps: LUTStep[]): this;
        /**
         * Get collection of LUT steps.
         * @returns Collection of steps.
         * @public
         */
        getSteps(): LUTStep[];
        /**
         * Set title of the LUT, which describes the data.
         * @param title - Title of the LUT.
         * @public
         */
        setTitle(title: string): this;
        /**
         * Get title of the LUT.
         * @returns Title of the LUT as string.
         * @public
         */
        getTitle(): string;
        /**
         * Set units of the data-values in the LUT, which describes the data domain.
         * @param units - Units of the LUT.
         * @public
         */
        setUnits(units: string): this;
        /**
         * Get units of the LUT.
         * @returns Units of the LUT as string.
         * @public
         */
        getUnits(): string;
        /**
         * Set interpolation behavior of the LUT, which describes the distribution of color for the data:
         * - True: creates a ***gradient*** LUT using linear-interpolation (LERP) between colors,
         * which were defined in the collection of steps.
         * - False: creates a ***uniform*** LUT using step-function for each color
         * to describe the range of values where this color is used.
         * @param interpolate - Interpolation behavior: True - gradient, False - uniform.
         * @public
         */
        setInterpolation(interpolate: boolean): this;
        /**
         * Get interpolation behavior of the LUT.
         * @returns Intepolation behaviour state. True - gradient, False - uniform.
         * @public
         */
        getInterpolation(): boolean;
        /**
         * Set fallback color.
         * The following color would be used as a backup.
         * Meaning, the LUT might be configured incorrectly or the data is incorrect.
         * @param color - Color object.
         * @public
         */
        setFallbackColor(color: Color): this;
        /**
         * Get fallback color of value the LUT.
         * @returns Color object.
         * @public
         */
        getFallbackColor(): Color;
        /**
         * Get the color associated with the given value.
         *
         * Example:
         * ```javascript
         * const color = lut.getColors( 5 )
         * ```
         * @param values - Single value.
         * @returns Associated color if the LUT is valid, otherwise fallback color.
         * @public
         */
        getColors(values: number): Color;
        /**
         * Get the colors associated with the given collection of values.
         *
         * Example:
         * ```javascript
         * const colors = lut.getColors( [ 5, 10, 15 ] )
         * ```
         * @param values - 1D collection of value.
         * @returns Collection of associated colors if the LUT is valid, otherwise fallback colors.
         * @public
         */
        getColors(values: number[]): Color[];
        /**
         * Get the colors associated with the given collection Matrix2D of values.
         *
         * Example:
         * ```javascript
         * const colors = lut.getColors(
         *  [
         *    [ 3, 7, 9 ],
         *    [ 5, 10, 15 ]
         *  ]
         * )
         * ```
         * @param values - 2D collection of values.
         * @returns Collection of associated colors if the LUT is valid, otherwise fallback colors.
         * @public
         */
        getColors(values: number[][]): Color[][];
    }
    /**
     * Interface defines a *LUT* lookup table configurations.
     * @public
     */
    export declare type LUTOptions = LUTStepsOptions & Partial<ValuePaletteOptions>;
    /**
     * Record constructor for PaletteProperties.
     * @public
     */
    declare const LUTRecord: Record_2.Factory<LUTRecordType>;
    /**
     * Record property object.
     * @public
     */
    export declare type LUTRecordType = LUTStepsOptions & ValuePaletteOptions & LUTStateOptions & {
        type: 'lut';
    };
    /**
     * Interface to define a LUT options which were recomputed after each LUT update.
     * @public
     */
    export declare interface LUTStateOptions {
        /**
         * Amount of LUT steps.
         */
        length: number;
        /**
         * Minimal value of the entire LUT.
         */
        min: number;
        /**
         * Maximal value of the entire LUT.
         */
        max: number;
        /**
         * Collection of subranges.
         */
        subranges: SubRange[];
        /**
         * Validation flag which describes that the LUT is configured correctly.
         */
        isValid: boolean;
    }
    /**
     * Interface to specify the color and its value.
     * Each represented as a pair object \{value: number, color: Color\}.
     * @public
     */
    export declare interface LUTStep {
        /**
         * Value associated with a color.
         */
        value: number;
        /**
         * Color at given step.
         */
        color: Color;
        /**
         * Optional label to show on given step.
         *
         * Can be specified to alter default labels when the component that uses the `LUT` is attached to a `LegendBox`.
         *
         * ```typescript
         *  // Example, map Uint8 data range to Decibels range [0, 140].
         *  const lut = new LUT({
         *      steps: [
         *          { value: 0, label: '0', color: ColorHSV(0) },
         *          { value: 127.5, label: '70', color: ColorHSV(120) },
         *          { value: 255.0, label: '140', color: ColorHSV(240) },
         *      ],
         *      units: 'dB',
         *      interpolate: true,
         *  })
         * ```
         */
        label?: string;
    }
    /**
     * Interface to store the collection of LUTSteps.
     * @public
     */
    export declare interface LUTStepsOptions {
        /**
         * The collection of LUTSteps, which specifies the colors and their corresponding values
         * to describe the location and color of a transition point in a gradient.
         * Each represented as a pair object \{value: number, color: Color\}.
         *
         * Default value: [].
         */
        steps: LUTStep[];
    }
    /**
     * Chart class for visualizing a Map of a selected part of the world. Defaults to the entire world.
     *
     * `MapChart` can be created in two different ways - to learn more about creation time configuration of `MapChart`, please refer to:
     * - {@link LightningChart.Map} (stand-alone chart).
     * - {@link Dashboard.createMapChart} (chart inside *dashboard*).
     *
     * **MapChart features**
     *
     * 1. Map Types
     *
     * `MapChart` supports 9 different *map types*, each of which depicts a different part of the world.
     * *Map types* can also be split based on different types of *regions*, like *countries, states, territories, provinces*, etc.
     *
     * Supported {@link MapTypes | map types}:
     *
     * - `MapTypes.World`         | Map of the whole world, regions as countries.
     * - `MapTypes.Europe`        | Map of Europe, regions as countries.
     * - `MapTypes.Africa`        | Map of Africa, regions as countries.
     * - `MapTypes.Asia`          | Map of Asia, regions as countries.
     * - `MapTypes.NorthAmerica`  | Map of North America, regions as countries.
     * - `MapTypes.SouthAmerica`  | Map of South America, regions as countries.
     * - `MapTypes.Australia`     | Map of Australia, regions as Australian territories.
     * - `MapTypes.USA`           | Map of the United States of America, regions as states.
     * - `MapTypes.Canada`        | Map of Canada, regions as Canadian territories and provinces.
     *
     * Map type is selected when the `MapChart` is created, with the `type` argument:
     *
     * ```typescript
     *  // Example, specify map type.
     *  const mapChart = lightningChart().Map({
     *      type: MapTypes.Europe,
     *  })
     * ```
     *
     * 2. Style and dynamic region coloring
     *
     * `MapChart` has two style properties: region *fill* style and *stroke* style.
     * The style is shared for all regions.
     *
     * Style is configured with
     * - {@link MapChart.setFillStyle}.
     * - {@link MapChart.setStrokeStyle}.
     *
     * Dynamic region coloring is possibly by configuring *fill* style with {@link PalettedFill}.
     *
     * ```typescript
     *  // Example, enable dynamic region coloring based on a color look-up table.
     *  MapChart.setFillStyle(new PalettedFill({
     *      lut: new LUT({
     *          interpolate: true,
     *          steps: [
     *              { value: 0, color: ColorRGBA(255, 0, 0) },
     *              { value: 100, color: ColorRGBA(0, 255, 0) }
     *          ]
     *      })
     *  }))
     * ```
     *
     * Region values used for color look-up are configured with {@link MapChart.invalidateRegionValues}.
     * This method is very flexible and can be used in a variety of ways - refer to the method documentation for more examples.
     *
     * ```typescript
     *  // Example, set value of "Finland" region to `0`.
     *  MapChart.invalidateRegionValues([
     *      { value: 0, ISO_A3: 'FIN' }
     *  ])
     * ```
     *
     * 3. AutoCursor
     *
     * `MapChart` has built-in *AutoCursor* functionality, which is activated when
     * user pointer is above any region.
     *
     * *Auto cursor* can be configured in a variety of ways:
     * - {@link MapChart.setCursorResultTableFormatter} | configure formatting of *result table* contents.
     * - {@link MapChart.setAutoCursor} | style auto cursor.
     * - {@link MapChart.setAutoCursorMode} | disable / enable *auto cursor*.
     *
     *
     * **Required resources:**
     *
     * `MapChart` requires external file resources in order to work.
     * These resources are distributed along with the LightningChart JS package (`node_modules/@arction/lcjs/dist/resources`).
     *
     * In order to use `MapChart` the map resources need to be hosted on a file server.
     * When `MapChart` is created, a GET request will be issued to URL: `<resourcesBaseUrl>/maps/<mapDataFile>`.
     *
     * The file server location can be specified by supplying a `resourcesBaseUrl`, please see {@link LightningChartOptions.resourcesBaseUrl} for general information and troubleshooting on LCJS resources.
     *
     * The following table documents which resource files are required based on used *Map type*:
     *
     * | Map type                   | Map data file                             |
     * | :------------------------- | :---------------------------------------- |
     * | `MapTypes.World`           | `'countries_world.json'`                  |
     * | `MapTypes.Europe`          | `'countries_europe.json'`                 |
     * | `MapTypes.NorthAmerica`    | `'countries_northAmerica.json'`           |
     * | `MapTypes.SouthAmerica`    | `'countries_southAmerica.json'`           |
     * | `MapTypes.Africa`          | `'countries_africa.json'`                 |
     * | `MapTypes.Asia`            | `'countries_asia.json'`                   |
     * | `MapTypes.USA`             | `'states_usa.json'`                       |
     * | `MapTypes.Canada`          | `'territoriesProvinces_canada.json'`      |
     * | `MapTypes.Australia`       | `'territories_australia.json'`            |
     * @public
     */
    export declare class MapChart<SelectedMapType extends MapType = MapType, CursorResultTableBackgroundType extends UIBackground = UIBackground, CursorType extends StaticCursor<CursorResultTableBackgroundType> = StaticCursor<CursorResultTableBackgroundType>> extends Chart implements AttachableWithLUT, Highlightable {
        /**
         * Get region that is currently under mouse.
         * Result is `undefined` if no region is under mouse.
         * @returns     Map region that is under mouse or `undefined`.
         * @public
         */
        getRegionUnderMouse(): MapTypeRegionProperties[SelectedMapType] | undefined;
        /**
         * Set Fill Style of Map regions.
         *
         * **Example usage:**
         *
         * {@link SolidFill}:
         *
         * All Map regions are filled with a single color.
         *
         * ```typescript
         *  // Example, solid color MapChart.
         *  MapChart.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
         * ```
         *
         * {@link PalettedFill}:
         *
         * Each Map region is colored with an individual color.
         * Coloring basis is further based on `lookUpProperty` of the `PalettedFill`:
         *
         * `lookUpProperty: 'value'`:
         *
         * Each region is colored with a solid color that is looked up from the attached {@link LUT}
         * by the active value of that region, as configured with {@link invalidateRegionValues} method.
         *
         * ```typescript
         *  // Example, MapChart color look-up based on region values.
         *  const mapChart = lightningChart().Map({
         *      type: MapTypes.Europe
         *  })
         *  mapChart.setFillStyle(new PalettedFill({
         *      lookUpProperty: 'value',
         *      lut: new LUT({
         *          interpolate: true,
         *          steps: [
         *              { value: 0, color: ColorRGBA(0, 0, 0) },
         *              { value: 100, color: ColorRGBA(0, 255, 0) }
         *          ]
         *      })
         *  }))
         *  // Assign value for "Finland" region.
         *  mapChart.invalidateRegionValues([{ value: 100, ISO_A3: 'FIN' }])
         * ```
         *
         * `lookUpProperty: 'x' | 'y'`:
         *
         * Each pixel color of the map is looked up from the attached {@link LUT} by the respective
         * *longitude* (`'x'`), or *latitude* (`'y'`) coordinate.
         *
         * ```typescript
         *  // Example, MapChart color look-up based on longitude.
         *  const mapChart = lightningChart().Map({
         *      type: MapTypes.Europe
         *  })
         *  mapChart.setFillStyle(new PalettedFill({
         *      lookUpProperty: 'x',
         *      lut: new LUT({
         *          interpolate: false,
         *          steps: [
         *              { value: -180, color: ColorRGBA(0, 0, 0) },
         *              { value: 20, color: ColorRGBA(0, 255, 0) },
         *              { value: 32, color: ColorRGBA(0, 0, 0) },
         *          ]
         *      })
         *  }))
         * ```
         *
         * {@link LinearGradientFill}:
         *
         * Each pixel color of the map is colored according to a *linear gradient*.
         *
         * ```typescript
         *  // Example, color MapChart with linear gradient.
         *  MapChart.setFillStyle(new LinearGradientFill({
         *      angle: 45,
         *      stops: [
         *          { offset: 0.0, color: ColorRGBA(255, 0, 0) },
         *          { offset: 1.0, color: ColorRGBA(0, 255, 0) }
         *      ]
         *  }))
         * ```
         *
         * {@link RadialGradientFill}:
         *
         * Each pixel color of the map is colored according to a *radial gradient*.
         *
         * ```typescript
         *  // Example, color MapChart with radial gradient.
         *  MapChart.setFillStyle(new RadialGradientFill({
         *      position: { x: 0.8, y: 0.7 },
         *      stops: [
         *          { offset: 0.0, color: ColorRGBA(255, 0, 0) },
         *          { offset: 1.0, color: ColorRGBA(0, 0, 255) }
         *      ]
         *  }))
         * ```
         *
         * {@link emptyFill}:
         *
         * Map regions are not filled.
         *
         * @param value - Either a {@link FillStyle} object or a function,
         *                      which will be used to create a new FillStyle based on current Fill Style.
         * @returns MapChart itself.
         * @public
         */
        setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
        /**
         * Get Fill Style of Map regions.
         * @returns FillStyle.
         * @public
         */
        getFillStyle(): FillStyle;
        /**
         * Set Stroke style of Map regions.
         *
         * **Example usage:**
         *
         * {@link SolidLine}:
         *
         * All Map regions edges are drawn with a stroke.
         *
         * ```typescript
         *  // Example, solid region stroke
         *  MapChart.setStrokeStyle(new SolidLine({
         *      thickness: 2,
         *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
         *  }))
         * ```
         *
         * {@link emptyLine}:
         *
         * Regions edges are not drawn with a stroke.
         *
         * @param value - `LineStyle` or function which mutates the active `LineStyle`.
         * @returns Object itself
         * @public
         */
        setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
        /**
         * Get Stroke Style of Map regions.
         * @returns {@link LineStyle}.
             * @public
             */
         getStrokeStyle(): LineStyle;
         /**
          * Set theme effect enabled on component or disabled.
          *
          * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
          * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
          *
          * ```ts
          *  // Example, disable theme effect from a particular component.
          *  Component.setEffect(false)
          * ```
          *
          * For the most part, theme effects are **enabled** by default on most components.
          *
          * Theme effect is configured with {@link Theme.effect} property.
          *
          * @param enabled - Theme effect enabled
          * @returns          Object itself.
          * @public
          */
         setEffect(enabled: boolean): this;
         /**
          * Get theme effect enabled on component or disabled.
          *
          * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
          * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
          *
          * ```ts
          *  // Example, disable theme effect from a particular component.
          *  Component.setEffect(false)
          * ```
          *
          * For the most part, theme effects are **enabled** by default on most components.
          *
          * Theme effect is configured with {@link Theme.effect} property.
          *
          * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
          * @public
          */
         getEffect(): boolean;
         /**
          * Set {@link FillStyle} of *outlier regions* (parts of map that are visible, but not interactable with active map type).
          *
          * ```typescript
          *  // Example usage,
          *  MapChart.setOutlierRegionFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
          * ```
          * @param value - `FillStyle` or function which mutates the active `FillStyle`.
          * @returns Object itself
          * @public
          */
         setOutlierRegionFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
         /**
          * Get {@link FillStyle} of *outlier regions* (parts of map that are visible, but not interactable with active map type).
          *
          * @returns FillStyle
          * @public
          */
         getOutlierRegionFillStyle(): FillStyle;
         /**
          * Set {@link LineStyle} of *outlier regions* (parts of map that are visible, but not interactable with active map type).
          *
          * ```typescript
          *  // Example usage,
          *  MapChart.setOutlierRegionStrokeStyle(new SolidLine({
          *      thickness: 2,
          *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
          *  }))
          * ```
          * @param value - `LineStyle` or function which mutates the active `LineStyle`.
          * @returns Object itself
          * @public
          */
         setOutlierRegionStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
         /**
          * Get {@link LineStyle} of *outlier regions* (parts of map that are visible, but not interactable with active map type).
          *
          * @returns LineStyle
          * @public
          */
         getOutlierRegionStrokeStyle(): LineStyle;
         /**
          * Set {@link FillStyle} of *separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
          *
          * Separate regions are present in following {@link MapTypes | Map types}:
          * - `MapTypes.USA`
          *
          * ```typescript
          *  // Example usage,
          *  MapChart.setSeparateRegionFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
          * ```
          * @param value - `FillStyle` or function which mutates the active `FillStyle`.
          * @returns Object itself
          * @public
          */
         setSeparateRegionFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
         /**
          * Get {@link FillStyle} of *Separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
          *
          * Separate regions are present in following {@link MapTypes | Map types}:
          * - `MapTypes.USA`
          *
          * @returns FillStyle
          * @public
          */
         getSeparateRegionFillStyle(): FillStyle;
         /**
          * Set {@link LineStyle} of *Separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
          *
          * Separate regions are present in following {@link MapTypes | Map types}:
          * - `MapTypes.USA`
          *
          * ```typescript
          *  // Example usage,
          *  MapChart.setSeparateRegionStrokeStyle(new SolidLine({
          *      thickness: 2,
          *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
          *  }))
          * ```
          * @param value - `LineStyle` or function which mutates the active `LineStyle`.
          * @returns Object itself
          * @public
          */
         setSeparateRegionStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
         /**
          * Get {@link LineStyle} of *Separate regions*, which are visual components surrounding areas such as *Alaska* and *Hawaii*.
          *
          * Separate regions are present in following {@link MapTypes | Map types}:
          * - `MapTypes.USA`
          *
          * @returns LineStyle
          * @public
          */
         getSeparateRegionStrokeStyle(): LineStyle;
         /**
          * Invalidate numeric values associated with each *region* of the Map using a callback function that is called for every region.
          *
          * Region values can be used in conjuction with:
          *
          * - DataCursor:
          *
          * The values can be displayed when user puts the mouse above a *region*. Modify DataCursor parsing with
          * {@link MapChart.setCursorResultTableFormatter}
          *
          * - FillStyle:
          *
          * Each *region* can be styled based on its assigned value, by setting the MapCharts' fill style to a
          * {@link PalettedFill}.
          *
          * **Example usage:**
          *
          * ``` ts
          *  // Example, Set a random value [0, 100] for each region.
          *  MapChart.invalidateRegionValues( ( region, prev ) => Math.random() * 100 )
          * ```
          *
          * In a more realistic application, you would look up a value from an external data set based on the `region`.
          * The properties available from `region` are based on the used {@link MapType}, see {@link MapTypeRegionProperties} for a list of supported properties.
          *
          * ```typescript
          *  // Example, invalidate region values by external data set.
          *  fetch(...)
          *      .then((data) => {
          *          MapChart.invalidateRegionValues((region) => {
          *              // Look up value for `region`.
          *              const value = data[region.name]
          *              return value || 0
          *          })
          *      })
          * ```
          *
          * @param callback - Function that is called for each region.
          *                      First parameter is a region data structure, that can be used to identify each region.
          *                      Second parameter is the previous value if any.
          * @returns MapChart itself.
          * @public
          */
         invalidateRegionValues(callback: (region: MapTypeRegionProperties[SelectedMapType], prev?: number) => number | undefined): this;
         /**
          * Invalidate numeric values associated with each *region* of the Map using an Array of identifier-value objects.
          *
          * Region values can be used in conjuction with:
          *
          * - DataCursor:
          *
          * The values can be displayed when user puts the mouse above a *region*. Modify DataCursor parsing with
          * {@link MapChart.setCursorResultTableFormatter}
          *
          * - FillStyle:
          *
          * Each *region* can be styled based on its assigned value, by setting the MapCharts' fill style to a
          * {@link PalettedFill}
          *
          * **Example usage**:
          *
          * - Select region by name or other property supported by the used {@link MapTypes}.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { value: 0, name: 'Finland' }
          *  ])
          * ```
          *
          * In place of 'name', any property supported by the used {@link MapType} can be supplied.
          * Look up {@link MapTypeRegionProperties} for a map of supported properties per *MapType*.
          *
          * ``` ts
          *  // MapTypes that plot *Countries* (for example, 'World', 'Europe') also support 'ISO_A3' country codes.
          *  MapChart.invalidateRegionValues([
          *      { value: 0, ISO_A3: 'FIN' }
          *  ])
          * ```
          *
          * - For quick access, you can also refer to the *region* list of the used *MapType* that is accessed through {@link MapRegions}.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { value: 0, ...MapRegions[ MapTypes.World ].Finland }
          *  ])
          * ```
          *
          * @param values - Array of identifier-value objects.
          * @returns MapChart itself.
          * @public
          */
         invalidateRegionValues(values: Array<(Partial<MapTypeRegionProperties[SelectedMapType]> & {
             value: number;
         }) | undefined>): this;
         /**
          * Mutator function for charts auto cursor.
          * @param mutator - Mutator function for a Cursor
          * @returns Object itself for fluent interface
          * @public
          */
         setAutoCursor(mutator: Mutator<CursorType>): this;
         /**
          * @returns Auto cursor object
          * @public
          */
         getAutoCursor(): CursorType;
         /**
          * Set mode of charts Auto cursor
          * @param mode - Either {@link AutoCursorModes.onHover} or {@link AutoCursorModes.disabled}.
          * @returns Object itself for fluent interface
          * @public
          */
         setAutoCursorMode(mode: AutoCursorModes.onHover | AutoCursorModes.disabled): this;
         /**
          * Get current mode of charts Auto cursor
          * @returns {@link AutoCursorModes}.
              * @public
              */
          getAutoCursorMode(): AutoCursorModes.onHover | AutoCursorModes.disabled;
          /**
           * Set *ResultTable* formatter. Can be used to specify the information that is displayed, when hovering mouse/pointer
           * over a Map region.
           *
           * **Example usage:**
           *
           * - Display *country* name and ISO_A3 code.
           *
           * ``` ts
           *  MapChart.setCursorResultTableFormatter( ( tableContentBuilder, mapRegion, mapRegionValue, longitude, latitude, mapChart ) => tableContentBuilder
           *      .addRow( mapRegion.name )
           *      .addRow( mapRegion.ISO_A3 )
           *  )
           * ```
           *
           * @param formatter - Function which builds ResultTable content.
           *                      See definition of {@link MapChartFormatter} for supplied formatting information.
           * @returns Object itself
           * @public
           */
          setCursorResultTableFormatter(formatter: MapChartFormatter<SelectedMapType>): this;
          /**
           * Get ResultTable Formatter.
           * @returns Function which builds ResultTable content for MapChart.
           * @public
           */
          getCursorResultTableFormatter(): MapChartFormatter;
          /**
           * Add event listener to Enter Event
           * @param clbk - Event listener for Mouse Enter Event
           * @returns Token of the event listener
           * @public
           */
          onMouseEnter: (clbk: MouseEventHandler<this>) => Token;
          /**
           * Add event listener to Mouse Leave Event
           * @param clbk - Event listener for Mouse Leave Event
           * @returns Token of the event listener
           * @public
           */
          onMouseLeave: (clbk: AbruptMouseEventHandler<this>) => Token;
          /**
           * Add event listener to Mouse Click Event
           * @param clbk - Event listener for Mouse Click Event
           * @returns Token of the event listener
           * @public
           */
          onMouseClick: (clbk: MouseEventHandler<this>) => Token;
          /**
           * Add event listener to Mouse Double Click Event
           * @param clbk - Event listener for Mouse Double Click Event
           * @returns Token of the event listener
           * @public
           */
          onMouseDoubleClick: (clbk: MouseEventHandler<this>) => Token;
          /**
           * Add event listener to Mouse Down Event
           * @param clbk - Event listener for Mouse Down Event
           * @returns Token of the event listener
           * @public
           */
          onMouseDown: (clbk: MouseEventHandler<this>) => Token;
          /**
           * Add event listener to Mouse Up Event
           * @param clbk - Event listener for Mouse Up Event
           * @returns Token of the event listener
           * @public
           */
          onMouseUp: (clbk: MouseEventHandler<this>) => Token;
          /**
           * Add event listener to Mouse Move Event
           * @param clbk - Event listener for Mouse Move Event
           * @returns Token of the event listener
           * @public
           */
          onMouseMove: (clbk: MouseEventHandler<this>) => Token;
          /**
           * Subscribe to Mouse Drag Start event
           * @public
           */
          onMouseDragStart(clbk: MouseDragStartEventHandler<this>): Token;
          /**
           * Subscribe to Mouse Drag event
           * @public
           */
          onMouseDrag(clbk: MouseDragEventHandler<this>): Token;
          /**
           * Subscribe to Mouse Drag Stop event
           * @public
           */
          onMouseDragStop(clbk: MouseDragStopEventHandler<this>): Token;
          /**
           * Subscribe to Mouse Wheel event
           * @param clbk - Event handler function
           * @returns Token of subscription
           * @public
           */
          onMouseWheel(clbk: MouseWheelEventHandler<this>): Token;
          /**
           * Subscribe to Touch Start event
           * @param clbk - Event handler function
           * @returns Token of subscription
           * @public
           */
          onTouchStart(clbk: TouchEventHandler<this>): Token;
          /**
           * Subscribe to Touch Move event
           * @param clbk - Event handler function
           * @returns Token of subscription
           * @public
           */
          onTouchMove(clbk: TouchEventHandler<this>): Token;
          /**
           * Subscribe to Touch End event
           * @param clbk - Event handler function
           * @returns Token of subscription
           * @public
           */
          onTouchEnd(clbk: TouchEventHandler<this>): Token;
          /**
           * Remove event listener from Mouse Enter Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseEnter: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Leave Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseLeave: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Click Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseClick: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Double Click Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseDoubleClick: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Down Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseDown: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Up Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseUp: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Move Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseMove: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Drag Start Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseDragStart: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Drag Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseDrag: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Drag Stop Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseDragStop: (token: Token) => boolean;
          /**
           * Remove event listener from Mouse Wheel Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMouseWheel: (token: Token) => boolean;
          /**
           * Remove event listener from Touch Start Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offTouchStart(token: Token): boolean;
          /**
           * Remove event listener from Touch Move Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offTouchMove(token: Token): boolean;
          /**
           * Remove event listener from Touch End Event
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offTouchEnd(token: Token): boolean;
          /**
           * Set mouse interactions enabled or disabled.
           *
           * Disabling mouse interactions will also disable auto-cursor and triggering of events such as:
           * `onMouseClick`, `onMouseMove`.
           *
           * Disabling mouse interactions can have a positive impact on performance.
           *
           * @param state - Specifies state of mouse interactions
           * @returns Object itself for fluent interface
           * @public
           */
          setMouseInteractions(state: boolean): this;
          /**
           * Get mouse interactions enabled or disabled.
           * @returns Mouse interactions state
           * @public
           */
          getMouseInteractions(): boolean;
          /**
           * Set state of component highlighting.
           *
           * ```ts
           *  // Example usage
           *
           *  component.setHighlight(true)
           *
           *  component.setHighlight(0.5)
           * ```
           *
           * If highlight animations are enabled (which is true by default), the transition will be animated.
           * As long as the component is highlighted, the active highlight intensity will be animated continuously between 0 and the configured value.
           * Highlight animations can be disabled with {@link setAnimationHighlight}
           *
           * **In case of MapChart, this method only considers the complete highlighting of MapChart, not highlighting individual regions**
           *
           * This method does not work before map data is loaded. See {@link onMapDataReady}
           *
           * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
           * @returns Object itself
           * @public
           */
          setHighlight(highlight: boolean | number): this;
          /**
           * Get state of component highlighting.
           *
           * In case highlight animations are enabled, this method returns the **unanimated highlight value**.
           *
           * **In case of MapChart, this method only considers the complete highlighting of MapChart, not highlighting individual regions**
           *
           * @returns Number between 0 and 1, where 1 is fully highlighted.
           * @public
           */
          getHighlight(): number;
          /**
           * Set component highlight animations enabled or not.
           * For most components this is enabled by default.
           *
           * ```ts
           *  // Example usage, disable highlight animations.
           *  component.setAnimationHighlight(false)
           * ```
           *
           * This method does not work before map data is loaded. See {@link onMapDataReady}
           *
           * @param   enabled    - Animation enabled?
           * @returns            Object itself
           */
          setAnimationHighlight(enabled: boolean): this;
          /**
           * Get component highlight animations enabled or not.
           *
           * @returns      Animation enabled?
           */
          getAnimationHighlight(): boolean;
          /**
           * Set highlight on mouse hover enabled or disabled.
           *
           * Mouse interactions have to be enabled on the component for this to function as expected.
           * See {@link setMouseInteractions} for more information.
           *
           * @param state - True if highlighting on mouse hover, false if no highlight on mouse hover
           * @returns Object itself for fluent interface.
           * @public
           */
          setHighlightOnHover(state: boolean): this;
          /**
           * Get boolean flag for whether object should highlight on mouse hover
           * @returns Boolean for if object should highlight on mouse hover or not.
           * @public
           */
          getHighlightOnHover(): boolean;
          /**
           * Subscribe to highlight object event. This is called whenever an object is highlighted.
           *
           * **In case of MapChart, this method only considers the complete highlighting of MapChart, not highlighting individual regions**
           * @param handler - Function that is called when event is triggered.
           * @param isHighlighted - The Highlight state.
           * @returns Token that can be used to unsubscribe from the event.
           * @public
           */
          onHighlight(handler: (chart: this, isHighlighted: boolean | number) => void): Token;
          /**
           * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
           *
           * **In case of MapChart, this method only considers the complete highlighting of MapChart, not highlighting individual regions**
           * @param token - Token that was received when subscribing to the event.
           * @returns True if the unsubscription was successful.
           * @public
           */
          offHighlight(token: Token): boolean;
          /**
           * Add event listener to Map Data Ready.
           *
           * If map data is ready when event is attached the callback will be called on the next JS event loop cycle.
           * @param clbk - Event listener for Map Data Ready Event
           * @returns Token of the event listener
           * @public
           */
          onMapDataReady: (clbk: () => void) => Token;
          /**
           * Remove event listener from Map Data Ready event.
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offMapDataReady(token: Token): boolean;
          /**
           * Subscribe to on View Change event.
           *
           * This event is triggered when the geographical view of the Map chart is changed as a side effect of chart resize, padding change, or other reason.
           *
           * It is also fired when the Map chart is first displayed.
           *
           * The view change event can be used for aligning other geographically positioned components over the Map chart.
           * Mainly, it is designed for convenience of usage with `ChartXY` that is laid over a `MapChart`.
           *
           * See our [Interactive Examples gallery for examples of this](https://lightningchart.com/lightningchart-js-interactive-examples/search.html?t=map).
           *
           * ```typescript
           *  // Example syntax.
           *  mapChart.onViewChange((view) => {
           *      console.log(view)
           *  })
           * ```
           *
           * @param clbk - Callback to trigger when the event is fired.
           * @returns Token of the event listener
           * @public
           */
          onViewChange: (clbk: (view: MapChartView) => unknown) => Token;
          /**
           * Remove event listener from View Change event.
           * @param token - Token of event listener which has to be removed
           * @returns True if the listener is successfully removed and false if it is not found
           * @public
           */
          offViewChange(token: Token): boolean;
          /**
           * Disable/Enable all animations of the Chart.
           * @param animationsEnabled - Boolean value to enable or disable animations.
           * @returns Chart itself for fluent interface.
           * @public
           */
          setAnimationsEnabled(animationsEnabled: boolean | undefined): this;
          /**
           * Get animations disable/enable state.
           * @returns Animations default state.
           * @public
           */
          getAnimationsEnabled(): boolean;
          /**
           * Get minimum size of Panel.
           * Depending on the type of class this value might be automatically computed to fit different elements.
           * @returns Vec2 minimum size or undefined if unimplemented
           * @public
           */
          getMinimumSize(): Point | undefined;
          /**
           * **Permanently** destroy the component.
           *
           * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
           * **to the component and its children** in application code.
           * ```javascript
           * let chart = ...ChartXY()
           * let axisX = chart.getDefaultAxisX()
           * // Dispose Chart, and remove all references so that they can be garbage-collected.
           * chart.dispose()
           * chart = undefined
           * axisX = undefined
           * ```
           * @returns Object itself for fluent interface
           * @public
           */
          dispose(): this;
          /**
           * Attach object to an legendBox entry
           * @param entry - Object which has to be attached
           * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
           *                          when its respective Entry is clicked.
           * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
           * @returns Series itself for fluent interface
           * @public
           */
          attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
         }
         /**
          * Interface that can be used to define {@link MapChart} configurations, when inside a {@link Dashboard},
          * that can't be changed after creation.
          *
          * **Example usage:**
          *
          * - Specify minimum amount of required configurations ({@link DashboardCellOptions}).
          *
          * ``` ts
          *  const mapChart = lightningChart().Dashboard({
          *      rowIndex: 0,
          *      columnIndex: 0,
          *      rowSpan: 1,
          *      columnSpan: 1
          *  })
          * ```
          *
          * - Specify *MapType*.
          *
          * ``` ts
          *  const mapChart = lightningChart().Dashboard({
          *      rowIndex: 0,
          *      columnIndex: 0,
          *      rowSpan: 1,
          *      columnSpan: 1,
          *      type: MapTypes.USA
          *  })
          * ```
          * @public
          */
         export declare interface MapChartDashboardOptions<SelectedMapType extends MapType, CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, MapChartOptions<SelectedMapType, CursorResultTableBackgroundType> {
         }
         /**
          * Interface for a function which builds ResultTable content when pointing at a SeriesXY.
          *
          * **Example usage:**
          *
          * - Display *country* name and ISO_A3 code.
          *
          * ``` ts
          *  MapChart.setCursorResultTableFormatter( ( tableContentBuilder, mapRegion, mapRegionValue, longitude, latitude, mapChart ) => tableContentBuilder
          *      .addRow( mapRegion.name )
          *      .addRow( mapRegion.ISO_A3 )
          *  )
          * ```
          *
          * @param tableContentBuilder - Builder that is used to build contents of ResultTable.
          *                                  Use addRow() method for adding content.
          * @param mapRegion - Currently pointed *region* on the Map. Type depends on the {@link MapTypes} of the *MapChart*.
          *                                  Refer to {@link MapTypeRegionProperties} if you're unsure.
          * @param mapRegionValue - Data value of pointed *region*, as configured with {@link MapChart.invalidateRegionValues}.
          * @param longitude - Pointed map coordinate *longitude*.
          * @param latitude - Pointed map coordinate *latitude*.
          * @param mapChart - Reference to the {@link MapChart} object.
          * @returns TableContentBuilder that was supplied.
          * @public
          */
         export declare type MapChartFormatter<SelectedMapType extends MapType = MapType> = <T extends TableContentBuilder>(tableContentBuilder: T, mapRegion: MapTypeRegionProperties[SelectedMapType], mapRegionValue: undefined | number, longitude: number, latitude: number, mapChart: MapChart<SelectedMapType>) => T;
         /**
          * Interface that can be used to define *Map Chart* configurations that can't be changed after creation.
          *
          * **Example usage:**
          *
          * - Specify *MapType*.
          *
          * ``` ts
          *  const mapChart = lightningChart().Map({
          *      type: MapTypes.USA
          *  })
          * ```
          * @public
          */
         export declare interface MapChartOptions<SelectedMapType extends MapType, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
             /**
              * Preset selection that defines the displayed Map region as well as the type of
              * associated region data (eq. USA -\> states, World -\> countries).
              *
              * Valid options can be referenced via {@link MapTypes}:
              *
              * ``` ts
              *  const mapChart = lightningChart().Map({
              *      type: MapTypes.USA
              *  })
              * ```
              * @public
              */
             type?: SelectedMapType;
             /**
              * Builder for the Charts AutoCursor. If omitted, a default one will be used.
              * AutoCursorBuilders.Map can be used to build a custom one from scratch.
              * @public
              */
             autoCursorBuilder?: StaticCursor2DBuilder<CursorResultTableBackgroundType>;
         }
         /**
          * Data structure which describes the geographical view of a {@link MapChart}.
          *
          * Can be received via {@link MapChart.onViewChange} method.
          * @public
          */
         export declare interface MapChartView {
             /**
              * Displayed longitude range (east-west position).
              */
             longitudeRange: {
                 start: number;
                 end: number;
             };
             /**
              * Displayed latitude range (north-south position).
              */
             latitudeRange: {
                 start: number;
                 end: number;
             };
             /**
              * Margins around Map chart edges as pixels.
              */
             margin: {
                 left: number;
                 top: number;
                 right: number;
                 bottom: number;
             };
         }
         /**
          * {@link MapTypes} pairing with a list of MapRegions the MapType includes.
          *
          * For example, when using **MapType.Europe**, the list of available *countries* can be referenced with:
          *
          * ```ts
          * const countries = MapRegions[ MapTypes.Europe ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.Europe ].Finland, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.Europe ] ).forEach( key => console.log( key ) )
          * ```
          * @public
          */
         export declare const MapRegions: {
             /**
              * {@link MapRegionsWorld}
              */
             World: {
                 Aruba: Country;
                 Afghanistan: Country;
                 Angola: Country;
                 Anguilla: Country;
                 Albania: Country;
                 Aland: Country;
                 Andorra: Country;
                 'United Arab Emirates': Country;
                 Argentina: Country;
                 /**
                  * {@link MapRegionsWorld}
                  */
                 Armenia: Country;
                 'American Samoa': Country;
                 Antarctica: Country;
                 'French Southern and Antarctic Lands': Country;
                 'Antigua and Barbuda': Country;
                 Australia: Country;
                 Austria: Country;
                 Azerbaijan: Country;
                 Burundi: Country;
                 Belgium: Country;
                 Benin: Country;
                 'Burkina Faso': Country;
                 Bangladesh: Country;
                 Bulgaria: Country;
                 Bahrain: Country;
                 'The Bahamas': Country;
                 'Bosnia and Herzegovina': Country;
                 Belarus: Country;
                 Belize: Country;
                 Bermuda: Country;
                 Bolivia: Country;
                 Brazil: Country;
                 Barbados: Country;
                 Brunei: Country;
                 Bhutan: Country;
                 Botswana: Country;
                 'Central African Republic': Country;
                 Canada: Country;
                 Switzerland: Country;
                 Chile: Country;
                 China: Country;
                 'Ivory Coast': Country;
                 Cameroon: Country;
                 'Cyprus No Mans Area': Country;
                 'Democratic Republic of the Congo': Country;
                 'Republic of Congo': Country;
                 'Cook Islands': Country;
                 Colombia: Country;
                 Comoros: Country;
                 'Cape Verde': Country;
                 'Costa Rica': Country;
                 Cuba: Country;
                 Curaao: Country;
                 'Cayman Islands': Country;
                 'Northern Cyprus': Country;
                 Cyprus: Country;
                 'Czech Republic': Country;
                 Germany: Country;
                 Djibouti: Country;
                 Dominica: Country;
                 Denmark: Country;
                 'Dominican Republic': Country;
                 Algeria: Country;
                 Ecuador: Country;
                 Egypt: Country;
                 Eritrea: Country;
                 'Dhekelia Sovereign Base Area': Country;
                 Spain: Country;
                 Estonia: Country;
                 Ethiopia: Country;
                 Finland: Country;
                 Fiji: Country;
                 'Falkland Islands': Country;
                 France: Country;
                 'Faroe Islands': Country;
                 'Federated States of Micronesia': Country;
                 Gabon: Country;
                 'United Kingdom': Country;
                 Georgia: Country;
                 Guernsey: Country;
                 Ghana: Country;
                 Guinea: Country;
                 Gambia: Country;
                 'Guinea Bissau': Country;
                 'Equatorial Guinea': Country;
                 Greece: Country;
                 Grenada: Country;
                 Greenland: Country;
                 Guatemala: Country;
                 Guam: Country;
                 Guyana: Country;
                 'Hong Kong S.A.R.': Country;
                 'Heard Island and McDonald Islands': Country;
                 Honduras: Country;
                 Croatia: Country;
                 Haiti: Country;
                 Hungary: Country;
                 Indonesia: Country;
                 'Isle of Man': Country;
                 India: Country;
                 'Indian Ocean Territories': Country;
                 'British Indian Ocean Territory': Country;
                 Ireland: Country;
                 Iran: Country;
                 Iraq: Country;
                 Iceland: Country;
                 Israel: Country;
                 Italy: Country;
                 Jamaica: Country;
                 Jersey: Country;
                 Jordan: Country;
                 Japan: Country;
                 'Baykonur Cosmodrome': Country;
                 'Siachen Glacier': Country;
                 Kazakhstan: Country;
                 Kenya: Country;
                 Kyrgyzstan: Country;
                 Cambodia: Country;
                 Kiribati: Country;
                 'Saint Kitts and Nevis': Country;
                 'South Korea': Country;
                 Kosovo: Country;
                 Kuwait: Country;
                 Laos: Country;
                 Lebanon: Country;
                 Liberia: Country;
                 Libya: Country;
                 'Saint Lucia': Country;
                 Liechtenstein: Country;
                 'Sri Lanka': Country;
                 Lesotho: Country;
                 Lithuania: Country;
                 Luxembourg: Country;
                 Latvia: Country;
                 'Macao S.A.R': Country;
                 'Saint Martin': Country;
                 Morocco: Country;
                 Moldova: Country;
                 Madagascar: Country;
                 Maldives: Country;
                 Mexico: Country;
                 'Marshall Islands': Country;
                 Macedonia: Country;
                 Mali: Country;
                 Malta: Country;
                 Myanmar: Country;
                 Montenegro: Country;
                 Mongolia: Country;
                 'Northern Mariana Islands': Country;
                 Mozambique: Country;
                 Mauritania: Country;
                 Montserrat: Country;
                 Mauritius: Country;
                 Malawi: Country;
                 Malaysia: Country;
                 Namibia: Country;
                 'New Caledonia': Country;
                 Niger: Country;
                 Nigeria: Country;
                 Nicaragua: Country;
                 Niue: Country;
                 Netherlands: Country;
                 Norway: Country;
                 Nepal: Country;
                 'New Zealand': Country;
                 Oman: Country;
                 Pakistan: Country;
                 Panama: Country;
                 'Pitcairn Islands': Country;
                 Peru: Country;
                 'Spratly Islands': Country;
                 Philippines: Country;
                 Palau: Country;
                 'Papua New Guinea': Country;
                 Poland: Country;
                 'Puerto Rico': Country;
                 'North Korea': Country;
                 Portugal: Country;
                 Paraguay: Country;
                 Palestine: Country;
                 'French Polynesia': Country;
                 Qatar: Country;
                 Romania: Country;
                 Russia: Country;
                 Rwanda: Country;
                 'Western Sahara': Country;
                 'Saudi Arabia': Country;
                 Sudan: Country;
                 'South Sudan': Country;
                 Senegal: Country;
                 Singapore: Country;
                 'South Georgia and South Sandwich Islands': Country;
                 'Saint Helena': Country;
                 'Solomon Islands': Country;
                 'Sierra Leone': Country;
                 'El Salvador': Country;
                 Somalia: Country;
                 'Saint Pierre and Miquelon': Country;
                 'Republic of Serbia': Country;
                 'Sao Tome and Principe': Country;
                 Suriname: Country;
                 Slovakia: Country;
                 Slovenia: Country;
                 Sweden: Country;
                 Swaziland: Country;
                 Seychelles: Country;
                 Syria: Country;
                 'Turks and Caicos Islands': Country;
                 Chad: Country;
                 Togo: Country;
                 Thailand: Country;
                 Tajikistan: Country;
                 Turkmenistan: Country;
                 'East Timor': Country;
                 Tonga: Country;
                 'Trinidad and Tobago': Country;
                 Tunisia: Country;
                 Turkey: Country;
                 Tuvalu: Country;
                 Taiwan: Country;
                 'United Republic of Tanzania': Country;
                 Uganda: Country;
                 Ukraine: Country;
                 'United States Minor Outlying Islands': Country;
                 Uruguay: Country;
                 'United States of America': Country;
                 'US Naval Base Guantanamo Bay': Country;
                 Uzbekistan: Country;
                 'Saint Vincent and the Grenadines': Country;
                 Venezuela: Country;
                 'British Virgin Islands': Country;
                 'United States Virgin Islands': Country;
                 Vietnam: Country;
                 Vanuatu: Country;
                 'Wallis and Futuna': Country;
                 'Akrotiri Sovereign Base Area': Country;
                 Samoa: Country;
                 Yemen: Country;
                 'South Africa': Country;
                 Zambia: Country;
                 Zimbabwe: Country;
                 'French Guyana': Country;
             };
             /**
              * {@link MapRegionsUSA}
              */
             USA: {
                 Alabama: State;
                 Alaska: State;
                 Arizona: State;
                 Arkansas: State;
                 California: State;
                 Colorado: State;
                 Connecticut: State;
                 Delaware: State;
                 'District of Columbia': State;
                 Florida: State;
                 Georgia: State;
                 Hawaii: State;
                 Idaho: State;
                 Illinois: State;
                 Indiana: State;
                 Iowa: State;
                 Kansas: State;
                 Kentucky: State;
                 Louisiana: State;
                 Maine: State;
                 Maryland: State;
                 Massachusetts: State;
                 Michigan: State;
                 Minnesota: State;
                 Mississippi: State;
                 Missouri: State;
                 Montana: State;
                 Nebraska: State;
                 Nevada: State;
                 'New Hampshire': State;
                 'New Jersey': State;
                 'New Mexico': State;
                 'New York': State;
                 'North Carolina': State;
                 'North Dakota': State;
                 Ohio: State;
                 Oklahoma: State;
                 Oregon: State;
                 Pennsylvania: State;
                 'Rhode Island': State;
                 'South Carolina': State;
                 'South Dakota': State;
                 Tennessee: State;
                 Texas: State;
                 Utah: State;
                 Vermont: State;
                 Virginia: State;
                 Washington: State;
                 'West Virginia': State;
                 Wisconsin: State;
                 Wyoming: State;
             };
             /**
              * {@link MapRegionsNorthAmerica}
              */
             NorthAmerica: {
                 Anguilla: Country;
                 'Antigua and Barbuda': Country;
                 'The Bahamas': Country;
                 Bermuda: Country;
                 Barbados: Country;
                 Canada: Country;
                 Cuba: Country;
                 'Cayman Islands': Country;
                 Dominica: Country;
                 'Dominican Republic': Country;
                 Grenada: Country;
                 Greenland: Country;
                 Haiti: Country;
                 Jamaica: Country;
                 'Saint Kitts and Nevis': Country;
                 'Saint Lucia': Country;
                 'Saint Martin': Country;
                 Mexico: Country;
                 Montserrat: Country;
                 'Puerto Rico': Country;
                 'Saint Pierre and Miquelon': Country;
                 'Turks and Caicos Islands': Country;
                 'Trinidad and Tobago': Country;
                 'United States of America': Country;
                 'Saint Vincent and the Grenadines': Country;
                 'British Virgin Islands': Country;
                 'United States Virgin Islands': Country;
             };
             /**
              * {@link MapRegionsSouthAmerica}
              */
             SouthAmerica: {
                 Argentina: Country;
                 Bolivia: Country;
                 Brazil: Country;
                 Chile: Country;
                 Colombia: Country;
                 'Costa Rica': Country;
                 Ecuador: Country;
                 'Falkland Islands': Country;
                 Guyana: Country;
                 Nicaragua: Country;
                 Panama: Country;
                 Peru: Country;
                 Paraguay: Country;
                 Suriname: Country;
                 Uruguay: Country;
                 Venezuela: Country;
                 'French Guyana': Country;
                 Guatemala: Country;
                 'El Salvador': Country;
                 Honduras: Country;
             };
             /**
              * {@link MapRegionsCanada}
              */
             Canada: {
                 'British Columbia': CanadaProvinceOrTerritory;
                 Quebec: CanadaProvinceOrTerritory;
                 Nunavut: CanadaProvinceOrTerritory;
                 'Prince Edward Island': CanadaProvinceOrTerritory;
                 Saskatchewan: CanadaProvinceOrTerritory;
                 Yukon: CanadaProvinceOrTerritory;
                 Manitoba: CanadaProvinceOrTerritory;
                 Ontario: CanadaProvinceOrTerritory;
                 'New Brunswick': CanadaProvinceOrTerritory;
                 'Northwest Territories': CanadaProvinceOrTerritory;
                 Alberta: CanadaProvinceOrTerritory;
                 'Newfoundland and Labrador': CanadaProvinceOrTerritory;
                 'Nova Scotia': CanadaProvinceOrTerritory;
             };
             /**
              * {@link MapRegionsEurope}
              */
             Europe: {
                 Albania: Country;
                 Austria: Country;
                 Belarus: Country;
                 Belgium: Country;
                 Bulgaria: Country;
                 'Bosnia and Herzegovina': Country;
                 Switzerland: Country;
                 Cyprus: Country;
                 'Czech Republic': Country;
                 Germany: Country;
                 Denmark: Country;
                 Spain: Country;
                 Estonia: Country;
                 Finland: Country;
                 France: Country;
                 'United Kingdom': Country;
                 Greece: Country;
                 Croatia: Country;
                 Hungary: Country;
                 Ireland: Country;
                 Iceland: Country;
                 Italy: Country;
                 Kosovo: Country;
                 Lithuania: Country;
                 Luxembourg: Country;
                 Latvia: Country;
                 Macedonia: Country;
                 Malta: Country;
                 Montenegro: Country;
                 Netherlands: Country;
                 Norway: Country;
                 Poland: Country;
                 Portugal: Country;
                 Romania: Country;
                 'Republic of Serbia': Country;
                 Slovakia: Country;
                 Slovenia: Country;
                 Sweden: Country;
                 Ukraine: Country;
                 Moldova: Country;
                 Russia: Country;
                 Turkey: Country;
             };
             /**
              * {@link MapRegionsAsia}
              */
             Asia: {
                 Afghanistan: Country;
                 'United Arab Emirates': Country;
                 Armenia: Country;
                 Australia: Country;
                 Azerbaijan: Country;
                 Bangladesh: Country;
                 Bahrain: Country;
                 Brunei: Country; /**
                 * {@link MapRegionsUSA}
                 */
                 Bhutan: Country;
                 China: Country;
                 Georgia: Country;
                 Indonesia: Country;
                 India: Country;
                 Iran: Country; /**
                 * {@link MapRegionsEurope}
                 */
                 Iraq: Country;
                 Israel: Country;
                 Jordan: Country;
                 Japan: Country;
                 Kazakhstan: Country;
                 Kyrgyzstan: Country;
                 Cambodia: Country;
                 'South Korea': Country;
                 Kuwait: Country;
                 Laos: Country;
                 Lebanon: Country;
                 'Sri Lanka': Country;
                 Maldives: Country;
                 Myanmar: Country;
                 Mongolia: Country;
                 Malaysia: Country;
                 Nepal: Country;
                 Oman: Country;
                 Pakistan: Country;
                 Philippines: Country;
                 'Papua New Guinea': Country;
                 'North Korea': Country;
                 Palestine: Country;
                 Qatar: Country;
                 Russia: Country;
                 'Saudi Arabia': Country;
                 Singapore: Country;
                 Syria: Country;
                 Thailand: Country;
                 Tajikistan: Country;
                 Turkmenistan: Country;
                 Turkey: Country;
                 Taiwan: Country;
                 Uzbekistan: Country;
                 Vietnam: Country;
                 Yemen: Country;
             };
             /**
              * {@link MapRegionsAfrica}
              */
             Africa: {
                 Angola: Country;
                 Burundi: Country;
                 Benin: Country;
                 'Burkina Faso': Country;
                 Botswana: Country;
                 'Central African Republic': Country;
                 'Ivory Coast': Country;
                 Cameroon: Country;
                 'Democratic Republic of the Congo': Country;
                 'Republic of Congo': Country;
                 Comoros: Country;
                 'Cape Verde': Country;
                 Djibouti: Country;
                 Algeria: Country;
                 Egypt: Country;
                 Eritrea: Country;
                 Ethiopia: Country;
                 Gabon: Country;
                 Ghana: Country;
                 Guinea: Country;
                 Gambia: Country;
                 'Guinea Bissau': Country;
                 'Equatorial Guinea': Country;
                 Israel: Country;
                 Jordan: Country;
                 Kenya: Country;
                 Lebanon: Country;
                 Liberia: Country;
                 Libya: Country;
                 Lesotho: Country;
                 Morocco: Country;
                 Madagascar: Country;
                 Mali: Country;
                 Malta: Country;
                 Mozambique: Country;
                 Mauritania: Country;
                 Mauritius: Country;
                 Malawi: Country;
                 Namibia: Country;
                 Niger: Country;
                 Nigeria: Country;
                 Oman: Country;
                 Rwanda: Country;
                 'Western Sahara': Country;
                 'Saudi Arabia': Country;
                 Sudan: Country;
                 'South Sudan': Country;
                 Senegal: Country;
                 'Saint Helena': Country;
                 'Sierra Leone': Country;
                 Somalia: Country;
                 Swaziland: Country;
                 Seychelles: Country;
                 Syria: Country;
                 Chad: Country;
                 Togo: Country;
                 Tunisia: Country;
                 'United Republic of Tanzania': Country;
                 Uganda: Country;
                 Yemen: Country;
                 'South Africa': Country;
                 Zambia: Country;
                 Zimbabwe: Country;
             };
             /**
              * {@link MapRegionsAustralia}
              */
             Australia: {
                 'New South Wales': AustraliaTerritory;
                 Victoria: AustraliaTerritory;
                 Queensland: AustraliaTerritory;
                 'South Australia': AustraliaTerritory;
                 'Western Australia': AustraliaTerritory;
                 Tasmania: AustraliaTerritory;
                 'Northern Territory': AustraliaTerritory;
                 'Australian Capital Territory': AustraliaTerritory;
                 'Other Territories': AustraliaTerritory;
             };
         };
         /**
          * List of MapRegions included in {@link MapTypes | MapTypes.Africa}.
          *
          * Can be referenced like so:
          *
          * ```ts
          * const countries = MapRegions[ MapTypes.Africa ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.Africa ].Egypt, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.Africa ] ).forEach( key => console.log( key ) )
          * ```
          *
          * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of Africa.
          * @public
          */
         export declare const MapRegionsAfrica: {
             Angola: Country;
             Burundi: Country;
             Benin: Country;
             'Burkina Faso': Country;
             Botswana: Country;
             'Central African Republic': Country;
             'Ivory Coast': Country;
             Cameroon: Country;
             'Democratic Republic of the Congo': Country;
             'Republic of Congo': Country;
             Comoros: Country;
             'Cape Verde': Country;
             Djibouti: Country;
             Algeria: Country;
             Egypt: Country;
             Eritrea: Country;
             Ethiopia: Country;
             Gabon: Country;
             Ghana: Country;
             Guinea: Country;
             Gambia: Country;
             'Guinea Bissau': Country;
             'Equatorial Guinea': Country;
             Israel: Country;
             Jordan: Country;
             Kenya: Country;
             Lebanon: Country;
             Liberia: Country;
             Libya: Country;
             Lesotho: Country;
             Morocco: Country;
             Madagascar: Country;
             Mali: Country;
             Malta: Country;
             Mozambique: Country;
             Mauritania: Country;
             Mauritius: Country;
             Malawi: Country;
             Namibia: Country;
             Niger: Country;
             Nigeria: Country;
             Oman: Country;
             Rwanda: Country;
             'Western Sahara': Country;
             'Saudi Arabia': Country;
             Sudan: Country;
             'South Sudan': Country;
             Senegal: Country;
             'Saint Helena': Country;
             'Sierra Leone': Country;
             Somalia: Country;
             Swaziland: Country;
             Seychelles: Country;
             Syria: Country;
             Chad: Country;
             Togo: Country;
             Tunisia: Country;
             'United Republic of Tanzania': Country;
             Uganda: Country;
             Yemen: Country;
             'South Africa': Country;
             Zambia: Country;
             Zimbabwe: Country;
         };
         /**
          * List of MapRegions included in {@link MapTypes | MapTypes.Asia}.
          *
          * Can be referenced like so:
          *
          * ```ts
          * const countries = MapRegions[ MapTypes.Asia ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.Asia ].China, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.Asia ] ).forEach( key => console.log( key ) )
          * ```
          *
          * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of Asia.
          * @public
          */
         export declare const MapRegionsAsia: {
             Afghanistan: Country;
             'United Arab Emirates': Country;
             Armenia: Country;
             Australia: Country;
             Azerbaijan: Country;
             Bangladesh: Country;
             Bahrain: Country;
             Brunei: Country;
             Bhutan: Country;
             China: Country;
             Georgia: Country;
             Indonesia: Country;
             India: Country;
             Iran: Country;
             Iraq: Country;
             Israel: Country;
             Jordan: Country;
             Japan: Country;
             Kazakhstan: Country;
             Kyrgyzstan: Country;
             Cambodia: Country;
             'South Korea': Country;
             Kuwait: Country;
             Laos: Country;
             Lebanon: Country;
             'Sri Lanka': Country;
             Maldives: Country;
             Myanmar: Country;
             Mongolia: Country;
             Malaysia: Country;
             Nepal: Country;
             Oman: Country;
             Pakistan: Country;
             Philippines: Country;
             'Papua New Guinea': Country;
             'North Korea': Country;
             Palestine: Country;
             Qatar: Country;
             Russia: Country;
             'Saudi Arabia': Country;
             Singapore: Country;
             Syria: Country;
             Thailand: Country;
             Tajikistan: Country;
             Turkmenistan: Country;
             Turkey: Country;
             Taiwan: Country;
             Uzbekistan: Country;
             Vietnam: Country;
             Yemen: Country;
         };
         /**
          * List of MapRegions included in {@link MapTypes | MapTypes.Australia}.
          *
          * Can be referenced like so:
          *
          * ```ts
          * const territories = MapRegions[ MapTypes.Australia ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.Australia ].Queensland, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.Australia ] ).forEach( key => console.log( key ) )
          * ```
          * @public
          */
         export declare const MapRegionsAustralia: {
             'New South Wales': AustraliaTerritory;
             Victoria: AustraliaTerritory;
             Queensland: AustraliaTerritory;
             'South Australia': AustraliaTerritory;
             'Western Australia': AustraliaTerritory;
             Tasmania: AustraliaTerritory;
             'Northern Territory': AustraliaTerritory;
             'Australian Capital Territory': AustraliaTerritory;
             'Other Territories': AustraliaTerritory;
         };
         /**
          * List of MapRegions included in {@link MapTypes | MapTypes.Canada}.
          *
          * Can be referenced like so:
          *
          * ```ts
          * const territories = MapRegions[ MapTypes.Canada ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.Canada ].Ontario, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.Canada ] ).forEach( key => console.log( key ) )
          * ```
          * @public
          */
         export declare const MapRegionsCanada: {
             'British Columbia': CanadaProvinceOrTerritory;
             Quebec: CanadaProvinceOrTerritory;
             Nunavut: CanadaProvinceOrTerritory;
             'Prince Edward Island': CanadaProvinceOrTerritory;
             Saskatchewan: CanadaProvinceOrTerritory;
             Yukon: CanadaProvinceOrTerritory;
             Manitoba: CanadaProvinceOrTerritory;
             Ontario: CanadaProvinceOrTerritory;
             'New Brunswick': CanadaProvinceOrTerritory;
             'Northwest Territories': CanadaProvinceOrTerritory;
             Alberta: CanadaProvinceOrTerritory;
             'Newfoundland and Labrador': CanadaProvinceOrTerritory;
             'Nova Scotia': CanadaProvinceOrTerritory;
         };
         /**
          * List of MapRegions included in {@link MapTypes | MapTypes.Europe}.
          *
          * Can be referenced like so:
          *
          * ```ts
          * const countries = MapRegions[ MapTypes.Europe ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.Europe ].Finland, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.Europe ] ).forEach( key => console.log( key ) )
          * ```
          *
          * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of Europe.
          * @public
          */
         export declare const MapRegionsEurope: {
             Albania: Country;
             Austria: Country;
             Belarus: Country;
             Belgium: Country;
             Bulgaria: Country;
             'Bosnia and Herzegovina': Country;
             Switzerland: Country;
             Cyprus: Country;
             'Czech Republic': Country;
             Germany: Country;
             Denmark: Country;
             Spain: Country;
             Estonia: Country;
             Finland: Country;
             France: Country;
             'United Kingdom': Country;
             Greece: Country;
             Croatia: Country;
             Hungary: Country;
             Ireland: Country;
             Iceland: Country;
             Italy: Country;
             Kosovo: Country;
             Lithuania: Country;
             Luxembourg: Country;
             Latvia: Country;
             Macedonia: Country;
             Malta: Country;
             Montenegro: Country;
             Netherlands: Country;
             Norway: Country;
             Poland: Country;
             Portugal: Country;
             Romania: Country;
             'Republic of Serbia': Country;
             Slovakia: Country;
             Slovenia: Country;
             Sweden: Country;
             Ukraine: Country;
             Moldova: Country;
             Russia: Country;
             Turkey: Country;
         };
         /**
          * List of MapRegions included in {@link MapTypes | MapTypes.NorthAmerica}.
          *
          * Can be referenced like so:
          *
          * ```ts
          * const countries = MapRegions[ MapTypes.NorthAmerica ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.NorthAmerica ].Panama, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.NorthAmerica ] ).forEach( key => console.log( key ) )
          * ```
          *
          * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of North America.
          * @public
          */
         export declare const MapRegionsNorthAmerica: {
             Anguilla: Country;
             'Antigua and Barbuda': Country;
             'The Bahamas': Country;
             Bermuda: Country;
             Barbados: Country;
             Canada: Country;
             Cuba: Country;
             'Cayman Islands': Country;
             Dominica: Country;
             'Dominican Republic': Country;
             Grenada: Country;
             Greenland: Country;
             Haiti: Country;
             Jamaica: Country;
             'Saint Kitts and Nevis': Country;
             'Saint Lucia': Country;
             'Saint Martin': Country;
             Mexico: Country;
             Montserrat: Country;
             'Puerto Rico': Country;
             'Saint Pierre and Miquelon': Country;
             'Turks and Caicos Islands': Country;
             'Trinidad and Tobago': Country;
             'United States of America': Country;
             'Saint Vincent and the Grenadines': Country;
             'British Virgin Islands': Country;
             'United States Virgin Islands': Country;
         };
         /**
          * List of MapRegions included in {@link MapTypes | MapTypes.SouthAmerica}.
          *
          * Can be referenced like so:
          *
          * ```ts
          * const countries = MapRegions[ MapTypes.SouthAmerica ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.SouthAmerica ].Colombia, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.SouthAmerica ] ).forEach( key => console.log( key ) )
          * ```
          *
          * Note, that the list includes all countries that are visible on the MapChart, some of which are outside the continent of South America.
          * @public
          */
         export declare const MapRegionsSouthAmerica: {
             Argentina: Country;
             Bolivia: Country;
             Brazil: Country;
             Chile: Country;
             Colombia: Country;
             'Costa Rica': Country;
             Ecuador: Country;
             'Falkland Islands': Country;
             Guyana: Country;
             Nicaragua: Country;
             Panama: Country;
             Peru: Country;
             Paraguay: Country;
             Suriname: Country;
             Uruguay: Country;
             Venezuela: Country;
             'French Guyana': Country;
             Guatemala: Country;
             'El Salvador': Country;
             Honduras: Country;
         };
         /**
          * List of MapRegions included in {@link MapTypes | MapTypes.USA}.
          *
          * Can be referenced like so:
          *
          * ```ts
          * const states = MapRegions[ MapTypes.USA ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.USA ].Alabama, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.USA ] ).forEach( key => console.log( key ) )
          * ```
          * @public
          */
         export declare const MapRegionsUSA: {
             Alabama: State;
             Alaska: State;
             Arizona: State;
             Arkansas: State;
             California: State;
             Colorado: State;
             Connecticut: State;
             Delaware: State;
             'District of Columbia': State;
             Florida: State;
             Georgia: State;
             Hawaii: State;
             Idaho: State;
             Illinois: State;
             Indiana: State;
             Iowa: State;
             Kansas: State;
             Kentucky: State;
             Louisiana: State;
             Maine: State;
             Maryland: State;
             Massachusetts: State;
             Michigan: State;
             Minnesota: State;
             Mississippi: State;
             Missouri: State;
             Montana: State;
             Nebraska: State;
             Nevada: State;
             'New Hampshire': State;
             'New Jersey': State;
             'New Mexico': State;
             'New York': State;
             'North Carolina': State;
             'North Dakota': State;
             Ohio: State;
             Oklahoma: State;
             Oregon: State;
             Pennsylvania: State;
             'Rhode Island': State;
             'South Carolina': State;
             'South Dakota': State;
             Tennessee: State;
             Texas: State;
             Utah: State;
             Vermont: State;
             Virginia: State;
             Washington: State;
             'West Virginia': State;
             Wisconsin: State;
             Wyoming: State;
         };
         /**
          * List of MapRegions included in {@link MapTypes | MapTypes.World}.
          *
          * Can be referenced like so:
          *
          * ```ts
          * const countries = MapRegions[ MapTypes.World ]
          * ```
          *
          * Each item is an enum-like object, that can be used with {@link MapChart} API to specify any region.
          *
          * **Example usage**:
          *
          * - Invalidate selected region value.
          *
          * ``` ts
          *  MapChart.invalidateRegionValues([
          *      { ...MapRegions[ MapTypes.World ].Finland, value: 0 }
          *  ])
          * ```
          *
          * - List all region names (can be useful when developing a js application without intellisense).
          *
          * ``` ts
          *  Object.keys( MapRegions[ MapTypes.World ] ).forEach( key => console.log( key ) )
          * ```
          * @public
          */
         export declare const MapRegionsWorld: {
             Aruba: Country;
             Afghanistan: Country;
             Angola: Country;
             Anguilla: Country;
             Albania: Country;
             Aland: Country;
             Andorra: Country;
             'United Arab Emirates': Country;
             Argentina: Country;
             Armenia: Country;
             'American Samoa': Country;
             Antarctica: Country;
             'French Southern and Antarctic Lands': Country;
             'Antigua and Barbuda': Country;
             Australia: Country;
             Austria: Country;
             Azerbaijan: Country;
             Burundi: Country;
             Belgium: Country;
             Benin: Country;
             'Burkina Faso': Country;
             Bangladesh: Country;
             Bulgaria: Country;
             Bahrain: Country;
             'The Bahamas': Country;
             'Bosnia and Herzegovina': Country;
             Belarus: Country;
             Belize: Country;
             Bermuda: Country;
             Bolivia: Country;
             Brazil: Country;
             Barbados: Country;
             Brunei: Country;
             Bhutan: Country;
             Botswana: Country;
             'Central African Republic': Country;
             Canada: Country;
             Switzerland: Country;
             Chile: Country;
             China: Country;
             'Ivory Coast': Country;
             Cameroon: Country;
             'Cyprus No Mans Area': Country;
             'Democratic Republic of the Congo': Country;
             'Republic of Congo': Country;
             'Cook Islands': Country;
             Colombia: Country;
             Comoros: Country;
             'Cape Verde': Country;
             'Costa Rica': Country;
             Cuba: Country;
             Curaao: Country;
             'Cayman Islands': Country;
             'Northern Cyprus': Country;
             Cyprus: Country;
             'Czech Republic': Country;
             Germany: Country;
             Djibouti: Country;
             Dominica: Country;
             Denmark: Country;
             'Dominican Republic': Country;
             Algeria: Country;
             Ecuador: Country;
             Egypt: Country;
             Eritrea: Country;
             'Dhekelia Sovereign Base Area': Country;
             Spain: Country;
             Estonia: Country;
             Ethiopia: Country;
             Finland: Country;
             Fiji: Country;
             'Falkland Islands': Country;
             France: Country;
             'Faroe Islands': Country;
             'Federated States of Micronesia': Country;
             Gabon: Country;
             'United Kingdom': Country;
             Georgia: Country;
             Guernsey: Country;
             Ghana: Country;
             Guinea: Country;
             Gambia: Country;
             'Guinea Bissau': Country;
             'Equatorial Guinea': Country;
             Greece: Country;
             Grenada: Country;
             Greenland: Country;
             Guatemala: Country;
             Guam: Country;
             Guyana: Country;
             'Hong Kong S.A.R.': Country;
             'Heard Island and McDonald Islands': Country;
             Honduras: Country;
             Croatia: Country;
             Haiti: Country;
             Hungary: Country;
             Indonesia: Country;
             'Isle of Man': Country;
             India: Country;
             'Indian Ocean Territories': Country;
             'British Indian Ocean Territory': Country;
             Ireland: Country;
             Iran: Country;
             Iraq: Country;
             Iceland: Country;
             Israel: Country;
             Italy: Country;
             Jamaica: Country;
             Jersey: Country;
             Jordan: Country;
             Japan: Country;
             'Baykonur Cosmodrome': Country;
             'Siachen Glacier': Country;
             Kazakhstan: Country;
             Kenya: Country;
             Kyrgyzstan: Country;
             Cambodia: Country;
             Kiribati: Country;
             'Saint Kitts and Nevis': Country;
             'South Korea': Country;
             Kosovo: Country;
             Kuwait: Country;
             Laos: Country;
             Lebanon: Country;
             Liberia: Country;
             Libya: Country;
             'Saint Lucia': Country;
             Liechtenstein: Country;
             'Sri Lanka': Country;
             Lesotho: Country;
             Lithuania: Country;
             Luxembourg: Country;
             Latvia: Country;
             'Macao S.A.R': Country;
             'Saint Martin': Country;
             Morocco: Country;
             Moldova: Country;
             Madagascar: Country;
             Maldives: Country;
             Mexico: Country;
             'Marshall Islands': Country;
             Macedonia: Country;
             Mali: Country;
             Malta: Country;
             Myanmar: Country;
             Montenegro: Country;
             Mongolia: Country;
             'Northern Mariana Islands': Country;
             Mozambique: Country;
             Mauritania: Country;
             Montserrat: Country;
             Mauritius: Country;
             Malawi: Country;
             Malaysia: Country;
             Namibia: Country;
             'New Caledonia': Country;
             Niger: Country;
             Nigeria: Country;
             Nicaragua: Country;
             Niue: Country;
             Netherlands: Country;
             Norway: Country;
             Nepal: Country;
             'New Zealand': Country;
             Oman: Country;
             Pakistan: Country;
             Panama: Country;
             'Pitcairn Islands': Country;
             Peru: Country;
             'Spratly Islands': Country;
             Philippines: Country;
             Palau: Country;
             'Papua New Guinea': Country;
             Poland: Country;
             'Puerto Rico': Country;
             'North Korea': Country;
             Portugal: Country;
             Paraguay: Country;
             Palestine: Country;
             'French Polynesia': Country;
             Qatar: Country;
             Romania: Country;
             Russia: Country;
             Rwanda: Country;
             'Western Sahara': Country;
             'Saudi Arabia': Country;
             Sudan: Country;
             'South Sudan': Country;
             Senegal: Country;
             Singapore: Country;
             'South Georgia and South Sandwich Islands': Country;
             'Saint Helena': Country;
             'Solomon Islands': Country;
             'Sierra Leone': Country;
             'El Salvador': Country;
             Somalia: Country;
             'Saint Pierre and Miquelon': Country;
             'Republic of Serbia': Country;
             'Sao Tome and Principe': Country;
             Suriname: Country;
             Slovakia: Country;
             Slovenia: Country;
             Sweden: Country;
             Swaziland: Country;
             Seychelles: Country;
             Syria: Country;
             'Turks and Caicos Islands': Country;
             Chad: Country;
             Togo: Country;
             Thailand: Country;
             Tajikistan: Country;
             Turkmenistan: Country;
             'East Timor': Country;
             Tonga: Country;
             'Trinidad and Tobago': Country;
             Tunisia: Country;
             Turkey: Country;
             Tuvalu: Country;
             Taiwan: Country;
             'United Republic of Tanzania': Country;
             Uganda: Country;
             Ukraine: Country;
             'United States Minor Outlying Islands': Country;
             Uruguay: Country;
             'United States of America': Country;
             'US Naval Base Guantanamo Bay': Country;
             Uzbekistan: Country;
             'Saint Vincent and the Grenadines': Country;
             Venezuela: Country;
             'British Virgin Islands': Country;
             'United States Virgin Islands': Country;
             Vietnam: Country;
             Vanuatu: Country;
             'Wallis and Futuna': Country;
             'Akrotiri Sovereign Base Area': Country;
             Samoa: Country;
             Yemen: Country;
             'South Africa': Country;
             Zambia: Country;
             Zimbabwe: Country;
             'French Guyana': Country;
         };
         /**
          * Collection object for all possible {@link MapChart} types.
          *
          * Selected type defines the displayed Map region as well as the type of associated region data (eq. USA -\> states, World -\> countries).
          *
          * *MapType* can be specified when the *MapChart* is created:
          *
          * ``` ts
          *  const mapChart = lightningChart().Map({
          *      type: MapTypes.USA
          *  })
          * ```
          * @public
          */
         export declare type MapType = typeof MapTypes[keyof typeof MapTypes];
         /**
          * Type map that indicates what data is available for each *Map Region*, based on the selected *Map Type*.
          *
          * For example, {@link MapTypes | MapTypes.World} works with {@link Country} data structures, whereas {@link MapTypes | MapTypes.USA} works with {@link State} data structures.
          *
          * This affects the usage of
          * - {@link MapChart.setCursorResultTableFormatter}
          * - {@link MapChart.invalidateRegionValues}
          * @public
          */
         export declare interface MapTypeRegionProperties {
             World: Country;
             USA: State;
             NorthAmerica: Country;
             SouthAmerica: Country;
             Canada: CanadaProvinceOrTerritory;
             Europe: Country;
             Asia: Country;
             Africa: Country;
             Australia: AustraliaTerritory;
         }
         /**
          * Collection of {@link MapChart} types for selecting a section of the world to show.
          *
          * Map type is selected when the `MapChart` is created, with the `type` argument:
          *
          * ```typescript
          *  // Example, specify map type.
          *  const mapChart = lightningChart().Map({
          *      type: MapTypes.Europe,
          *  })
          * ```
          * @public
          */
         export declare const MapTypes: {
             /**
              * Map of whole world, with regions as countries.
              */
             World: "World";
             /**
              * Map of the United States of America with regions as states.
              */
             USA: "USA";
             /**
              * Map of North America, with regions as countries.
              */
             NorthAmerica: "NorthAmerica";
             /**
              * Map of South America, with regions as countries.
              */
             SouthAmerica: "SouthAmerica";
             /**
              * Map of Canada, with regions as Canadian provinces and territories.
              */
             Canada: "Canada";
             /**
              * Map of Europe, with regions as countries.
              */
             Europe: "Europe";
             /**
              * Map of Asia, with regions as countries.
              */
             Asia: "Asia";
             /**
              * Map of Africa, with regions as countries.
              */
             Africa: "Africa";
             /**
              * Map of Australia, with regions as Australian territories.
              */
             Australia: "Australia";
         };
         /**
          * Interface for a data-structure which represents a measurement of four sides.
          * Has number properties for:
          * - left
          * - top
          * - right
          * - bottom
          *
          * This data-structure is mainly used for specifying Chart paddings and UIElement paddings/margins.
          *
          * Duplicate of Padding.
          * @public
          */
         export declare interface Margin {
             /**
              * Left value.
              */
             readonly left: number;
             /**
              * Top value.
              */
             readonly top: number;
             /**
              * Right value.
              */
             readonly right: number;
             /**
              * Bottom value.
              */
             readonly bottom: number;
         }
         /**
          * Indicates object which can have margin.
          * Margin is empty space around element content (including background if any)
          * @public
          */
         export declare interface Marginable {
             /**
              * Set margin around object in pixels.
              * @param margin - Number with pixel margins for all sides or datastructure with individual pixel margins
              *                      for each side. Any side can be omitted, only passed values will be overridden.
              * @returns Object itself
              * @public
              */
             setMargin(margin: Partial<MMargin> | number): this;
             /**
              * Get margin around object in pixels.
              * @returns Margin datastructure
              * @public
              */
             getMargin(): Margin;
         }
         /**
          * Cursor-based visual that can be plotted on a Chart.
          * Like Cursors its built of two parts:
          * PointMarker and ResultTable, first of which
          * shows the location of the Marker clearly and the second
          * to display information about the pointed DataPoint.
          * @public
          */
         export declare interface Marker<ResultTableBackgroundType extends UIBackground, CursorType extends Cursor<ResultTableBackgroundType>> extends Draggable {
             /**
              * Set visibility mode for PointMarker.
              * PointMarker is a visual that is displayed at the Cursors position.
              * @param visibilityMode - Defines when part is visible
              * @returns Object itself
              * @public
              */
             setPointMarkerVisibility(visibilityMode: UIVisibilityModes): this;
             /**
              * Get visibility mode for PointMarker.
              * PointMarker is a visual that is displayed at the Cursors position.
              * @returns VisibilityMode
              * @public
              */
             getPointMarkerVisibility(): UIVisibilityModes;
             /**
              * Set visibility mode for ResultTable.
              * ResultTable is a visual that displays currently pointed data next to its location.
              * @param visibilityMode - Defines when part is visible
              * @returns Object itself
              * @public
              */
             setResultTableVisibility(visibilityMode: UIVisibilityModes): this;
             /**
              * Get visibility mode for ResultTable.
              * ResultTable is a visual that displays currently pointed data next to its location.
              * @returns VisibilityMode
              * @public
              */
             getResultTableVisibility(): UIVisibilityModes;
             /**
              * Set mouse interactions enabled or disabled
              * @param state - Specifies state of mouse interactions
              * @returns Object itself for fluent interface
              * @public
              */
             setMouseInteractions(state: boolean): this;
             /**
              * @returns Mouse interactions state
              * @public
              */
             getMouseInteractions(): boolean;
             /**
              * Set auto-fit strategy of Cursor.
              * Affects logic of automatic fitting of Cursors ResultTable to the screen.
              * @param autoFitStrategy - AutoFitStrategy factory or undefined to disable auto-fitting
              * @returns Object itself for fluent interface
              * @public
              */
             setAutoFitStrategy(autoFitStrategy?: AutoFitStrategyFactory<ResultTableBackgroundType>): this;
             /**
              * Get is auto-fit enabled.
              * Affects logic of automatic fitting of Cursors ResultTable to the screen.
              * @returns Boolean flag whether auto-fit is enabled
              * @public
              */
             getAutoFitStrategy(): boolean;
         }
         /**
          * **Warning, old and mostly unused API. You most likely don't need this.**
          *
          * Collection of *StaticCursorBuilders*.
          *
          * *StaticCursorBuilder*s are used to modify structure of *Markers*, by passing one when the *Marker* is created.
          *
          * Each item is associated with a specific *Chart*-type, that it can only be used with.
          * @public
          */
         export declare const MarkerBuilders: {
             /**
              * **Warning, old and mostly unused API. You most likely don't need this.**
              *
              * Builder that is used by default when creating Chart Markers in ChartXY {@link ChartXY.addChartMarkerXY}.
              * This can mainly be used to create chart marker with non-rectangle background (very uncommon requirement).
              *
              * ```ts
              *  // Example
              *  const chartMarker = ChartXY
              *      .addChartMarkerXY(MarkerBuilders.ChartMarkerXY.setResultTableBackground(UIBackgrounds.Circle))
              *      .setResultTable((resultTable) => resultTable
              *          .setContent([['Hello']])
              *      )
              * ```
              */
             ChartMarkerXY: StaticCursorXYBuilder;
             /**
              * **Warning, old and mostly unused API. You most likely don't need this.**
              *
              * Builder that is used by default when creating XY Series Markers {@link SeriesXY.addMarker}.
              * This can mainly be used to create marker with non-rectangle background (very uncommon requirement).
              *
              * ```ts
              *  // Example
              *  const seriesMarker = SeriesXY.addMarker(MarkerBuilders.SeriesMarkerXY.setResultTableBackground(UIBackgrounds.Circle))
              * ```
              */
             SeriesMarkerXY: StaticCursorXYBuilder;
         };
         /**
          * Cursor-based visual that can be plotted on a XY Chart.
          * Like CursorXYs its built of four parts:
          * PointMarker shows the location of the Marker,
          * ResultTable displays information of the point
          * and X&Y tickMarkers to show gridstroke on its axes.
          * @public
          */
         declare interface MarkerXY<ResultTableBackgroundType extends UIBackground> extends Marker<ResultTableBackgroundType, CursorXY<ResultTableBackgroundType>>, Hideable, HideableEvents {
             /**
              * Set visibility mode for gridstroke X.
              * @param visibilityMode - Defines when part is visible
              * @returns Object itself
              * @public
              */
             setGridStrokeXVisibility(visibilityMode: UIVisibilityModes): this;
             /**
              * Get visibility mode for gridstroke X.
              * @returns VisibilityMode
              * @public
              */
             getGridStrokeXVisibility(): UIVisibilityModes;
             /**
              * Set visibility mode for gridstroke Y.
              * @param visibilityMode - Defines when part is visible
              * @returns Object itself
              * @public
              */
             setGridStrokeYVisibility(visibilityMode: UIVisibilityModes): this;
             /**
              * Get visibility mode for gridstroke Y.
              * @returns VisibilityMode
              * @public
              */
             getGridStrokeYVisibility(): UIVisibilityModes;
             /**
              * Set visibility mode for tickMarker X.
              * @param visibilityMode - Defines when part is visible
              * @returns Object itself
              * @public
              */
             setTickMarkerXVisibility(visibilityMode: UIVisibilityModes): this;
             /**
              * Get visibility mode for tickMarker X.
              * @returns VisibilityMode
              * @public
              */
             getTickMarkerXVisibility(): UIVisibilityModes;
             /**
              * Set visibility mode for tickMarker Y.
              * @param visibilityMode - Defines when part is visible
              * @returns Object itself
              * @public
              */
             setTickMarkerYVisibility(visibilityMode: UIVisibilityModes): this;
             /**
              * Get visibility mode for tickMarker Y.
              * @returns VisibilityMode
              * @public
              */
             getTickMarkerYVisibility(): UIVisibilityModes;
         }
         /**
          * Interface for a mutable data-structure which represents a 2-dimensional location and an associated Color.
          *
          * This can be used for Point-based series for coloring each point individually, when combined with usage of IndividualPointFill-style.
          * @public
          */
         export declare interface MColorPoint extends MPoint, MColorValue {
         }
         /**
          * Interface for mutable data-structure which contains a color.
          * @public
          */
         export declare interface MColorValue {
             /**
              * Color for the fill.
              */
             color: Color;
         }
         /**
          * Implementation of ScaleXY for a mixable combination of Linear and Logarithmic Scales.
          */
         declare class MixedScaleXY extends ScaleXY<LinearScale1D | LogarithmicScale1D> {
         }
         /**
          * Interface for a mutable margin-datastructure.
          */
         declare interface MMargin {
             left: number;
             top: number;
             right: number;
             bottom: number;
         }
         /**
          * Event handler for mouse drag
          * @param obj - Object
          * @param event - Browser MouseEvent that triggered the event
          * @param button - Button that is being held down
          * @param startLocation - Start location of mouse
          * @param delta - Dragged delta
          * @public
          */
         export declare type MouseDragEventHandler<T> = (obj: T, event: MouseEvent, button: number, startLocation: Point, delta: Point) => void;
         /**
          * Event handler for mouse drag start
          * @param obj - Object
          * @param event - Browser MouseEvent that triggered the event
          * @param button - Button that is being held down
          * @public
          */
         export declare type MouseDragStartEventHandler<T> = (obj: T, event: MouseEvent, button: number) => void;
         /**
          * Event handler for mouse drag
          * @param obj - Object
          * @param event - Browser MouseEvent that triggered the event
          * @param button - Button that is being held down
          * @param startLocation - Start location of mouse
          * @public
          */
         export declare type MouseDragStopEventHandler<T> = (obj: T, event: MouseEvent, button: number, startLocation: Point) => void;
         /**
          * Event handler for mouse move
          * @param obj - Object
          * @param event - Browser MouseEvent that triggered the event
          * @public
          */
         export declare type MouseEventHandler<T> = (obj: T, event: MouseEvent) => void;
         /**
          * Collection of some useful cursor styles.
          *
          * Uses HTML DOM Style cursor property, so supported values are specified by browser.
          *
          * https://www.w3schools.com/jsref/prop_style_cursor.asp
          *
          * Use with {@link UIElement.setMouseStyle}
          * @public
          */
         export declare enum MouseStyles {
             Move = "move",
             ResizeColumn = "col-resize",
             ResizeRow = "row-resize",
             Horizontal = "ew-resize",
             Vertical = "ns-resize",
             NorthWest = "nw-resize",
             NorthEast = "ne-resize",
             Copy = "copy",
             CrossHair = "crosshair",
             Default = "default",
             Help = "help",
             Restricted = "not-allowed",
             None = "none",
             Point = "pointer",
             Text = "text",
             Wait = "wait",
             ZoomIn = "zoom-in",
             ZoomOut = "zoom-out"
         }
         /**
          * Event handler for mouse wheel
          * @param obj - Object
          * @param event - Browser WheelEvent that triggered the event
          * @public
          */
         export declare type MouseWheelEventHandler<T> = (obj: T, event: WheelEvent) => void;
         /**
          * Interface for a mutable data-structure which represents a 2-dimensional location.
          * @public
          */
         export declare interface MPoint {
             /**
              * Location in X-dimension.
              */
             x: number;
             /**
              * Location in Y-dimension.
              */
             y: number;
         }
         /**
          * Interface for a strategy which defines dimension
          * @public
          */
         export declare interface MultidimensionalStrategy {
             /**
              * @param size - Two dimensional value width of which has to be extracted
              * @returns Width of Vec2
              * @public
              */
             readonly getWidth: <T>(sizes: Vec2<T>) => T;
             /**
              * @param size - Two dimensional value height of which has to be extracted
              * @returns Height of Vec2
              * @public
              */
             readonly getHeight: <T>(size: Vec2<T>) => T;
             /**
              * Combine argument with the tick value to create relevant Vec2
              * @param height - Value on height Scale units
              * @returns Vec2 which represents relevant for custom tick position
              * @public
              */
             readonly toVec2: <T>(value: T, height: T) => Vec2<T>;
             /**
              * Combine argument with the tick value to create relevant Point
              * @param height - Value on height Scale units
              * @returns Point
              * @public
              */
             readonly toPoint: (value: number, height: number) => Point;
         }
         /**
          * Internal interface for default implementations of Axis TickStrategies.
          *
          * Default implementations are immutable settings objects that users can modify with convenient setters.
          * This interface defines a method that is internally used to convert the settings object into an actual TickStrategy.
          * @public
          */
         declare interface MutableAxisTickStrategy {
         }
         /**
          * Type of a mutator function for abstract object.
          * Function provides functionality for modifying an object.
          * @param object - Object to mutate
          * @public
          */
         export declare type Mutator<T> = (object: T) => void;
         /**
          * Mutable version of Vec2. Internal use only.
          */
         declare interface MVec2<T> {
             x: T;
             y: T;
         }
         /**
          * *Axis Tick Strategy* that is designed for depicting numeric values of all magnitudes.
          *
          * **`NumericTickStrategy` is the default selection for all Axes**.
          *
          * Axis interval ranges supported by `NumericTickStrategy`:
          * - Minimum: `10e-9`
          * - Maximum: Unlimited.
          *
          * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
          *
          * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
          *
          * ```js
          *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks)
          * ```
          *
          * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
          * see example below for the idea:
          *
          * ```js
          *  // Specify TickStrategy and use callback to style automatic ticks.
          *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (numericTicks) => numericTicks
          *      // All methods of `NumericTickStrategy` can be used here for styling ticks.
          *      .setMajorTickStyle((majorTicks) => majorTicks
          *          .setLabelFont((font) => font
          *              .setWeight('bold')
          *          )
          *      )
          *  )
          * ```
          *
          * All available strategies for automatic Axis ticks creation can be referenced via {@link AxisTickStrategies}.
          * @public
          */
         export declare class NumericTickStrategy extends NumericTickStrategyRecord implements MutableAxisTickStrategy {
             /**
              * Set cursor formatter for this `TickStrategy` object.
              *
              * This will override the date time formatting used by:
              * - Default cursor result table formatters.
              * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
              * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
              *
              * ```ts
              *  // Example syntax, custom cursor formatting.
              *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
              *      .setCursorFormatter((value, range, locale) =>
              *          value.toFixed(3)
              *      )
              *  )
              * ```
              * @param formatter - `FormattingFunction` or `undefined` to use default numeric cursor formatting.
              * @returns New *NumericTickStrategy* object.
              * @public
              */
             setCursorFormatter(formatter: FormattingFunction | undefined): this;
             /**
              * Get cursor formatter of this `NumericTickStrategy` object.
              *
              * @returns `FormattingFunction` as set by user, or `undefined` to indicate that the default numeric cursor formatting is configured.
              * @public
              */
             getCursorFormatter(): FormattingFunction | undefined;
             /**
              * Construct a new *NumericTickStrategy* object based on this one, but with modified extreme tick style.
              *
              * Example usage:
              *
              * **Disable extreme ticks**:
              * ```javascript
              * Axis.setTickStrategy(
              *     AxisTickStrategies.Numeric,
              *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
              *         .setExtremeTickStyle( emptyTick )
              * )
              * ```
              *
              * **Set font of extreme ticks**:
              * ```javascript
              * Axis.setTickStrategy(
              *     AxisTickStrategies.Numeric,
              *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
              *         .setExtremeTickStyle(( tickStyle: TickStyle ) => tickStyle
              *             .setLabelFont(( font ) => font
              *                 .setWeight( 'bold' )
              *             )
              *         )
              * )
              * ```
              * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
              *                              Passing a function only works if the existing style is **not** *emptyTick*.
              * @returns New *NumericTickStrategy* object.
              * @public
              */
             setExtremeTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
             /**
              * Get extreme tick style of this *NumericTickStrategy* object.
              * @returns Extreme tick style.
              * @public
              */
             getExtremeTickStyle(): TickStyle;
             /**
              * Construct a new *NumericTickStrategy* object based on this one, but with modified formatting offset.
              *
              * `formattingOffset` is an optional coordinate to offset from tick coordinates when formatting tick labels and default cursor labels.
              *
              * If supplied, the value of `formattingOffset` will be added to every coordinate before formatting.
              * This can be useful for offsetting displayed data ranges in cases where actual data can't be practically rendered due to extremely large numbers for example.
              *
              * ```
              *  // Example, specify formatting offset.
              *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
              *      // Will result in `0` being formatted as `1000000`
              *      .setFormattingOffset(1000000)
              *  )
              * ```
              *
              * @public
              */
             setFormattingOffset(formattingOffset: number | undefined): this;
             /**
              * Get `formattingOffset` of Tick strategy.
              *
              * `formattingOffset` is an optional coordinate to offset from tick coordinates when formatting tick labels and default cursor labels.
              *
              * If supplied, the value of `formattingOffset` will be added to every coordinate before formatting.
              * This can be useful for offsetting displayed data ranges in cases where actual data can't be practically rendered due to extremely large numbers for example.
              *
              * ```
              *  // Example, specify formatting offset.
              *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
              *      // Will result in `0` being formatted as `1000000`
              *      .setFormattingOffset(1000000)
              *  )
              * ```
              * @public
              */
             getFormattingOffset(): number | undefined;
             /**
              * Construct a new *NumericTickStrategy* object based on this one, but with modified major tick style.
              *
              * Example usage:
              *
              * **Set font of major ticks**:
              * ```javascript
              * Axis.setTickStrategy(
              *     AxisTickStrategies.Numeric,
              *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
              *         .setMajorTickStyle(( tickStyle ) => tickStyle
              *             .setLabelFont(( font ) => font
              *                 .setWeight( 'bold' )
              *             )
              *         )
              * )
              * ```
              * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
              * @returns New *NumericTickStrategy* object.
              * @public
              */
             setMajorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
             /**
              * Get major tick style of this *NumericTickStrategy* object.
              * @returns Major tick style.
              * @public
              */
             getMajorTickStyle(): TickStyle;
             /**
              * Construct a new *NumericTickStrategy* object based on this one, but with modified minor tick style.
              *
              * Example usage:
              *
              * **Disable minor ticks**:
              * ```javascript
              * Axis.setTickStrategy(
              *     AxisTickStrategies.Numeric,
              *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
              *         .setMinorTickStyle( emptyTick )
              * )
              * ```
              *
              * **Set font of minor ticks**:
              * ```javascript
              * Axis.setTickStrategy(
              *     AxisTickStrategies.Numeric,
              *     ( tickStrategy: NumericTickStrategy ) => tickStrategy
              *         .setMinorTickStyle(( tickStyle: TickStyle ) => tickStyle
              *             .setLabelFont(( font ) => font
              *                 .setWeight( 'bold' )
              *             )
              *         )
              * )
              * ```
              * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
              *                              Passing a function only works if the existing style is **not** *emptyTick*.
              * @returns New *NumericTickStrategy* object.
              * @public
              */
             setMinorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
             /**
              * Get minor tick style of this *NumericTickStrategy* object.
              * @returns Minor tick style.
              * @public
              */
             getMinorTickStyle(): TickStyle;
             /**
              * Utility method for setting *formatting function* of all numeric tick levels (extreme, major, minor) as well as cursor.
              *
              * Each formatting target can be individually overridden with following methods:
              * - {@link setExtremeFormattingFunction} | extreme ticks
              * - {@link setMajorFormattingFunction} | major ticks
              * - {@link setMinorFormattingFunction} | minor ticks
              * - {@link setCursorFormatter} | cursor result table and ticks
              * @param formattingFunction - Function that formats a tick value to text.
              * @returns New *NumericTickStrategy* object.
              * @public
              */
             setFormattingFunction(formattingFunction: FormattingFunction): this;
             /**
              * Get extreme ticks formatting function of this *NumericTickStrategy* object.
              * @returns Formatting Function.
              * @public
              */
             getExtremeFormattingFunction(): FormattingFunction | undefined;
             /**
              * Set extreme ticks formatting function of this *NumericTickStrategy* object.
              * @param formattingFunction - Formatting function to use with this *NumericTickStrategy* object.
              * @returns New *NumericTickStrategy* object.
              * @public
              */
             setExtremeFormattingFunction(formattingFunction: FormattingFunction): this;
             /**
              * Get major ticks formatting function of this *NumericTickStrategy* object.
              * @returns Formatting Function.
              * @public
              */
             getMajorFormattingFunction(): FormattingFunction | undefined;
             /**
              * Set major ticks formatting function of this *NumericTickStrategy* object.
              * @param formattingFunction - Formatting function to use with this *NumericTickStrategy* object.
              * @returns New *NumericTickStrategy* object.
              * @public
              */
             setMajorFormattingFunction(formattingFunction: FormattingFunction): this;
             /**
              * Get minor ticks formatting function of this *NumericTickStrategy* object.
              * @returns Formatting Function.
              * @public
              */
             getMinorFormattingFunction(): FormattingFunction | undefined;
             /**
              * Set minor ticks formatting function of this *NumericTickStrategy* object.
              * @param formattingFunction - Formatting function to use with this *NumericTickStrategy* object.
              * @returns New *NumericTickStrategy* object.
              * @public
              */
             setMinorFormattingFunction(formattingFunction: FormattingFunction): this;
         }
         /**
          * Modifiable properties of a Numeric *TickStrategy*.
          *
          * @public
          */
         declare interface NumericTickStrategyProperties {
             type: 'numeric-ticks';
             /**
              * Style of Extreme ticks (start & end of Axis).
              *
              * To disable extreme ticks, set to **emptyTick**.
              */
             readonly extremeTickStyle: TickStyle;
             /**
              * Style of Major ticks.
              */
             readonly majorTickStyle: TickStyle;
             /**
              * Style of Minor ticks.
              *
              * To disable minor ticks, set to **emptyTick**.
              */
             readonly minorTickStyle: TickStyle;
             /**
              * Optional coordinate to offset from tick coordinates when formatting tick labels and default cursor labels.
              *
              * If supplied, the value of `formattingOffset` will be added to every coordinate before formatting.
              * This can be useful for offsetting displayed data ranges in cases where actual data can't be practically rendered due to extremely large numbers for example.
              *
              * ```
              *  // Example, specify formatting offset.
              *  Axis.setTickStrategy(AxisTickStrategies.Numeric, (ticks) => ticks
              *      // Will result in `0` being formatted as `1000000`
              *      .setFormattingOffset(1000000)
              *  )
              * ```
              */
             readonly formattingOffset: number | undefined;
             /**
              * Cursor formatter.
              *
              * This controls the formatting used by:
              * - Default cursor result table formatters.
              * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
              * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
              *
              * `undefined` means to use default Numeric cursor formatting.
              *
              * ```ts
              *  // Example value, custom cursor formatter
              *  cursorFormatter: (value, range, locale) => value.toFixed(3)
              * ```
              */
             readonly cursorFormatter: FormattingFunction | undefined;
             /**
              * Formatting function used for extreme ticks.
              *
              * Use FormattingFunctions to select available ones or define custom function.
              *
              * **undefined** will result in default selection.
              */
             readonly extremeFormattingFunction?: FormattingFunction;
             /**
              * Formatting function used for major ticks.
              *
              * Use FormattingFunctions to select available ones or define custom function.
              *
              * **undefined** will result in default selection.
              */
             readonly majorFormattingFunction?: FormattingFunction;
             /**
              * Formatting function used for minor ticks.
              *
              * Use FormattingFunctions to select available ones or define custom function.
              *
              * **undefined** will result in default selection.
              */
             readonly minorFormattingFunction?: FormattingFunction;
         }
         /**
          * Default Numeric TickStrategy settings.
          * @public
          */
         declare const NumericTickStrategyRecord: Record_2.Factory<NumericTickStrategyProperties>;
         /**
          * Container class for a value that can be observed.
          * (event which is triggered when value is set)
          * Internal class
          * @public
          */
         declare class ObservableValue<T> {
         }
         /**
          * Interface for SeriesXY types whose data can be observed in detail.
          *
          * The intent is that all SeriesXY types implement this, apart from Figure series. It is used for ZoomBandChart functionality.
          * @typeParam T -   Type of data-point in Series (eq. Point, AreaPoint, XOHLC, ...).
          *
          * @privateRemarks
          * This should be private but as it's implemented by BasicSeries it has to be considered public
          *
          * @public
          */
         export declare interface ObservableXYData<T> {
         }
         /**
          * Interface for an official LightningChart JS theme.
          *
          * On top of Theme properties, also requires "optional" theme properties utilized in Interactive Examples and other official LCJS applications.
          * @public
          */
         export declare interface OfficialTheme extends Theme {
             examples: ThemeExampleProperties;
         }
         /**
          * Interface for CursorPoints that point to an OHLCSegment.
          * Used to pack information about pointed segment to users.
          * @public
          */
         export declare interface OHLCCursorPoint extends CursorPoint, OHLCSegment {
         }
         /**
          * Interface for data values of an OHLC segment.
          * @public
          */
         export declare interface OHLCSegment {
             position: number;
             open: number;
             high: number;
             low: number;
             close: number;
             isPacked: boolean;
         }
         /**
          * Series type for visualizing trading figures in large quantities and/or with real-time data input.
          *
          * **OHLC Series is only usable with a Trading license for LightningChart JS**
          *
          * **Creating OHLCSeries:**
          *
          * `OHLCSeries` are created with {@link ChartXY.addOHLCSeries} method.
          *
          * Some properties of `OHLCSeries` can only be configured when it is created. These arguments are all optional,
          * and are wrapped in a single object parameter:
          *
          * ```typescript
          *  // Example,
          *  const lineSeries = ChartXY.addOHLCSeries({
          *      // Specify non-default X Axis to attach series to.
          *      xAxis: myNonDefaultAxisX
          *  })
          * ```
          *
          * To learn about available properties, refer to {@link OHLCSeriesOptions}.
          *
          * **Frequently used methods:**
          *
          * - Append data points to series | {@link add}
          * - Remove all data points from series | {@link clear}
          * - Configure cursor enabled | {@link setCursorEnabled}
          * - Destroy series permanently | {@link dispose}
          * - Solve nearest data point from specified location | {@link solveNearestFromScreen}
          * - Set figure width | {@link setFigureWidth}
          * - Enable/disable automatic figure packing | {@link setPackData}
          * - Configure auto cursor result table formatting | {@link setCursorResultTableFormatter}
          *
          * There are 2 types of OHLC series, each with their own styling API:
          * - {@link OHLCSeriesCandlesticks}
          * - {@link OHLCSeriesBars}
          *
          * By default, candlesticks are created, bars can be selected using {@link OHLCSeriesOptions.type} property.
          * @public
          */
         export declare abstract class OHLCSeries extends SeriesXY<OHLCCursorPoint, LinearScaleXY | MixedScaleXY> implements ObservableXYData<XOHLC> {
             /**
              * @returns Max X value of the series
              * @public
              */
             getXMax(): number;
             /**
              * @returns Min X value of the series
              * @public
              */
             getXMin(): number;
             /**
              * @returns Max Y value of the series
              * @public
              */
             getYMax(): number;
             /**
              * @returns Min Y value of the series
              * @public
              */
             getYMin(): number;
             /**
              * Add OHLC segments to series.
              * NOTE: Added segments must always have progressive X values!
              * @param data - Array of X+OHLC values.
              * @returns Object itself for fluent interface.
              * @public
              */
             add(xohlc: XOHLC[] | XOHLC): this;
             /**
              * Enable/disable automatic data packing.
              * @param pack - Packing disabled or enabled.
              * @returns Object itself for fluent interface.
              * @public
              */
             setPackData(pack: boolean): this;
             /**
              * @returns Packing status. True = packing enabled, false = disabled. Default is true.
              * @public
              */
             getPackData(): boolean;
             /**
              * Get active state of automatic packing.
              * If packing is active, this tells how long time is represented by 1 figure (candle, bar, etc.).
              *
              * This information is not necessarily up to date when the method is called. If you are using methods like `add`, `setFigureWidth` etc.
              * before calling the method you may need to wait 1 frame (`requestAnimationFrame`) before calling this method to get the proper result.
              * @returns     Information about active packing state
              * @public
              */
             getPackDataState(): undefined | {
                 figureAxisInterval: number;
             };
             /**
              * Set drawn figure width in pixels.
              * @param widthPixels - width in pixels
              * @returns Object itself for fluent interface.
              * @public
              */
             setFigureWidth(widthPixels: pixel): this;
             /**
              * Get drawn figure width in pixels.
              * @returns width in pixels
              */
             getFigureWidth(): pixel;
             /**
              * Set minimum gap between sticks in pixels when packing is enabled.
              * @param gap - minimum Gap in pixels.
              * @returns Object itself for fluent interface.
              * @public
              */
             setFigureMinimumGap(gap: pixel): this;
             /**
              * Get minimum gap between sticks in pixels when packing is enabled.
              * @returns minimum Gap in pixels.
              */
             getFigureMinimumGap(): pixel;
             /**
              * Method for solving the nearest data point from a given coordinate on screen.
              *
              * ```ts
              *  // Example usage, from mouse move event.
              *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
              *      const result = LineSeries.solveNearestFromScreen(event)
              *  })
              * ```
              *
              * ```ts
              *  // Example usage, arbitrary coordinate on client coordinate system.
              *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
              * ```
              *
              * Translating coordinates from other coordinate systems is also possible, see {@link ChartXY.translateCoordinate}.
              *
              * @param   location -  Location in HTML client coordinates.
              * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
              * @public
              */
             solveNearestFromScreen(location: CoordinateClient): undefined | OHLCCursorPoint;
             /**
              * Abstract method that solves the nearest datapoint to a given coordinate on screen.
              * @param location - Location on screen
              * @returns Undefined or data-structure for positioning of cursors
              * @public
              * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
              */
             solveNearestFromScreen(location: Point): undefined | OHLCCursorPoint;
             /**
              * Clear all previously pushed data points from the *series*.
              *
              * ```ts
              *  // Example usage
              *  series.clear()
              * ```
              *
              * @returns Object itself for fluent interface.
              * @public
              */
             clear(): this;
             /**
              * Set new ResultTable formatter.
              * @param formatter - ResultTable formatter.
              * @returns Object itself for fluent interface.
              * @public
              */
             setCursorResultTableFormatter(formatter: OHLCSeriesFormatter): this;
         }
         /**
          * Implementation of {@link OHLCSeries} displayed as bars.
          *
          * See documentation of generic super class for more instructions on how to create one, and common configuration {@link OHLCSeries}.
          *
          * **Frequently used methods:**
          *
          * - Set stroke style for negative segments | {@link setStrokeStyleNegative}
          * - Set stroke style for positive segments | {@link setStrokeStylePositive}
          *
          * @public
          */
         export declare class OHLCSeriesBars extends OHLCSeries {
             /**
              * Set positive change stroke style.
              * @returns Object itself for fluent interface.
              * @public
              */
             setStrokeStylePositive(value: LineStyle | ImmutableMutator<LineStyle>): this;
             /**
              * Get positive change stroke style.
              * @returns stroke style.
              * @public
              */
             getStrokeStylePositive(): LineStyle;
             /**
              * Set negative change stroke style.
              * @returns Object itself for fluent interface.
              * @public
              */
             setStrokeStyleNegative(value: LineStyle | ImmutableMutator<LineStyle>): this;
             /**
              * Get negative change stroke style.
              * @returns stroke style.
              * @public
              */
             getStrokeStyleNegative(): LineStyle;
             /**
              * Attach object to an legendBox entry
              * @param entry - Object which has to be attached
              * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
              *                          when its respective Entry is clicked.
              * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
              * @returns Series itself for fluent interface
              * @public
              * @privateRemarks  Override
              */
             attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
             /**
              * Set drawn figure width in pixels.
              * @param widthPixels - width in pixels
              * @returns Object itself for fluent interface.
              * @public
              * @privateRemarks  Override
              */
             setFigureWidth(widthPixels: number): this;
         }
         /**
          * Implementation of {@link OHLCSeries} displayed as candlesticks.
          *
          * See documentation of generic super class for more instructions on how to create one, and common configuration {@link OHLCSeries}.
          *
          * **Frequently used methods:**
          *
          * - Set body thickness | {@link setBodyThickness}
          * - Set body fill style for negative segments | {@link setBodyFillStyleNegative}
          * - Set body fill style for positive segments | {@link setBodyFillStylePositive}
          * - Set tail stroke style for negative segments | {@link setTailStrokeStyleNegative}
          * - Set tail stroke style for positive segments | {@link setTailStrokeStylePositive}
          *
          * @public
          */
         export declare class OHLCSeriesCandlesticks extends OHLCSeries {
             /**
              * Set body thickness in pixels.
              * @param thickness - New body thickness in pixels.
              * @returns Object itself for fluent interface.
              * @public
              */
             setBodyThickness(thickness: pixel): this;
             /**
              * @returns Get body thickness in pixels.
              * @public
              */
             getBodyThickness(): pixel;
             /**
              * Set positive change fill style. Note! Supported fill style: SolidFill.
              * @returns Object itself for fluent interface.
              * @public
              */
             setBodyFillStylePositive(value: FillStyle | ImmutableMutator<FillStyle>): this;
             /**
              * Get positive change fill style. Note! Supported fill style: SolidFill.
              */
             getBodyFillStylePositive(): FillStyle;
             /**
              * Set negative change fill style. Note! Supported fill style: SolidFill.
              * @returns Object itself for fluent interface.
              * @public
              */
             setBodyFillStyleNegative(value: FillStyle | ImmutableMutator<FillStyle>): this;
             /**
              * Get negative change fill style. Note! Supported fill style: SolidFill.
              */
             getBodyFillStyleNegative(): FillStyle;
             /**
              * Set positive change tail line stroke style.
              * @returns Object itself for fluent interface.
              * @public
              */
             setTailStrokeStylePositive(value: LineStyle | ImmutableMutator<LineStyle>): this;
             /**
              * Get positive change tail line stroke style.
              * @returns Tail line stroke style.
              * @public
              */
             getTailStrokeStylePositive(): LineStyle;
             /**
              * Set negative change tail line stroke style.
              * @returns Object itself for fluent interface.
              * @public
              */
             setTailStrokeStyleNegative(value: LineStyle | ImmutableMutator<LineStyle>): this;
             /**
              * Get negative change tail line stroke style.
              * @returns Tail line stroke style.
              * @public
              */
             getTailStrokeStyleNegative(): LineStyle;
             /**
              * Attach object to an legendBox entry
              * @param entry - Object which has to be attached
              * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
              *                          when its respective Entry is clicked.
              * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
              * @returns Series itself for fluent interface
              * @public
              * @privateRemarks  Override
              */
             attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
         }
         /**
          * Interface for a function which builds ResultTable content when pointing at an OHLCSeries.
          * @param tableContentBuilder - Builder that is used to build contents of ResultTable.
          *                                  Use addRow() method for adding content.
          * @param series - OHLCSeries
          * @param ohlcSegment - OHLCSegment that is pointed. Has methods for reading its Open, High, Low, Close and Position values.
          * @returns TableContentBuilder that was supplied
          * @public
          */
         export declare type OHLCSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: OHLCSeries, ohlcSegment: OHLCSegment) => T;
         /**
          * Interface for readonly configuration of {@link OHLCSeries}.
          *
          * **Commonly used properties:**
          * - {@link OHLCSeriesOptions.xAxis}: Attach series on non-default X Axis.
          * - {@link OHLCSeriesOptions.yAxis}: Attach series on non-default Y Axis.
          * - {@link OHLCSeriesOptions.type}: Select how trading data is displayed (candlesticks, bars, etc.).
          *
          * **Example usage:**
          *
          * ```typescript
          *  // Example 1, create series with default configuration.
          *  const series = ChartXY.addOHLCSeries({})
          * ```
          *
          * ```typescript
          *  // Example 2, display data as bars
          *  const series = ChartXY.addOHLCSeries({
          *      type: OHLCSeriesTypes.Bars
          *  })
          * ```
          *
          * See also {@link ChartXY.addOHLCSeries}.
          * @public
          */
         export declare interface OHLCSeriesOptions<Type extends OHLCSeriesTypes> extends SeriesOptionsXY {
             /**
              * Specify how trading data is displayed (candlesticks, bars, etc.).
              *
              * Available options are listed and accessed via {@link OHLCSeriesTypes}.
              *
              * ```ts
              *  // Example
              *  const candlestickSeries = ChartXY.addOHLCSeries({ type: OHLCSeriesTypes.Candlesticks })
              * ```
              */
             type?: Type;
         }
         /**
          * Collection of different types of {@link OHLCSeries}.
          * Used when creating one using {@link ChartXY.addOHLCSeries} method.
          *
          * ```ts
          *  // Example
          *  const candlestickSeries = ChartXY.addOHLCSeries({ type: OHLCSeriesTypes.Candlesticks })
          * ```
          * @public
          */
         export declare const OHLCSeriesTypes: {
             /**
              * Display trading figures as Candlesticks.
              * See available styling API from {@link OHLCSeriesCandlesticks}
              *
              * ```ts
              *  // Example
              *  const candlestickSeries = ChartXY.addOHLCSeries({ type: OHLCSeriesTypes.Candlesticks })
              * ```
              * @public
              */
             Candlesticks: typeof OHLCSeriesCandlesticks;
             /**
              * Display trading figures as Bars.
              * See available styling API from {@link OHLCSeriesBars}
              *
              * ```ts
              *  // Example
              *  const ohlcSeries = ChartXY.addOHLCSeries({ type: OHLCSeriesTypes.Bars })
              * ```
              * @public
              */
             Bars: typeof OHLCSeriesBars;
         };
         /**
          * Type union for possible types of {@link OHLCSeries}.
          * @public
          */
         export declare type OHLCSeriesTypes = typeof OHLCSeriesTypes[keyof typeof OHLCSeriesTypes];
         /**
          * Main implementation for OnScreenMenu.
          * This class handles the DOM creation, initialization and event wiring of the core OSM container.
          *
          * @beta This feature is considered experimental and might be changed in minor release.
          */
         export declare class OnScreenMenu {
             /**
              * @public
              */
             protected chart: ChartXY;
             /**
              * Remove the position properties for the div containing osm menu button.
              * @public
              */
             removePositionProperty(): void;
             /**
              * Set the position property for the div containing the OSM menu.
              * @param position - The {@link OSMPosition} where one wants to place the OnScreenMenu on the screen.
              * @public
              */
             setPositionProperty(position: OSMPosition): void;
             /**
              * **Permanently** destroy the component.
              *
              * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
              * **to the component and its children** in application code.
              * ```javascript
              * let chart = ...ChartXY()
              * let axisX = chart.getDefaultAxisX()
              * // Dispose Chart, and remove all references so that they can be garbage-collected.
              * chart.dispose()
              * chart = undefined
              * axisX = undefined
              * ```
              * @returns Object itself for fluent interface
              * @public
              */
             dispose(): void;
             /**
              * Subscribe `onDispose` event.
              * This event is triggered whenever the On-Screen-menu is disposed.
              *
              * ```typescript
              *  // Example usage
              *
              * OSM.onDispose(() => {
              *   console.log('OSM was disposed')
              * })
              *
              * OSM.dispose()
              * ```
              *
              * @param clbk - Event handler function
              * @returns Token of subscription
              * @public
              */
             onDispose(clbk: (obj: this) => void): Token;
             /**
              * Remove event listener from dispose event.
              * @param token - Token of event listener which has to be removed
              * @returns True if the listener is successfully removed and false if it is not found
              * @public
              */
             offDispose(token: Token): boolean;
         }
         /**
          * On-Screen Menu button shapes.
          * @public
          */
         export declare enum OnScreenMenuButtonShape {
             Circle = 0,
             Rectangle = 1,
             RoundedRectangle = 2
         }
         /**
          * Lists the various types of pre-defined buttons that can be added to the On-Screen Menu.
          * @public
          */
         export declare enum OnScreenMenuButtonType {
             ZoomIn = 0,
             ZoomInX = 1,
             ZoomInY = 2,
             ZoomOut = 3,
             ZoomOutX = 4,
             ZoomOutY = 5,
             ZoomToFit = 6,
             ToggleAnimations = 7
         }
         /**
          * Base unit height for all controls. This value is multiplied by the
          * rows specified in the {@link OnScreenMenuDimensions} interface to get the final
          * control dimensions.
          * @public
          */
         export declare const onScreenMenuControlBaseHeight: number;
         /**
          * Base unit width for all controls. This value is multiplied by the
          * columns specified in the {@link OnScreenMenuDimensions} interface to get the final
          * control dimensions.
          * @public
          */
         export declare const onScreenMenuControlBaseWidth: number;
         /**
          * Default opacity value for all On-Screen Menu controls.
          * @public
          */
         export declare const onScreenMenuControlOpacity: string;
         /**
          * Interface to describe parameters that are used to construct a custom button for the On-Screen Menu.
          * @public
          */
         export declare interface OnScreenMenuCustomButtonParams {
             /**
              * Path to an icon that this button will display.
              */
             icon?: string;
             /**
              * Optional label to be displayed on the button.
              */
             label?: string;
             dimensions?: OnScreenMenuDimensions;
             /**
              * Optional opacity for the button. Accepts a value between 0 and 1, were 0 is transparent and 1 is opaque.
              */
             opacity?: string;
             /**
              * Optional color value for this button. If no value is specified, the color will be chosen from the theme.
              */
             color?: string;
             /**
              * Optional value for the shape of the button.
              */
             shape?: OnScreenMenuButtonShape;
             /**
              * Function that represents the action to be performed on the click of the button.
              */
             action: (chart: ChartXY) => void;
         }
         /**
          * Default button Shape for all On-Screen menu buttons.
          * @public
          */
         export declare const onScreenMenuDefaultButtonShape: OnScreenMenuButtonShape;
         /**
          * Interface that describes an abstract dimensions for {@link OnScreenMenu} controls.
          * We use this to determine sizing based on a grid layout in HTML.
          * @public
          */
         export declare interface OnScreenMenuDimensions {
             /**
              * The number of rows in the grid the control will take up.
              */
             rows: number;
             /**
              * The number of columns in the grid the control will take up.
              */
             columns: number;
         }
         /** @public */
         export declare interface OnScreenMenuIconSet {
             ZoomIn: string | SpriteImagePosition;
             ZoomInX: string | SpriteImagePosition;
             ZoomInY: string | SpriteImagePosition;
             ZoomOut: string | SpriteImagePosition;
             ZoomOutX: string | SpriteImagePosition;
             ZoomOutY: string | SpriteImagePosition;
             ZoomToFit: string | SpriteImagePosition;
             EnableAnimation: string | SpriteImagePosition;
             DisableAnimation: string | SpriteImagePosition;
             CollapseMenu: string | SpriteImagePosition;
             ShowMenu: string | SpriteImagePosition;
         }
         /**
          * url for sprite image
          * @public
          */
         export declare const onScreenMenuSpriteURL: string;
         /**
          * Enum for various types of pre-defined positions that On-Screen Menu button can take.
          * @public
          */
         export declare enum OSMPosition {
             TopRight = 0,
             TopLeft = 1,
             BottomLeft = 2,
             BottomRight = 3
         }
         /**
          * Interface for overriding mouse buttons that trigger user interactions.
          *
          * Can be supplied along {@link LightningChartOptions} before creating any chart or series, when initiating the `lightningChart` function:
          *
          * ```typescript
          *  const lcjs = lightningChart({
          *      overrideInteractionMouseButtons: {
          *          chartXYPanMouseButton: 0, // LMB
          *          chartXYRectangleZoomFitMouseButton: 2, // RMB
          *      }
          *  })
          *
          *  // Create charts...
          *  const chart = lcjs.ChartXY()
          * ```
          * @public
          */
         export declare interface OverrideInteractionMouseButtons {
             /**
              * Override mouse button that activates *rectangle zoom / fit* actions when dragging over ChartXY series background.
              *
              * By default *Left Mouse Button* (`0`).
              *
              * - Left Mouse Button = `0`
              * - Middle Mouse Button = `1`
              * - Right Mouse Button = `2`
              * @public
              */
             chartXYRectangleZoomFitMouseButton?: number;
             /**
              * Override mouse button that activates *panning* action when dragging over ChartXY series background.
              *
              * By default *Right Mouse Button* (`2`).
              *
              * - Left Mouse Button = `0`
              * - Middle Mouse Button = `1`
              * - Right Mouse Button = `2`
              * @public
              */
             chartXYPanMouseButton?: number;
             /**
              * Override mouse button that activates *zooming* action when dragging over ChartXY Axis.
              *
              * By default *Left Mouse Button* (`0`).
              *
              * - Left Mouse Button = `0`
              * - Middle Mouse Button = `1`
              * - Right Mouse Button = `2`
              * @public
              */
             axisXYZoomMouseButton?: number;
             /**
              * Override mouse button that activates *panning* action when dragging over ChartXY Axis.
              *
              * By default *Right Mouse Button* (`2`).
              *
              * - Left Mouse Button = `0`
              * - Middle Mouse Button = `1`
              * - Right Mouse Button = `2`
              * @public
              */
             axisXYPanMouseButton?: number;
         }
         /**
          * Interface for a data-structure which represents a measurement of four sides.
          * Has number properties for:
          * - left
          * - top
          * - right
          * - bottom
          *
          * This data-structure is mainly used for specifying Chart paddings and UIElement paddings/margins.
          *
          * Duplicate of Margin.
          * @public
          */
         export declare type Padding = Margin;
         /**
          * Type of an abstract Palette function.
          * NOTE: It is common for applications dealing with Palettes to assume that they are continuous,
          * meaning that when supplied an overflowing index, it will return loop back to start.
          * @param index - Index of item to pick from Palette
          * @returns Generated item
          * @public
          */
         export declare type Palette<T> = (index: number) => T;
         /**
          * Style class for describing a *dynamically looked up fill color*. Using a PalettedFill, each data point (or even pixel) can be colored individually.
          * The basis of coloring can be configured extensively, with a variety of different option combinations (read below for details).
          *
          * Instances of PalettedFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
          * but instead return a completely new modified object.
          *
          * **Properties of PalettedFill:**
          * - `lut`: color lookup table. Essentially a list of *colors* paired with numeric values. See {@link LUT} for more details.
          * - `lookUpProperty`: selects basis of color lookup. See {@link LookUpProperty} for possible options.
          *
          * **PalettedFill Usage:**
          *
          * PalettedFill can be used with a select group of features:
          *
          * - {@link PointSeries.setPointFillStyle}
          * - {@link SurfaceGridSeries3D.setFillStyle}
          * - {@link SurfaceScrollingGridSeries3D.setFillStyle}
          * - {@link PointSeries3D.setPointStyle}
          * - {@link BoxSeries3D.setFillStyle}
          * - {@link MapChart.setFillStyle}
          *
          * ```typescript
          *  // Example 1, paletted points fill by 'y' coordinates.
          *  PointSeries.setPointFillStyle(new PalettedFill({
          *      lookUpProperty: 'y',
          *      lut: new LUT({
          *          interpolate: true,
          *          steps: [
          *              { value: 0, color: ColorRGBA( 0, 0, 0 ) },
          *              { value: 10, color: ColorRGBA( 255, 0, 0 ) },
          *              { value: 20, color: ColorRGBA( 0, 255, 0 ) },
          *              { value: 30, color: ColorRGBA( 0, 0,255 ) },
          *          ]
          *      })
          *  }))
          * ```
          *
          * ```typescript
          *  // Example 2, paletted points fill by user supplied data point values.
          *  PointSeries
          *      .setPointFillStyle(new PalettedFill({
          *           lookUpProperty: 'value',
          *           lut: new LUT({
          *               interpolate: true,
          *               steps: [
          *                   { value: 0, color: ColorRGBA( 0, 0, 0 ) },
          *                   { value: 100, color: ColorRGBA( 255, 0, 0 ) },
          *               ]
          *           })
          *      }))
          *      .add([
          *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
          *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
          *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
          *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
          *          { x: Math.random() * 100, y: Math.random() * 100, value: Math.random() * 100 },
          *      ])
          * ```
          *
          * **Related information:**
          *
          * For more *fill styles*, see:
          * - {@link SolidFill}
          * - {@link emptyFill}
          * - {@link IndividualPointFill}
          * - {@link RadialGradientFill}
          * - {@link LinearGradientFill}
          *
          * @public
          */
         export declare class PalettedFill<T extends LookUpProperty = LookUpProperty> extends PalettedFillStyleRecord implements FillStyle {
             /**
              * Construct a PalettedFill object, specifying any amount of its properties.
              *
              * ```typescript
              *  // Example 1, palette by 'y' coordinate.
              *  const paletteY = new PalettedFill({
              *      lookUpProperty: 'y',
              *      lut: new LUT({
              *          interpolate: true,
              *          steps: [
              *              { value: 0, color: ColorRGBA( 0, 0, 0 ) },
              *              { value: 10, color: ColorRGBA( 255, 0, 0 ) },
              *              { value: 20, color: ColorRGBA( 0, 255, 0 ) },
              *              { value: 30, color: ColorRGBA( 0, 0,255 ) },
              *          ]
              *      })
              *  })
              * ```
              *
              * ```typescript
              *  // Example 2, palette by user supplied data point values.
              *  const paletteValue = new PalettedFill({
              *      lookUpProperty: 'value',
              *      lut: new LUT({
              *          interpolate: true,
              *          steps: [
              *              { value: 0, color: ColorRGBA( 0, 0, 0 ) },
              *              { value: 100, color: ColorRGBA( 255, 0, 0 ) },
              *          ]
              *      })
              *  })
              * ```
              *
              * For more details, see {@link LUT}, and {@link LookUpProperty}.
              *
              * @param props - Object containing any amount of PalettedFill properties.
              * @public
              */
             constructor(props?: Partial<PalettedFillProperties<T>>);
             /**
              * Get LUT lookup table.
              * @returns LUT object.
              * @public
              */
             getPalette(): LUT;
             /**
              * Construct a new PalettedFill object based on this one, but with modified 'lookUpProperty'.
              *
              * Example:
              * ```ts
              * palettedFill.setLookUpProperty( 'y' )
              * ```
              * @param value - {@link LookUpProperty}.
              * @returns New PalettedFill object.
              * @public
              */
             setLookUpProperty<PT extends LookUpProperty>(value: PT | ImmutableMutator<LookUpProperty, PT>): PalettedFill<PT>;
             /**
              * Get look up property of PalettedFill.
              * @returns {@link LookUpProperty}.
                  * @public
                  */
              getLookUpProperty(): LookUpProperty;
             }
             /**
              * Interface for all properties of a PalettedFillStyle.
              * @public
              */
             export declare interface PalettedFillProperties<T extends LookUpProperty = LookUpProperty> {
                 type: 'fillstyle';
                 fillType: 'palette';
                 /**
                  * Color lookup table, which describes the relation of `lookUpProperty` values to colors.
                  */
                 lut: LUT;
                 /**
                  * Identifier that points to a property to be used when picking colours from attached Look Up Table.
                  *
                  * Possible values are:
                  * - **"value"**
                  * - **"x"**
                  * - **"y"**
                  * - **"z"**
                  *
                  * Features that support assigning a {@link PalettedFill} contain additional per-feature information, which
                  * properties are supported, and how they behave.
                  */
                 lookUpProperty: T;
             }
             /**
              * Record contractor for PalettedFillStyleProperties.
              * @public
              */
             declare const PalettedFillStyleRecord: Record_2.Factory<PalettedFillProperties<LookUpProperty>>;
             /**
              * Type of an abstract Palette factory.
              * @param length - Length of Palette
              * @returns Palette of specified length
              * @public
              */
             export declare type PaletteFactory<T> = (length: number, color?: Color) => Palette<T>;
             /**
              * Abstract base class for charts and UI panels
              * @public
              */
             export declare abstract class Panel implements Control, DashboardPanel {
                 /**
                  * Selector for "relative" _Coordinate System_.
                  *
                  * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
                  * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
                  *
                  * This selector can be used for two purposes:
                  *
                  * **Positioning LCJS UI elements in pixels:**
                  *
                  * ```ts
                  *  // Position UI element in pixels by supplying `Control.coordsRelative` as its positioning system.
                  *  const textBox = Control.addUIElement(UIElementBuilders.TextBox, Control.coordsRelative)
                  *      .setOrigin(UIOrigins.LeftBottom)
                  *      .setPosition({ x: 100, y: 20 })
                  * ```
                  *
                  * **Translations between coordinate systems:**
                  *
                  * Use with {@link translateCoordinate} method to translate coordinates from "relative" to another coordinate system.
                  *
                  * @public
                  */
                 readonly coordsRelative: CoordinateSystemRelative;
                 /**
                  * Selector for "client" _Coordinate System_.
                  *
                  * This references the coordinate system used in HTML.
                  * It starts at top left of the web page and is measured in pixels.
                  * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
                  *
                  * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
                  *
                  * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
                  * For example, in order to:
                  * - Position LCJS UI elements in client coordinates
                  * - Find client coordinate that matches a location along LCJS Axis or Chart.
                  * - etc.
                  *
                  * See {@link translateCoordinate} for more detailed use case information and example usage.
                  *
                  * @public
                  */
                 readonly coordsClient: CoordinateSystemClient;
                 /**
                  * Interface for end user API of the LCJS engine.
                  * It provides some useful capabilities over the area enclosed by a single LCJS context (which can be just a single chart, or a Dashboard with several charts).
                  * @public
                  */
                 readonly engine: PublicEngine;
                 /**
                  * Scale for panel area in percentages (0-100).
                  *
                  * While it is not functionally equal to this, using [[coordsRelative]] coordinate system is preferred (more confidence for long term support).
                  * @public
                  */
                 uiScale: LinearScaleXY;
                 /**
                  * Scale for panel area in pixels.
                  * @public
                  * @deprecated  Deprecated since v4.2.0. Use [[coordsRelative]] instead. It works exactly the same.
                  */
                 pixelScale: LinearScaleXY;
                 /**
                  * @public
                  */
                 protected removePanel: (panel: Panel) => void;
                 /**
                  * Get minimum size of Panel.
                  * Depending on the type of class this value might be automatically computed to fit different elements.
                  * @returns Point minimum size or undefined if unimplemented
                  * @public
                  */
                 abstract getMinimumSize(): Point | undefined;
                 /**
                  * Returns the Theme currently being used.
                  * @returns An object containing the Theme.
                  * @public
                  */
                 getTheme(): Theme;
                 /**
                  * Get size of control as pixels.
                  *
                  * For stand-alone component, the size will be equal to the size of its containing HTML \<div\> (`Control.engine.container`)
                  *
                  * For component inside Dashboard, the size will only include the component itself, so size can be less than the size of containing HTML \<div\>.
                  *
                  * @returns     Object with x and y properties `{ x: number, y: number }`, where both are pixel values.
                  * @public
                  */
                 getSizePixels(): Point;
                 /**
                  * Set {@link FillStyle} of chart background.
                  *
                  * ```typescript
                  *  // Example usage,
                  *  ChartXY.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 80, 0, 0 ) }))
                  * ```
                  *
                  * **Related API:**
                  * - Use {@link SolidFill} to describe a solid fill color.
                  * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
                  *
                  * **Transparent chart backgrounds:**
                  *
                  * LightningChart JS charts can be configured to be fully or partially transparent.
                  *
                  * ```ts
                  *  // Example, partially transparent chart
                  *
                  *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
                  *  chart.engine.setBackgroundFillStyle(emptyFill)
                  *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
                  *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                  *  // Some charts also have a separate series background.
                  *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                  * ```
                  *
                  * @param value - `FillStyle` or function which mutates the active `FillStyle`.
                  * @returns Object itself
                  * @public
                  */
                 setBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                 /**
                  * Get fillstyle of chart background.
                  * @returns FillStyle
                  * @public
                  */
                 getBackgroundFillStyle(): FillStyle;
                 /**
                  * Set {@link LineStyle} of chart background border stroke.
                  *
                  * ```typescript
                  *  // Example usage,
                  *  ChartXY.setBackgroundStrokeStyle(new SolidLine({
                  *      thickness: 2,
                  *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
                  *  }))
                  * ```
                  *
                  * **Related API:**
                  * - Use {@link SolidLine} to describe a solid line style.
                  * - Use {@link SolidFill} to describe a solid fill color.
                  * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
                  *
                  * @param value - `LineStyle` or function which mutates the active `LineStyle`.
                  * @returns Object itself
                  * @public
                  */
                 setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                 /**
                  * Get stroke style of chart background.
                  * @returns LineStyle
                  * @public
                  */
                 getBackgroundStrokeStyle(): LineStyle;
                 /**
                  * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
                  *
                  * ```ts
                  *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
                  *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
                  *  // locationRelative is in pixels relative to bottom left corner of the chart
                  * ```
                  *
                  * Relative coordinates can be used for positioning LightningChart JS UI components:
                  *
                  * ```ts
                  *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
                  *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
                  *      .setOrigin(UIOrigins.LeftBottom)
                  *      .setPosition({ x: 20, y: 20 })
                  * ```
                  *
                  * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                  * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                  *
                  * ```ts
                  *  LineSeries.add(myData)
                  *  requestAnimationFrame(() => {
                  *      // translateCoordinate should now consider data added just now.
                  *  })
                  * ```
                  *
                  * @public
                  */
                 translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
                 /**
                  * Translate a coordinate from relative control coordinates to HTML client coordinate system.
                  *
                  * ```ts
                  *  // 10 pixels left and 20 pixels up from controls bottom left corner
                  *  const locationRelative = { x: 10, y: 20 }
                  *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
                  * ```
                  *
                  * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                  *
                  * ```ts
                  *  myHTMLElement.style.position = 'absolute'
                  *  myHTMLElement.style.left = locationClient.clientX
                  *  myHTMLElement.style.top = locationClient.clientY
                  * ```
                  *
                  * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                  * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                  *
                  * ```ts
                  *  LineSeries.add(myData)
                  *  requestAnimationFrame(() => {
                  *      // translateCoordinate should now consider data added just now.
                  *  })
                  * ```
                  *
                  * @public
                  */
                 translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
                 /**
                  * Add a stand-alone *UIElement* using a *builder*.
                  *
                  * **Example usage:**
                  *
                  * 1) TextBox with default positioning coordinate system.
                  *
                  * ```typescript
                  *  addUIElement( UIElementBuilders.TextBox )
                  *      // Position = [0, 100] as percentages.
                  *      .setPosition({ x: 50, y: 50 })
                  * ```
                  *
                  * 2) Position in pixel coordinate system.
                  *
                  * ```typescript
                  *  addUIElement( UIElementBuilders.TextBox, chart.coordsRelative )
                  *      // Position = pixels.
                  *      .setPosition({ x: 300, y: 100 })
                  * ```
                  *
                  * 3) Position on Axes.
                  *
                  * ```typescript
                  *  addUIElement( UIElementBuilders.TextBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
                  *      // Position = Axis values.
                  *      .setPosition({ x: 5, y: 5 })
                  * ```
                  *
                  * @typeParam UIElementType - Type of *UIElement* that is specified by 'builder'-*parameter*.
                  *
                  * @param builder - *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use {@link UIElementBuilders} for selection.
                  * @param scale - Optional parameter for altering the coordinate system used for positioning the UIElement. Defaults to whole Chart in percentages [0, 100].
                  * @returns Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
                  * @public
                  */
                 addUIElement<UIElementType extends UIPart = UITextBox>(builder?: UIElementBuilder<UIElementType>, scale?: UserScaleDefinition): UIElementType & UIElement;
                 /**
                  * Add a *legendbox*.
                  *
                  * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
                  * with user interactions, as well as positioned in application code.
                  *
                  * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
                  * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
                  *
                  * **Legendbox alignment:**
                  *
                  * Alignment of legendbox can be selected by supplying one of the available {@link LegendBoxBuilders} to `addLegendBox`:
                  *
                  * ```typescript
                  *  // Default (vertical) LegendBox.
                  *  const legendBox = ChartXY.addLegendBox()
                  *
                  *  // Horizontal LegendBox.
                  *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
                  * ```
                  *
                  * **Custom Legendbox positioning:**
                  *
                  * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
                  *
                  * A custom location can be configured with {@link UIElement} API:
                  * - {@link UIElement.setPosition}
                  * - {@link UIElement.setOrigin}
                  * - {@link UIElement.setMargin}
                  *
                  * *Position coordinate system* is specified when creating *legendbox*.
                  *
                  * 1) LegendBox with default positioning coordinate system.
                  *
                  * ```typescript
                  *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
                  *      // Position = [0, 100] as percentages.
                  *      .setPosition({ x: 50, y: 50 })
                  * ```
                  *
                  * 2) Position in pixel coordinate system.
                  *
                  * ```typescript
                  *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.coordsRelative )
                  *      // Position = pixels.
                  *      .setPosition({ x: 300, y: 100 })
                  * ```
                  *
                  * 3) Position on Axes.
                  *
                  * ```typescript
                  *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
                  *      // Position = Axis values.
                  *      .setPosition({ x: 5, y: 5 })
                  * ```
                  *
                  * @param builder - *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use {@link LegendBoxBuilders} for selection.
                  * @param scale - Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in percentages [0, 100].
                  * @returns LegendBox
                  * @public
                  */
                 addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox;
                 /**
                  * **Permanently** destroy the component.
                  *
                  * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                  * **to the component and its children** in application code.
                  * ```javascript
                  * let chart = ...ChartXY()
                  * let axisX = chart.getDefaultAxisX()
                  * // Dispose Chart, and remove all references so that they can be garbage-collected.
                  * chart.dispose()
                  * chart = undefined
                  * axisX = undefined
                  * ```
                  * @returns Object itself for fluent interface
                  * @public
                  */
                 dispose(): this;
                 /**
                  * Subscribe `onDispose` event.
                  * This event is triggered whenever the Control (Dashboards and all chart types) is disposed.
                  *
                  * ```typescript
                  *  // Example usage
                  *
                  * Chart.onDispose(() => {
                  *   console.log('chert was disposed')
                  * })
                  *
                  * Chart.dispose()
                  * ```
                  *
                  * @param handler - Handler function for event
                  * @returns Token of subscription
                  * @public
                  */
                 onDispose(handler: (object: this) => unknown): Token;
                 /**
                  * Remove event listener from dispose event.
                  * @param token - Token of event listener which has to be removed
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offDispose(token: Token): boolean;
                 /**
                  * Capture rendered state in an image file. Prompts the browser to download the created file.
                  *
                  * **NOTE: The download might be blocked by browser/plugins as harmful.**
                  * To prevent this, only call the method in events tied to user-interactions.
                  * From mouse-event handlers, for example.
                  *
                  * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
                  * For supported image formats, compression quality, Etc. refer to:
                  *
                  * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
                  *
                  * Example usage:
                  *```javascript
                  * // Download 'screenshot.png'
                  * Panel.saveToFile('screenshot')
                  * // Attempt download 'maybeNotSupported.bmp'
                  * Panel.saveToFile('maybeNotSupported', 'image/bmp')
                  * // Attempt download jpeg.file with specified compression quality
                  * Panel.saveToFile('fileName', 'image/jpeg', 0.50)
                  * ```
                  * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
                  *
                  * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
                  *                          as it is automatically detected from 'type'-argument.
                  * @param type - A DOMString indicating the image format. The default format type is image/png.
                  * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
                  *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
                  *                          the default value for image quality is used. The default value is 0.92.
                  * @public
                  */
                 saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
                 /**
                  * Flag that is set whenever Panel or any scale is resized.
                  *
                  * Will be handled before plot to update scale and trigger resize event just once per frame.
                  */
                 private _isPanelResized;
                 /**
                  * Subscribe to mouse-enter event on Chart background
                  * @public
                  */
                 onBackgroundMouseEnter(handler: MouseEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-enter event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseEnter(token: Token): boolean;
                 /**
                  * Subscribe to mouse-move event on Chart background
                  * @public
                  */
                 onBackgroundMouseMove(handler: MouseEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-move event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseMove(token: Token): boolean;
                 /**
                  * Subscribe to mouse-leave event on Chart background
                  * @public
                  */
                 onBackgroundMouseLeave(handler: MouseEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-leave event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseLeave(token: Token): boolean;
                 /**
                  * Subscribe to mouse-down event on Chart background
                  * @public
                  */
                 onBackgroundMouseDown(handler: MouseEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-down event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseDown(token: Token): boolean;
                 /**
                  * Subscribe to mouse-up event on Chart background
                  * @public
                  */
                 onBackgroundMouseUp(handler: MouseEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-up event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseUp(token: Token): boolean;
                 /**
                  * Subscribe to mouse-click event on Chart background
                  * @public
                  */
                 onBackgroundMouseClick(handler: MouseEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-click event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseClick(token: Token): boolean;
                 /**
                  * Subscribe to mouse-doubleClick event on Chart background
                  * @public
                  */
                 onBackgroundMouseDoubleClick(handler: MouseEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-doubleClick event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseDoubleClick(token: Token): boolean;
                 /**
                  * Subscribe to mouse-drag start event on Chart background
                  * @public
                  */
                 onBackgroundMouseDragStart(handler: MouseDragStartEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-dragStart event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseDragStart(token: Token): boolean;
                 /**
                  * Subscribe to mouse-drag event on Chart background
                  * @public
                  */
                 onBackgroundMouseDrag(handler: MouseDragEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-drag event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseDrag(token: Token): boolean;
                 /**
                  * Subscribe to mouse-drag stop event on Chart background
                  * @public
                  */
                 onBackgroundMouseDragStop(handler: MouseDragStopEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-dragStop event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseDragStop(token: Token): boolean;
                 /**
                  * Subscribe to mouse-wheel event on Chart background
                  * @public
                  */
                 onBackgroundMouseWheel(handler: MouseWheelEventHandler<this>): Token;
                 /**
                  * Remove subscription from mouse-wheel event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseWheel(token: Token): boolean;
                 /**
                  * Subscribe to touch-start event on Chart background
                  * @public
                  */
                 onBackgroundTouchStart(handler: TouchEventHandler<this>): Token;
                 /**
                  * Remove subscription from touch-start event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundMouseTouchStart(token: Token): boolean;
                 /**
                  * Subscribe to touch-move event on Chart background
                  * @public
                  */
                 onBackgroundTouchMove(handler: TouchEventHandler<this>): Token;
                 /**
                  * Remove subscription from touch-move event on Chart background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundTouchMove(token: Token): boolean;
                 /**
                  * Subscribe to touch-end event on Chart background
                  * @public
                  */
                 onBackgroundTouchEnd(handler: TouchEventHandler<this>): Token;
                 /**
                  * Remove subscription from touch-end event on Panel background
                  * @param token - Event listener
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offBackgroundTouchEnd(token: Token): boolean;
                 /**
                  * Subscribe to `resize` event.
                  * This event is triggered whenever the area of *chart* changes (due to document or dashboard resizing).
                  *
                  * ```typescript
                  *  // Example usage,
                  *  ChartXY.onResize((chart, width, height, engineWidth, engineHeight) => {
                  *      console.log('Chart resized', 'width', width, 'height', height, 'engineWidth', engineWidth, 'engineHeight', engineHeight)
                  *  })
                  * ```
                  *
                  * @param handler - Handler function for event
                  * @param obj - Panel itself
                  * @param width - Width of panel in pixels
                  * @param height - Height of panel in pixels
                  * @param engineWidth - Width of panels rendering engine in pixels
                  * @param engineHeight - Height of panels rendering engine in pixels
                  * @returns Token of subscription
                  * @public
                  */
                 onResize(handler: (obj: this, width: pixel, height: pixel, engineWidth: pixel, engineHeight: pixel) => void): Token;
                 /**
                  * Remove event listener from resize event.
                  * @param token - Token of event listener which has to be removed
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offResize(token: Token): boolean;
                 /**
                  * Subscribe to `inViewChange` event.
                  * This event is triggered when the chart transitions from being off-screen to being on-screen and vice versa.
                  *
                  * @param obj - Panel itself
                  * @param inView - State of panels visibility
                  * @returns Token of subscription
                  * @public
                  */
                 onInViewChange: (handler: (obj: this, inView: boolean) => void) => Token;
                 /**
                  * Remove event listener from `inViewChange` event.
                  * @param token - Token of event listener which has to be removed
                  * @returns True if the listener is successfully removed and false if it is not found
                  * @public
                  */
                 offInViewChange: (token: Token) => boolean;
                 /**
                  * Find if chart is currently considered to be in the browser viewport.
                  * @returns `true` when panel is in view
                  */
                 getIsInView(): boolean;
             }
             /**
              * _Phong_ color shading style.
              *
              * Phong shading supports ambient and specular lighting, greatly increasing depth perception
              * capabilities.
              *
              * With Phong shading enabled, the color of each pixel is affected by angle to camera, as well as the various available
              * Phong shading properties, like light colors and reflection values.
              *
              * ```js
              *  // Example syntax, use default Phong shading.
              *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong())
              * ```
              *
              * ```js
              *  // Example syntax, use Phong shading with specific configuration.
              *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong({
              *      // Add specular reflection for "highlight" effect.
              *      specularReflection: 0.5,
              *      specularColor: ColorRGBA(255, 255, 255),
              *  }))
              * ```
              *
              * Color shading style is specified with {@link Series3D.setColorShadingStyle} method.
              * @public
              */
             export declare class PhongShadingStyle implements PhongShadingStyleOptions {
                 readonly type = "phong";
                 /**
                  * Controls how much ambient light affects the color.
                  *
                  * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                  *
                  * The impact of ambient color on a surface is also affected by {@link ambientColor} property.
                  *
                  * The default value is `1.0`.
                  */
                 readonly ambientReflection: number;
                 /**
                  * Controls specular reflection strength.
                  *
                  * Describes how much the material reflects specular light.
                  *
                  * The impact of specular color on a surface is also affected by {@link shininess} and {@link specularColor} properties.
                  *
                  * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                  *
                  * The default value is `0.1`.
                  */
                 readonly specularReflection: number;
                 /**
                  * Controls how strongly the diffuse color is. Diffuse color is the color defined by user.
                  *
                  * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                  *
                  * The default value is `1.0`.
                  */
                 readonly diffuseReflection: number;
                 /**
                  * Ambient light color.
                  *
                  * Describes light that is present at all points of the surface, kind of like a _background light_.
                  *
                  * The impact of ambient color on a surface is also affected by {@link ambientReflection} property.
                  *
                  * The default setting is black.
                  *
                  * ```js
                  *  // Example, white ambient light.
                  *  ambientColor: ColorRGBA(255, 255, 255)
                  * ```
                  */
                 readonly ambientColor: Color;
                 /**
                  * Specular highlight color.
                  *
                  * Describes light that is reflected from a shiny surface.
                  * Can be used to get a "shine" effect on surfaces.
                  *
                  * The impact of specular color on a surface is also affected by {@link specularReflection} and {@link shininess} properties.
                  *
                  * The default setting is white.
                  *
                  * ```js
                  *  // Example, red specular light.
                  *  specularColor: ColorRGBA(255, 0, 0)
                  * ```
                  */
                 readonly specularColor: Color;
                 /**
                  * Specular highlight shininess.
                  *
                  * Describes how _shiny_ the material surface is.
                  *
                  * The impact of specular color on a surface is also affected by {@link specularReflection} and {@link specularColor} properties.
                  *
                  * Value ranges from 1 to 64, where higher values correspond to being _exponentially_ **less** shiny.
                  *
                  * The default value is `32`.
                  */
                 readonly shininess: number;
                 /** @public */
                 constructor(options?: Partial<PhongShadingStyleOptions> | undefined);
             }
             /**
              * Interface for configuration properties of {@link PhongShadingStyle}.
              *
              * ```js
              *  // Example syntax, use Phong shading with specific configuration.
              *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Phong({
              *      // Add specular reflection for "highlight" effect.
              *      specularReflection: 0.5,
              *      specularColor: ColorRGBA(255, 255, 255),
              *  }))
              * ```
              * @public
              */
             export declare interface PhongShadingStyleOptions {
                 /**
                  * Controls how much ambient light affects the color.
                  *
                  * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                  *
                  * The impact of ambient color on a surface is also affected by {@link ambientColor} property.
                  *
                  * The default value is `1.0`.
                  */
                 ambientReflection: number;
                 /**
                  * Controls specular reflection strength.
                  *
                  * Describes how much the material reflects specular light.
                  *
                  * The impact of specular color on a surface is also affected by {@link shininess} and {@link specularColor} properties.
                  *
                  * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                  *
                  * The default value is `0.1`.
                  */
                 specularReflection: number;
                 /**
                  * Controls how strongly the diffuse color is. Diffuse color is the color defined by user.
                  *
                  * Value ranges from 0 to 1, where higher values correspond to reflecting more.
                  *
                  * The default value is `1.0`.
                  */
                 diffuseReflection: number;
                 /**
                  * Ambient light color.
                  *
                  * Describes light that is present at all points of the surface, kind of like a _background light_.
                  *
                  * The impact of ambient color on a surface is also affected by {@link ambientReflection} property.
                  *
                  * The default setting is black.
                  *
                  * ```js
                  *  // Example, white ambient light.
                  *  ambientColor: ColorRGBA(255, 255, 255)
                  * ```
                  */
                 ambientColor: Color;
                 /**
                  * Specular highlight color.
                  *
                  * Describes light that is reflected from a shiny surface.
                  * Can be used to get a "shine" effect on surfaces.
                  *
                  * The impact of specular color on a surface is also affected by {@link specularReflection} and {@link shininess} properties.
                  *
                  * The default setting is white.
                  *
                  * ```js
                  *  // Example, red specular light.
                  *  specularColor: ColorRGBA(255, 0, 0)
                  * ```
                  */
                 specularColor: Color;
                 /**
                  * Specular highlight shininess.
                  *
                  * Describes how _shiny_ the material surface is.
                  *
                  * The impact of specular color on a surface is also affected by {@link specularReflection} and {@link specularColor} properties.
                  *
                  * Value ranges from 1 to 64, where higher values correspond to being _exponentially_ **less** shiny.
                  *
                  * The default value is `32`.
                  */
                 shininess: number;
             }
             /**
              * Class represents any kind of picture, it might be raster image rendered as texture,
              * just colored rectangle or polygon of another shape,
              * several different geometry shapes and so on.
              * @public
              */
             export declare abstract class Picture extends InternalUIElement implements Highlightable, StylableComponent {
                 /**
                  * Subscribe to highlight object event. This is called whenever an object is highlighted.
                  * @param handler - Function that is called when event is triggered.
                  * @param isHighlighted - The Highlight state.
                  * @returns Token that can be used to unsubscribe from the event.
                  * @public
                  */
                 onHighlight(handler: (obj: this, isHighlighted: boolean | number) => void): Token;
                 /**
                  * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
                  * @param token - Token that was received when subscribing to the event.
                  * @returns True if the unsubscription was successful.
                  * @public
                  */
                 offHighlight(token: Token): boolean;
                 /**
                  * Set fill style of Picture
                  * @param value - Fill style object or function which modifies it
                  * @returns Object itself for fluent interface
                  * @public
                  */
                 abstract setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                 /**
                  * Get fill style of Picture
                  * @public
                  */
                 abstract getFillStyle(): FillStyle;
                 /**
                  * @returns 1 for highlighted state of object and 0 for basic
                  * @public
                  */
                 getHighlight(): number;
                 /**
                  * Set state of component highlighting.
                  *
                  * ```ts
                  *  // Example usage
                  *
                  *  component.setHighlight(true)
                  *
                  *  component.setHighlight(0.5)
                  * ```
                  *
                  * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
                  * @returns Object itself
                  * @public
                  */
                 setHighlight(highlight: number): this;
             }
             /**
              * Abstract base class for *Pie Charts*.
              * Visualizes proportions and percentages between categories, by dividing a circle into proportional segments.
              *
              * Set data using *PieChart*.**addSlice( name: string, value: number )**
              *
              * There are multiple implementations of *PieChart*, each with their own visual design and *API* for customizing it.
              * List of selectable options can be found in: {@link PieChartTypes}
              * @public
              */
             export declare abstract class PieChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends Chart implements SlicedCharts<PieSlice>, ChartWithCursor<CursorResultTableBackgroundType> {
                 /**
                  * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
                  *
                  * **Example usage:**
                  *
                  * ```typescript
                  *  // Example 1, style AutoCursor ResultTable.
                  *  PieChart.setAutoCursor((autoCursor) => autoCursor
                  *      .setResultTable((resultTable) => resultTable
                  *          .setOrigin(UIOrigins.LeftTop)
                  *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                  *          .setTextFont((font) => font
                  *              .setSize(12)
                  *              .setFamily('sans-serif')
                  *          )
                  *          .setBackground((background) => background
                  *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
                  *          )
                  *      )
                  *  )
                  * ```
                  *
                  * ```typescript
                  *  // Example 2, style AutoCursor PointMarker.
                  *  PieChart.setAutoCursor((autoCursor) => autoCursor
                  *      .setPointMarker((marker) => marker
                  *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                  *          .setSize({ x: 10, y: 10 })
                  *          .setStrokeStyle(emptyLine),
                  *      ),
                  *  )
                  * ```
                  * @param mutator - Callback function that receives reference to the charts `AutoCursor`.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setAutoCursor(mutator: Mutator<AutoCursor<CursorResultTableBackgroundType>>): this;
                 /**
                  * Get reference to charts `AutoCursor`.
                  *
                  * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
                  *
                  * @returns `AutoCursor`.
                  * @public
                  */
                 getAutoCursor(): AutoCursor<CursorResultTableBackgroundType>;
                 /**
                  * Set chart `AutoCursor` behavior, by selecting a preset option from {@link AutoCursorModes}.
                  *
                  * Possible values:
                  * - `AutoCursorModes.snapToClosest` (default) | *AutoCursor* snaps to closest data point from mouse location.
                  * - `AutoCursorModes.onHover` | *AutoCursor* is only shown when it is directly over a *series*. NOTE: Series mouse interactions must be enabled for this to work!
                  * - `AutoCursorModes.disabled` | *AutoCursor* is disabled
                  *
                  * ```typescript
                  *  // Example, disable AutoCursor
                  *  PieChart.setAutoCursorMode(AutoCursorModes.disabled)
                  * ```
                  *
                  * **Related information:**
                  *
                  * On *series* level, *AutoCursor* behavior can be configured individually for each *series*, and there are also more *series* specific options available.
                  * Here is `LineSeries` for example:
                  *
                  * - {@link Series2D.setCursorEnabled} | configure whether cursor should pick on the series or not.
                  * - {@link SeriesXY.setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                  * - {@link LineSeries.setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
                  * - {@link SeriesXY.setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
                  *
                  * @param mode - Selection of *AutoCursor* behavior.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setAutoCursorMode(mode: AutoCursorModes): this;
                 /**
                  * Get `AutoCursor` behavior, from a collection of preset options ({@link AutoCursorModes}).
                  * @returns Active selection of *AutoCursor* behavior.
                  * @public
                  */
                 getAutoCursorMode(): AutoCursorModes;
                 /**
                  * Set *ResultTable* formatter. Can be used to specify the information that is displayed, when hovering mouse/pointer
                  * over the chart.
                  *
                  * ```ts
                  *  // Example usage
                  *  pie.setCursorResultTableFormatter((builder, chart, slice, relativeValue) => builder
                  *      .addRow(slice.getName())
                  *      .addRow(slice.getAnimatedValue().toFixed(2))
                  *  )
                  * ```
                  *
                  * @param formatter - Function which builds ResultTable content.
                  *                      See definition of {@link SlicedChartResultTableFormatter} for supplied formatting information.
                  * @returns Object itself
                  * @public
                  */
                 setCursorResultTableFormatter(formatter: SlicedChartResultTableFormatter): this;
                 /**
                  * Add new Slice to the Pie Chart.
                  * The Slice will be automatically assigned an unique style (using SliceFillStylePalette),
                  * that will not be affected by sorting of Slices.
                  *
                  * Currently there is no way to override the individual style of a Slice - style modifications must be done using the API of Pie Chart.
                  *
                  * @param name - Initial name for Slice as string.
                  * @param value - Initial value for Slice as number.
                  * @returns New Slice object.
                  * @public
                  */
                 addSlice(name: string, value: number): PieSlice;
                 /**
                  * This method is used for the adding multiple slices in the funnel chart.
                  * @param multiSlice - Array of slices
                  * @public
                  */
                 addSlices(multiSlice: {
                     name: string;
                     value: number;
                 }[]): Array<PieSlice>;
                 /**
                  * Get all Slices of Pie Chart.
                  * NOTE: Manual modifications to returned Array can have unforeseen side-effects.
                  * Removing or adding Slices is intended to be done using other APIs (PieChart.addSlice, Slice.dispose, ...)
                  * @returns Array of Slices
                  * @public
                  */
                 getSlices(): PieSlice[];
                 /**
                  * Set if it is allowed for multiple Slices to be 'exploded' at the same time or not.
                  * When a Slice is exploded, it is drawn differently from non-exploded state
                  * - usually slightly "pushed away" from the center of Pie Chart.
                  *
                  * Does not affect state of already exploded Slices!
                  * @param multipleSliceExplosionAllowed - Is behavior allowed as boolean flag
                  * @returns Pie Chart itself
                  * @public
                  */
                 setMultipleSliceExplosion(multipleSliceExplosionAllowed: boolean): this;
                 /**
                  * Get a boolean flag which implies whether it is allowed for multiple Slices to be 'exploded' at the same time or not.
                  * When a Slice is exploded, it is drawn differently from non-exploded state
                  * - usually slightly "pushed away" from the center of Pie Chart.
                  * @returns Is behavior allowed as boolean flag
                  * @public
                  */
                 getMultipleSliceExplosion(): boolean;
                 /**
                  * Set inner radius of Pie Chart.
                  * This method can be used to style the Pie Chart as a "Donut Chart", with the center being hollow.
                  * @param innerRadius - Inner radius as a percentage of outer radius [0, 100]
                  * @returns Pie Chart itself
                  * @public
                  */
                 setInnerRadius(innerRadius: number): this;
                 /**
                  * Get inner radius of Pie Chart..
                  * This property can be used to style the Pie Chart as a "Donut Chart", with the center being hollow.
                  * @returns Inner radius as a percentage of outer radius [0, 100]
                  * @public
                  */
                 getInnerRadius(): number;
                 /**
                  * Set offset of exploded Slices in pixels.
                  * @param sliceExplosionOffset - Offset of exploded Slices in pixels
                  * @returns Pie Chart itself
                  * @public
                  */
                 setSliceExplosionOffset(sliceExplosionOffset: pixel): this;
                 /**
                  * Get offset of exploded Slices in pixels.
                  * @returns Offset of exploded Slices in pixels
                  * @public
                  */
                 getSliceExplosionOffset(): pixel;
                 /**
                  * Attach lookup table (LUT) to fill the slices with Colors based on value.
                  *
                  * The color for the slice would be selected from a specified *LUT*, which contains the information about gradient steps.
                  * After setting LUT to undefined all the slices stay colorized, but no further lookup.
                  *
                  * LUT class stores information about values and its associated colors,
                  * * which provides efficient lookup of the color based on provided value
                  * * as well as linear and step interpolation between colors.
                  *
                  * ``` javascript
                  * const pie = lightningChart()
                  *  .Pie( { type: PieChartTypes.LabelsOnSides } )
                  *  .setLUT( new LUT (steps: [
                  *          { value: 10, color: ColorRGBA( 0, 0, 0 ) },
                  *          { value: 20, color: ColorRGBA( 30, 255, 0 ) },
                  *          { value: 30, color: ColorRGBA( 60, 204, 0 ) },
                  *          { value: 40, color: ColorRGBA( 90, 128, 0 ) },
                  *          { value: 50, color: ColorRGBA( 255, 0, 0 ) } ) ],
                  *      interpolate: true } )
                  * ```
                  *
                  * @param lut - Lookup table
                  * @returns Pie itself for fluent interface
                  * @public
                  */
                 setLUT(lut?: LUT): this;
                 /**
                  * Set style of Pie Slices fill.
                  * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pie will be assigned an incremental index,
                  * which will be used to pick its fill style from this Palette.
                  *
                  * So, for example... We have a Pie Chart with 5 Slices, and we give it a Palette with only 3 possible values
                  * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                  * Note that this means, that the supplied Palette will have to work in a continuous manner!
                  *
                  * @param sliceFillStylePalette - Palette for FillStyle objects
                  * @returns Pie Chart itself
                  * @public
                  */
                 setSliceFillStyle(sliceFillStylePalette: Palette<FillStyle>): this;
                 /**
                  * Get style of Pie Slices fill.
                  * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pie will be assigned an incremental index,
                  * which will be used to pick its fill style from this Palette.
                  *
                  * So, for example... We have a Pie Chart with 5 Slices, and we give it a Palette with only 3 possible values
                  * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                  * Note that this means, that the supplied Palette will have to work in a continuous manner!
                  *
                  * @returns Palette<FillStyle>
                  * @public
                  */
                 getSliceFillStyle(): Palette<FillStyle>;
                 /**
                  * Set stroke style of Pie Slices border.
                  * @param value - LineStyle object or function which creates a new style based on previous
                  * @returns Pie Chart itself
                  * @public
                  */
                 setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                 /**
                  * Get stroke style of Pie Slices border.
                  * @returns LineStyle object
                  * @public
                  */
                 getSliceStrokeStyle(): LineStyle;
                 /**
                  * Set theme effect enabled on component or disabled.
                  *
                  * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                  * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                  *
                  * ```ts
                  *  // Example, disable theme effect from a particular component.
                  *  Component.setEffect(false)
                  * ```
                  *
                  * For the most part, theme effects are **enabled** by default on most components.
                  *
                  * Theme effect is configured with {@link Theme.effect} property.
                  *
                  * @param enabled - Theme effect enabled
                  * @returns          Object itself.
                  * @public
                  */
                 setSliceEffect(enabled: boolean): this;
                 /**
                  * Get theme effect enabled on component or disabled.
                  *
                  * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                  * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                  *
                  * ```ts
                  *  // Example, disable theme effect from a particular component.
                  *  Component.setEffect(false)
                  * ```
                  *
                  * For the most part, theme effects are **enabled** by default on most components.
                  *
                  * Theme effect is configured with {@link Theme.effect} property.
                  *
                  * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                  * @public
                  */
                 getSliceEffect(): boolean;
                 /**
                  * Set sorter of Pies' Slices as a comparator-function.
                  *
                  * For some commonly needed default implementations, can refer to PieSliceSorters-collection.
                  * @param sliceSorter - PieSliceSorter - function which sorts Slices of Pie with JavaScript API: Array.sort.
                  * @returns Pie Chart itself
                  * @public
                  */
                 setSliceSorter(sliceSorter: SliceSorter<PieSlice>): this;
                 /**
                  * Get sorter of Pies' Slices as a comparator-function.
                  * @returns PieSliceSorter - function which sorts Slices of Pie with JavaScript API: Array.sort.
                  * @public
                  */
                 getSliceSorter(): SliceSorter<PieSlice>;
                 /**
                  * Set fill style of Pie Slices Labels.
                  * @param value - FillStyle object or function which creates a new style based on previous
                  * @returns Pie Chart itself
                  * @public
                  */
                 setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                 /**
                  * Get fill style of Pie Slice Labels.
                  * @returns FillStyle object
                  * @public
                  */
                 getLabelFillStyle(): FillStyle;
                 /**
                  * Set font of Slice Labels.
                  * @param value - FontSettings or mutator function for existing settings
                  * @returns Pie Chart itself
                  * @public
                  */
                 setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                 /**
                  * Get font of Slice Labels.
                  * @returns FontSettings
                  * @public
                  */
                 getLabelFont(): FontSettings;
                 /**
                  * Set theme effect enabled on component or disabled.
                  *
                  * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                  * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                  *
                  * ```ts
                  *  // Example, disable theme effect from a particular component.
                  *  Component.setEffect(false)
                  * ```
                  *
                  * For the most part, theme effects are **enabled** by default on most components.
                  *
                  * Theme effect is configured with {@link Theme.effect} property.
                  *
                  * @param enabled - Theme effect enabled
                  * @returns          Object itself.
                  * @public
                  */
                 setLabelEffect(enabled: boolean): this;
                 /**
                  * Get theme effect enabled on component or disabled.
                  *
                  * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                  * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                  *
                  * ```ts
                  *  // Example, disable theme effect from a particular component.
                  *  Component.setEffect(false)
                  * ```
                  *
                  * For the most part, theme effects are **enabled** by default on most components.
                  *
                  * Theme effect is configured with {@link Theme.effect} property.
                  *
                  * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                  * @public
                  */
                 getLabelEffect(): boolean;
                 /**
                  * Set formatter of Slice Labels.
                  *
                  * See {@link SliceLabelFormatters} for a collection of default options.
                  * @param labelFormatter - SliceLabelFormatter - function which generates text of Labels per Slice.
                  * @returns Pie Chart itself
                  * @public
                  */
                 setLabelFormatter(labelFormatter: SliceLabelFormatter<PieSlice>): this;
                 /**
                  * Get formatter of Slice Labels.
                  * @returns SliceLabelFormatter - function which generates text of Labels per Slice.
                  * @public
                  */
                 getLabelFormatter(): SliceLabelFormatter<PieSlice>;
                 /**
                  * Set if slices should be highlighted on mouse hover / touch. Applies to all Slices.
                  * @param state - True if Slices should be highlighted on hover, false if not. This applies to all existing Slices and new Slices added.
                  * @public
                  */
                 setSliceHighlightOnHover(state: boolean): this;
                 /**
                  * **Permanently** destroy the component.
                  *
                  * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                  * **to the component and its children** in application code.
                  * ```javascript
                  * let chart = ...ChartXY()
                  * let axisX = chart.getDefaultAxisX()
                  * // Dispose Chart, and remove all references so that they can be garbage-collected.
                  * chart.dispose()
                  * chart = undefined
                  * axisX = undefined
                  * ```
                  * @returns Object itself for fluent interface
                  */
                 dispose(): this;
             }
             /**
              * Interface for readonly configuration of {@link PieChart}.
              *
              * Some properties of `PieChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
              *
              * ```typescript
              *  // Example, create chart with specified color theme.
              *  const chart = LightningChart.Pie({
              *      theme: Themes.light,
              *  })
              * ```
              *
              * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
              *
              * For *standalone* `PieChart`, more parameters are documented in {@link LightningChart.Pie}.
              *
              * For *dashboard* `PieChart`, more parameters are documented in {@link Dashboard.createPieChart}.
              *
              *
              * **Commonly used properties:**
              *
              * - {@link PieChartOptions.type}: Specify pie chart visual design from a collection of options.
              * - {@link PieChartOptions.theme}: Specify chart color *theme*.
              * - {@link PieChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
              *
              * **Example usage:**
              *
              * ```typescript
              *  // Example 1, create chart with default configuration.
              *  const chart = LightningChart.Pie({})
              * ```
              *
              * ```typescript
              *  // Example 2, create pie chart with labels inside slices.
              *  const chart = LightningChart.Pie({
              *      type: PieChartTypes.LabelsInsideSlices
              *  })
              * ```
              *
              * ```typescript
              *  // Example 3, create chart with specified color theme.
              *  const chart = LightningChart.Pie({
              *      theme: Themes.light,
              *  })
              * ```
              * @public
              */
             export declare interface PieChartOptions<PieChartType extends PieChartTypes = PieChartTypes, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                 /**
                  * Specify pie chart visual design from a collection of options.
                  *
                  * Options are located in {@link PieChartTypes} collection. If undefined, will default to `PieChartTypes.LabelsOnSides`.
                  */
                 type?: PieChartType;
                 /**
                  * Builder for the charts' *auto cursor*.
                  *
                  * For most use cases, it is not recommended to use this, but rather {@link PieChart.setAutoCursor} for a more convenient API.
                  * @public
                  */
                 readonly autoCursorBuilder?: AutoCursor2DBuilder<CursorResultTableBackgroundType>;
             }
             /**
              * Collection of {@link PieChart} implementations. Each option can have their own visual design, and *API* for customization of it.
              *
              * This must be specified when the {@link PieChart} is created (or default one will be used).
              *
              * Example usage:
              *```javascript
              * // Create a PieChart with specified type
              * LightningChart.Pie({ type: PieChartTypes.LabelsInsideSlices })
              * ```
              * @public
              */
             export declare const PieChartTypes: {
                 /**
                  * Pie Chart type, where Slice Labels are positioned on the left and right sides of Chart.
                  * Labels are connected to their Slices with lines, which can be styled using unique API for this Pie Chart type.
                  */
                 LabelsOnSides: typeof PieChartWithLabelsOnSides;
                 /**
                  * Pie Chart type, where Slice Labels inside the Slices.
                  * Works well when Label texts are short and there are not a lot of Slices, as the actual Pie has more space.
                  */
                 LabelsInsideSlices: typeof PieChartWithLabelsInsideSlices;
             };
             /**
              * @public
              */
             export declare type PieChartTypes = typeof PieChartTypes[keyof typeof PieChartTypes];
             /**
              * {@link PieChart} implementation that draws Slice Labels inside the Slices.
              * Works well when Label texts are short and there are not a lot of Slices, as the actual Pie has more space.
              * Public class
              * @public
              */
             export declare class PieChartWithLabelsInsideSlices extends PieChart {
                 /**
                  * Get minimum size of Panel.
                  * Depending on the type of class this value might be automatically computed to fit different elements.
                  * @returns Vec2 minimum size or undefined if unimplemented
                  * @public
                  */
                 getMinimumSize(): Point | undefined;
                 /**
                  * Set position of Labels.
                  * @param labelPositionInsideSlice - Position of labels inside their respective Slices as a number between [0, 1]
                  * @returns Pie Chart itself
                  * @public
                  */
                 setLabelPosition(labelPositionInsideSlice: number): this;
                 /**
                  * Get position of Labels.
                  * @returns Position of labels inside their respective Slices as a number between [0, 1]
                  * @public
                  */
                 getLabelPosition(): number;
             }
             /**
              * {@link PieChart} implementation that draws Slice Labels on its left and right sides.
              * Slices and Labels are connected by 'label connector lines'.
              * @public
              */
             export declare class PieChartWithLabelsOnSides extends PieChart {
                 /**
                  * Set style of Label connector lines.
                  * @param labelConnectorStyle - LineStyle object
                  * @returns Pie Chart itself
                  * @public
                  */
                 setLabelConnectorStyle(labelConnectorStyle: LineStyle): this;
                 /**
                  * Get style of Label connector lines.
                  * @returns LineStyle object
                  * @public
                  */
                 getLabelConnectorStyle(): LineStyle;
                 /**
                  * Set distance between slice and label (includes explosion offset), this points to reference position of label, so not necessarily the nearest corner
                  * @param labelSliceOffset - Length as pixels
                  * @returns Pie Chart itself
                  * @public
                  */
                 setLabelSliceOffset(labelSliceOffset: pixel): this;
                 /**
                  * Get distance between slice and label (includes explosion offset), this points to reference position of label, so not necessarily the nearest corner
                  * @returns Length as pixels
                  * @public
                  */
                 getLabelSliceOffset(): number;
                 /**
                  * Set gap between slice and connector line start
                  * @param labelConnectorGapStart - Gap as pixels
                  * @returns Pie Chart itself
                  * @public
                  */
                 setLabelConnectorGapStart(labelConnectorGapStart: pixel): this;
                 /**
                  * Get labelConnectorGapStart
                  * @returns Gap as pixels
                  * @public
                  */
                 getLabelConnectorGapStart(): number;
                 /**
                  * Set horizontal length of connector line before connecting to label
                  * @param labelConnectorGapStart - Pixels
                  * @returns Pie Chart itself
                  * @public
                  */
                 setLabelConnectorEndLength(labelConnectorEndLength: pixel): this;
                 /**
                  * Get horizontal length of connector line before connecting to label
                  * @returns Pixels
                  * @public
                  */
                 getLabelConnectorEndLength(): number;
                 /**
                  * Get minimum size of Panel.
                  * Depending on the type of class this value might be automatically computed to fit different elements.
                  * @returns Vec2 minimum size or undefined if unimplemented
                  * @public
                  */
                 getMinimumSize(): Point | undefined;
             }
             /**
              * Interface that can be used to define {@link PieChart}configurations, when inside a {@link Dashboard}, that can't be changed after creation.
              *
              *  Example usage:
              *```javascript
              * // Pie Chart with default type
              * undefined
              * // Pie Chart* with specified type
              * { pieChartOptions: { type: PieChartTypes.PieChartWithLabelsOnSides } }
              * ```
              * @public
              */
             export declare interface PieOptions<PieChartType extends PieChartTypes> extends DashboardCellOptions, PieChartOptions<PieChartType> {
             }
             /**
              * Abstract class represents a Pie & Donut specific slice API.
              * @public
              */
             export declare abstract class PieSlice extends Slice {
                 /**
                  * Set is Slice exploded.
                  * When a Slice is exploded, it is drawn differently from non-exploded state
                  * - usually slightly "pushed away" from the center of Pie Chart.
                  * @param exploded - State of explosion as boolean
                  * @returns Slice itself
                  * @public
                  */
                 abstract setExploded(exploded: boolean): this;
                 /**
                  * Get is Slice exploded.
                  * When a Slice is exploded, it is drawn differently from non-exploded state
                  * - usually slightly "pushed away" from the center of Pie Chart.
                  * @returns State of explosion as boolean
                  * @public
                  */
                 abstract getExploded(): boolean;
             }
             /**
              * Decoration for normal number. Indicates that the value should be interpreted as amount of pixels.
              * @public
              */
             export declare type pixel = number;
             /**
              * A style class used to specify style of 3D points rendering as pixelated squares.
              *
              * This rendering style is optimal for rendering large numbers of points that do not require great individual detail.
              * @public
              */
             export declare class PixelatedPoints3D extends PixelatedPoints3DRecord {
                 /**
                  * When creating a new PixelatedPoints3D object, any amount of its default parameters can be *overriden*, by supplying the
                  * values to its constructor:
                  * ```javascript
                  *  new PointStyle3D.Pixelated({
                  *      size: 4,
                  *      fillStyle: new SolidFill({ color: ColorHex('#FFF') }),
                  *  })
                  * ```
                  * @param props - Optional object containing any amount of parameters of PixelatedPoints3D
                  * @public
                  */
                 constructor(props?: Partial<PixelatedPoints3DProperties>);
                 /**
                  * Construct a new PixelatedPoints3D object based on this one, but with different size.
                  *
                  * @param size - Size of the rendered points in **pixels**.
                  * @returns New PixelatedPoints3D object
                  * @public
                  */
                 setSize(size: number): this;
                 /**
                  * Get size of points rendered with this style object.
                  * @returns Size of the rendered points in **pixels**.
                  * @public
                  */
                 getSize(): number;
                 /**
                  * Construct a new PixelatedPoints3D object based on this one, but with modified fill style.
                  *
                  * Example usage:
                  *
                  * | Desired result         | Argument                                      |
                  * | :--------------------- | :-------------------------------------------- |
                  * | Specified SolidFill    | new SolidFill(\{ color: ColorHex('#F00') \})    |
                  *
                  * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                  * @returns New PixelatedPoints3D object
                  * @public
                  */
                 setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                 /**
                  * Get fill style of PixelatedPoints3D.
                  * @returns FillStyle object
                  * @public
                  */
                 getFillStyle(): FillStyle;
             }
             /**
              * Interface for all properties of a PixelatedPoints3DProperties.
              * @public
              */
             export declare interface PixelatedPoints3DProperties {
                 type: 'pixelated-points-3d';
                 /**
                  * Size of the rendered points in **pixels**.
                  *
                  * Some devices / browser configurations always render with 1 pixel, regardless of this setting.
                  */
                 size: number;
                 /**
                  * *FillStyle* for rendering the points.
                  */
                 fillStyle: FillStyle;
             }
             /**
              * Record contractor for PixelatedPoints3DProperties.
              * @public
              */
             declare const PixelatedPoints3DRecord: Record_2.Factory<PixelatedPoints3DProperties>;
             /**
              * Interface for object that can be rendered as part of UI.
              * @public
              */
             declare interface Plotable {
             }
             /**
              * Interface for a immutable data-structure which represents a data point in XY charts.
              * @public
              */
             export declare interface Point {
                 /**
                  * Location in X-dimension.
                  */
                 readonly x: number;
                 /**
                  * Location in Y-dimension.
                  */
                 readonly y: number;
             }
             /**
              * Interface for a data-structure which represents a 3-dimensional location.
              *
              * **Required properties:**
              *
              * - {@link Point3D.x} | coordinate along X Axis.
              * - {@link Point3D.y} | coordinate along Y Axis.
              * - {@link Point3D.z} | coordinate along Z Axis.
              *
              * **Optional properties:**
              *
              * - {@link Point3D.color} | data point color.
              * - {@link Point3D.size} | data point size.
              * - {@link Point3D.value} | data point value for dynamic coloring.
              *
              * ```ts
              *  // Example syntax,
              *  PointSeries3D.add([
              *      {
              *          x: 0,
              *          y: 0,
              *          z: 0,
              *          // `color` can be used for individual point coloring.
              *          color: ColorRGBA(255, 0, 0),
              *          // `size` can be used for individual point sizing.
              *          size: 5.0,
              *          // `value` can be used for dynamic point coloring.
              *          value: 160.0,
              *      }
              *  ])
              * ```
              * @public
              */
             export declare interface Point3D {
                 /**
                  * Location in X-dimension.
                  */
                 readonly x: number;
                 /**
                  * Location in Y-dimension.
                  */
                 readonly y: number;
                 /**
                  * Location in Z-dimension.
                  */
                 readonly z: number;
                 /**
                  * Optional Color associated with the data point.
                  *
                  * Can be used for individual data point coloring when styled with {@link IndividualPointFill}.
                  *
                  * For some series types, individual data point coloring might have to be explicitly enabled when the series is created.
                  * Refer to series documentation for more detailed information.
                  */
                 readonly color?: Color;
                 /**
                  * Optional Size associated with the data point.
                  *
                  * Can be used for individual configuration of data points size.
                  *
                  * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                  * Refer to series documentation for more detailed information.
                  */
                 readonly size?: number;
                 /**
                  * Optional Value associated with the data point.
                  *
                  * Can be used for dynamic per data point coloring when associated with a Color lookup table {@link LUT}.
                  *
                  * For some series types, dynamic data point coloring might have to be explicitly enabled when the series is created.
                  * Refer to series documentation for more detailed information.
                  */
                 readonly value?: number;
                 /**
                  * Optional Size on X Axis associated with the data point.
                  *
                  * Can be used for individual configuration of data points size along Axis dimensions.
                  *
                  * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                  * Refer to series documentation for more detailed information.
                  */
                 readonly sizeAxisX?: number;
                 /**
                  * Optional Size on Y Axis associated with the data point.
                  *
                  * Can be used for individual configuration of data points size along Axis dimensions.
                  *
                  * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                  * Refer to series documentation for more detailed information.
                  */
                 readonly sizeAxisY?: number;
                 /**
                  * Optional Size on Z Axis associated with the data point.
                  *
                  * Can be used for individual configuration of data points size along Axis dimensions.
                  *
                  * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                  * Refer to series documentation for more detailed information.
                  */
                 readonly sizeAxisZ?: number;
             }
             /**
              * Interface for UI elements used for CustomTick Markers.
              *
              * A Pointable has two components: a label and a pointer.
              * @public
              */
             export declare interface Pointable {
                 /**
                  * NOTE: Internal method, usage is not encouraged.
                  * @public
                  */
                 setDirection(direction: UIDirections): this;
                 /**
                  * NOTE: Internal method, usage is not encouraged.
                  * @public
                  */
                 getDirection(): UIDirections;
                 /**
                  * NOTE: Usage is not encouraged, please use {@link CustomTick.setTickLength}
                  * @public
                  */
                 setPointerLength(length: pixel): this;
                 /**
                  * NOTE: Usage is not encouraged, please use {@link CustomTick.getTickLength}
                  * @public
                  */
                 getPointerLength(): pixel;
                 /**
                  * NOTE: Usage is not encouraged, please use {@link CustomTick.setTickLabelPadding}
                  * @public
                  */
                 setTickLabelPadding(margin: pixel): this;
                 /**
                  * NOTE: Usage is not encouraged, please use {@link CustomTick.getTickLabelPadding}
                  * @public
                  */
                 getTickLabelPadding(): pixel;
             }
             /**
              * Background that can be pointed at a direction (left,right,up or down)
              * @public
              */
             export declare interface PointableBackground extends Pointable, UIBackground {
             }
             /**
              * Type of Pointable Background constructor
              * @public
              */
             declare type PointableBackgroundConstructor<T extends InternalBackground & PointableBackground = InternalBackground & PointableBackground> = new (layer: unknown, renderingScale: unknown, scale: unknown, remove: unknown, theme: unknown) => T;
             /**
              * Series type for visualizing a collection of `{ x, y, z }` coordinates by different **2D markers**.
              *
              * `PointCloudSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
              *
              * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
              * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
              *
              * **Creating PointCloudSeries3D:**
              *
              * `PointCloudSeries3D` are created with {@link Chart3D.addPointSeries} method.
              *
              * Some properties of `PointCloudSeries3D` can only be configured when it is created. These arguments are all optional,
              * and are wrapped in a single object parameter:
              *
              * ```typescript
              *  // Example,
              *  const pointCloudSeries3D = Chart3D.addPointSeries({
              *      // Specify point series type as point cloud.
              *      type: PointSeriesTypes3D.Pixelated
              *  })
              * ```
              *
              * To learn about available properties, refer to {@link PointSeriesOptions3D}.
              *
              * **Frequently used methods:**
              *
              * - Append data points to series | {@link add}
              * - Remove all data points from series | {@link clear}
              * - Configure style of points | {@link setPointStyle}
              * - Destroy series permanently | {@link dispose}
              *
              * **Related information:**
              *
              * There is another series type for visualizing large sets of 3D coordinates with markers: {@link PointSeries3D}
              *
              * `PointSeries3D` works otherwise same, except that it renders markers with 3D geometry, with a collection of different shape options,
              * like 3D boxes or spheres. For this reason, `PointCloudSeries3D` is significantly faster than `PointSeries3D`!
              *
              * The main difference between `PointSeries3D` and `PointCloudSeries3D` is that `PointCloudSeries3D` don't have *depth*,
              * so they have same size regardless of how far they are from the camera.
              * @public
              */
             export declare class PointCloudSeries3D extends AbstractPointSeries3D<PixelatedPoints3D> implements AttachableWithLUT {
                 /**
                  * Set point style of Series.
                  *
                  * **Example syntax:**
                  *
                  * ```ts
                  *  // Example syntax, Specify new style
                  *  pointCloudSeries3D.setPointStyle( new PointStyle3D.Pixelated({
                  *      size: 10,
                  *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
                  *  }) )
                  * ```
                  *
                  * ```ts
                  *  // Example syntax, Change point color
                  *  pointCloudSeries3D.setPointStyle( (pointStyle) => pointStyle
                  *      .setFillStyle( new SolidFill({ color: ColorHEX('#FFF') }) )
                  *  )
                  * ```
                  *
                  * ```ts
                  *  // Example syntax, Change point size
                  *  pointCloudSeries3D.setPointStyle( (pointStyle) => pointStyle
                  *      .setSize( 10 )
                  *  )
                  * ```
                  *
                  * **Point coloring:**
                  *
                  * Color of points is configured by the `fillStyle` property of active point style.
                  *
                  * Here is a list of all supported _fill styles_ with feature descriptions and example syntax:
                  *
                  * {@link SolidFill}:
                  *
                  * Solid color for all points in series.
                  *
                  * ```js
                  *  // Example syntax, solid points color.
                  *  pointCloudSeries3D.setPointStyle(new PointStyle3D.Pixelated({
                  *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }),
                  *      size: 10
                  *  }))
                  * ```
                  *
                  * {@link PalettedFill}:
                  *
                  * Look-up dynamic per-point color based on a _look up property_ (number) and a color look up table ({@link LUT}).
                  *
                  * ```js
                  *  // Example syntax, dynamic points color.
                  *  pointCloudSeries3D.setPointStyle(new PointStyle3D.Pixelated({
                  *      fillStyle: new PalettedFill({
                  *          // lookUpProperty defines basis of selecting look up value (number).
                  *          lookUpProperty: 'value',
                  *          // lut defines table for mapping look up value (number) to a color.
                  *          lut: new LUT({
                  *              interpolate: true,
                  *              steps: [
                  *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                  *                  { value: 1, color: ColorRGBA(255, 0, 0) }
                  *              ]
                  *          })
                  *      }),
                  *      size: 10
                  *  }))
                  * ```
                  *
                  * `pointCloudSeries3D` supports several different look-up modes:
                  *
                  * `lookUpProperty: 'value'`:
                  *
                  * **IMPORTANT:** In order to use `value` property on data points, the feature has to be explicitly activated **when the series is created**:
                  *
                  * ```js
                  *  // Example syntax, enable individual data point values.
                  *  const pointCloudSeries3D = chart3D.addPointSeries({
                  *      type: PointSeriesTypes3D.Pixelated,
                  *      individualLookupValuesEnabled: true
                  *  })
                  * ```
                  *
                  * `value` property is then added for every data point along side `x`, `y` and `z`:
                  *
                  * ```js
                  *  // Example syntax, individual data point values.
                  *  pointCloudSeries3D.add([
                  *      { x: 0, y: 0, z: 0, value: 0 },
                  *      { x: 1, y: 0, z: 2, value: 1 },
                  *  ])
                  * ```
                  *
                  * Look-up value is read from data point `value` property.
                  *
                  * `lookUpProperty: 'x'`:
                  *
                  * Look-up value is set to data point `x` coordinate on Axis.
                  *
                  * `lookUpProperty: 'y'`:
                  *
                  * Look-up value is set to data point `y` coordinate on Axis.
                  *
                  * `lookUpProperty: 'z'`:
                  *
                  * Look-up value is set to data point `z` coordinate on Axis.
                  *
                  * {@link IndividualPointFill}:
                  *
                  * Supply individual color for each data point.
                  *
                  * **IMPORTANT:** In order to use `IndividualPointFill`, the feature has to be explicitly activated **when the series is created**:
                  *
                  * ```js
                  *  // Example syntax, enable individual data point colors.
                  *  const pointCloudSeries3D = chart3D.addPointSeries({
                  *      type: PointSeriesTypes3D.Pixelated,
                  *      individualPointColorEnabled: true
                  *  })
                  * ```
                  *
                  * `color` property is then added for every data point along side `x`, `y` and `z`:
                  *
                  * ```js
                  *  // Example syntax, individual data point colors.
                  *  pointCloudSeries3D.add([
                  *      { x: 0, y: 0, z: 0, color: ColorRGBA(255, 0, 0) },
                  *      { x: 1, y: 0, z: 2, color: ColorRGBA(0, 255, 0) },
                  *  ])
                  * ```
                  *
                  * **Point size:**
                  *
                  * Size of points is configured by the `size` property of active point style.
                  *
                  * If required, points can also be individually sized by adding a `size` property to data points.
                  *
                  * **IMPORTANT:** In order to use `size` property, the feature has to be explicitly activated **when the series is created**:
                  *
                  * ```js
                  *  // Example syntax, enable individual data point size.
                  *  const pointCloudSeries3D = chart3D.addPointSeries({
                  *      type: PointSeriesTypes3D.Pixelated,
                  *      individualPointSizeEnabled: true
                  *  })
                  * ```
                  *
                  * `size` property is then added for every data point along side `x`, `y` and `z`:
                  *
                  * ```js
                  *  // Example syntax, individual data point sizes.
                  *  pointCloudSeries3D.add([
                  *      { x: 0, y: 0, z: 0, size: 5 },
                  *      { x: 1, y: 0, z: 2, size: 10 },
                  *  ])
                  * ```
                  *
                  * @param value - A PixelatedPoints3D object, or a function which modifies the current style.
                  * @returns Object itself for fluent interface
                  * @public
                  */
                 setPointStyle(value: PixelatedPoints3D | ImmutableMutator<PixelatedPoints3D>): this;
                 /**
                  * Get normal points style.
                  * @returns PixelatedPoints3D
                  * @public
                  */
                 getPointStyle(): PixelatedPoints3D;
             }
             /**
              * Interface for a series which contains points
              * @public
              */
             export declare interface Pointed {
                 /**
                  * Set point fill style
                  * @param pointColor - FillStyle for points or mutator to modify existing one
                  * @returns Series object (self)
                  * @public
                  */
                 setPointFillStyle: (pointColor: FillStyle | ImmutableMutator<FillStyle>) => this;
                 /**
                  * @returns Current point fill style
                  * @public
                  */
                 getPointFillStyle: () => FillStyle;
                 /**
                  * Set size of point in pixels
                  * @param size - Size of point in pixels
                  * @returns Object itself for fluent interface
                  * @public
                  */
                 setPointSize(size: number): this;
                 /**
                  * @returns Size of point in pixels
                  * @public
                  */
                 getPointSize(): number;
                 /**
                  * Get shape of points.
                  *
                  * This is defined upon creation of Series, and cannot be changed afterwards.
                  * @public
                  * @returns Shape of points
                  */
                 getPointShape(): PointShape;
                 /**
                  * Set the rotation of points.
                  * @param angle - Rotation angle in degrees
                  * @public
                  */
                 setPointRotation(angle: number): this;
                 /**
                  * Get the current rotation of points.
                  * @public
                  */
                 getPointRotation(): number;
             }
             /**
              * Implementation of *SeriesXY* for visualizing a collection of *Points* with a specifiable {@link PointShape}
              * and connected lines.
              *
              * *PointLineSeries* are created with {@link ChartXY.addPointLineSeries}
              * @public
              */
             export declare class PointLineSeries extends BasicSeries<Point, LinearScaleXY> implements Lined, Pointed, IndividualPointed {
                 /**
                  * Append a single `XY` coordinate or list of `XY` coordinates into the *series*.
                  *
                  * ```ts
                  *  // Example syntax
                  *  LineSeries.add({ x: 0, y: 100 })
                  *
                  *  LineSeries.add([
                  *      { x: 0, y: 100 },
                  *      { x: 10, y: 50 },
                  *      { x: 20, y: 75 },
                  *  ])
                  * ```
                  *
                  * Point series also allow a set of extra properties that can be supplied for each data point:
                  *
                  * - `color`    | Associate data point with a color. Can be used for individual point coloring, when point fill style is {@link IndividualPointFill}.
                  * - `size`     | Associate data point with a size. Can be used for individual point size. Must be enabled with {@link setIndividualPointSizeEnabled}.
                  * - `rotation` | Associate data point with a rotation. Can be used for individual point rotation. Must be enabled with {@link setIndividualPointRotationEnabled}.
                  * - `value`    | Associate data point with a value. Can be used for paletted point coloring. Must be enabled with {@link setIndividualPointValueEnabled}.
                  *
                  * ```ts
                  *  PointLineSeries
                  *      .setIndividualPointSizeEnabled(true)
                  *      .setIndividualPointRotationEnabled(true)
                  *      .setIndividualPointValueEnabled(true)
                  *      .add({
                  *          x: 0,
                  *          y: 0,
                  *          color: ColorRGBA(255, 0, 0),
                  *          size: 10,
                  *          rotation: 45,
                  *          value: 62.5
                  *      })
                  * ```
                  *
                  * For more methods of appending data into series, see:
                  *
                  * - {@link addArrayY} | Append only Y coordinates.
                  * - {@link addArrayX} | Append only X coordinates.
                  * - {@link addArraysXY} | Append X and Y coordinates in separate arrays.
                  *
                  * @param points - Single XY coordinate or list of coordinates.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 add(points: PointSeriesDataPoint | Array<PointSeriesDataPoint>): this;
                 /**
                  * Set stroke style of Series.
                  *
                  * Supported line styles:
                  * - {@link SolidLine}
                  * - {@link DashedLine}
                  * - {@link emptyLine}
                  *
                  * ```ts
                  *  // Example syntax, specify LineStyle
                  *  LineSeries.setStrokeStyle(new SolidLine({
                  *      thickness: 2,
                  *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
                  *  }))
                  * ```
                  *
                  * ```ts
                  *  // Example syntax, change active LineStyle
                  *  LineSeries.setStrokeStyle((stroke) => stroke.setThickness(5))
                  * ```
                  *
                  * Use `-1` thickness to enable primitive line rendering.
                  * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
                  * ```typescript
                  *  LineSeries.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
                  * ```
                  *
                  * **Supported fill styles:**
                  *
                  * {@link SolidFill}:
                  *
                  * Solid color for entire line series.
                  *
                  * ```ts
                  *  // Example, solid colored line.
                  *  LineSeries.setStrokeStyle(new SolidLine({
                  *      thickness: 2,
                  *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                  *  }))
                  * ```
                  *
                  * To learn more about available *Color* factories, see {@link ColorRGBA}
                  *
                  * {@link PalettedFill}:
                  *
                  * Color line stroke dynamically based on `x` or `y` coordinate.
                  *
                  * ```ts
                  *  // Example, dynamic color by Y coordinates
                  *  LineSeries.setStrokeStyle(new SolidLine({
                  *      thickness: 2,
                  *      fillStyle: new PalettedFill({
                  *          lookUpProperty: 'y',
                  *          lut: new LUT({
                  *              interpolate: true,
                  *              steps: [
                  *                  { value: 0, color: ColorRGBA(255, 0, 0) },
                  *                  { value: 100, color: ColorRGBA(0, 255, 0) },
                  *              ]
                  *          })
                  *      })
                  *  }))
                  * ```
                  *
                  * To learn more about Color lookup tables, see {@link LUT}.
                  *
                  * {@link LinearGradientFill}:
                  *
                  * Color line stroke with a linear configurable gradient palette.
                  *
                  * ```ts
                  *  // Example, linear gradient line color
                  *  LineSeries.setStrokeStyle(new SolidLine({
                  *      thickness: 2,
                  *      fillStyle: new LinearGradientFill()
                  *  }))
                  * ```
                  *
                  * To learn more about linear gradient configurations, see {@link LinearGradientFill}.
                  *
                  * {@link RadialGradientFill}:
                  *
                  * Color line stroke with a radial configurable gradient palette.
                  *
                  * ```ts
                  *  // Example, radial gradient line color
                  *  LineSeries.setStrokeStyle(new SolidLine({
                  *      thickness: 2,
                  *      fillStyle: new RadialGradientFill()
                  *  }))
                  * ```
                  *
                  * To learn more about radial gradient configurations, see {@link RadialGradientFill}.
                  *
                  * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                 /**
                  * Get stroke style of Series.
                  * @returns SolidLine object
                  * @public
                  */
                 getStrokeStyle(): LineStyle;
                 /**
                  * Set point fill style of Series.
                  * Use {@link IndividualPointFill} to enable individual coloring of points.
                  *
                  * Example usage:
                  *```javascript
                  * // Create a new style
                  * PointLineSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                  * // Change transparency
                  * PointLineSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
                  * // Set hidden
                  * PointLineSeries.setPointFillStyle(emptyFill)
                  * ```
                  * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                  * @returns Series itself for fluent interface.
                  * @public
                  */
                 setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                 /**
                  * Get normal points fill style.
                  * @returns Normal point fill style.
                  * @public
                  */
                 getPointFillStyle(): FillStyle;
                 /**
                  * Set size of point in pixels
                  * @param size - Size of point in pixels
                  * @returns Object itself for fluent interface
                  * @public
                  */
                 setPointSize(size: number): this;
                 /**
                  * @returns Size of point in pixels
                  * @public
                  */
                 getPointSize(): number;
                 /**
                  * Get shape of points.
                  *
                  * This is defined upon creation of series, and cannot be changed afterwards.
                  * @returns PointShape
                  * @public
                  */
                 getPointShape(): PointShape;
                 /**
                  * Set the rotation of points.
                  * @param angle - Rotation angle in degrees
                  * @public
                  */
                 setPointRotation(angle: number): this;
                 /**
                  * Get the current rotation of points.
                  * @public
                  */
                 getPointRotation(): number;
                 /**
                  * Enable or disable individual point sizing.
                  *
                  * When enabled, size for each point can be provided with the location of the point.
                  * ```js
                  * pointSeries.add({x: 1, y: 2, size: 10 })
                  * ```
                  * @param enabled - Boolean state for individual point size enabled
                  * @public
                  */
                 setIndividualPointSizeEnabled(enabled: boolean): this;
                 /**
                  * Gets if individual point sizing is enabled or not.
                  * @public
                  */
                 getIndividualPointSizeEnabled(): boolean;
                 /**
                  * Enable or disable individual point rotation.
                  *
                  * When enabled, rotation for each point can be provided with the location of the point.
                  * ```js
                  * pointSeries.add({x: 1, y: 2, rotation: 45 })
                  * ```
                  * @param enabled - Boolean state for individual point size enabled
                  * @public
                  */
                 setIndividualPointRotationEnabled(enabled: boolean): this;
                 /**
                  * Gets if individual point rotation is enabled or not.
                  * @public
                  */
                 getIndividualPointRotationEnabled(): boolean;
                 /**
                  * Enable or disable individual point value attributes.
                  *
                  * When enabled, each added data point can be associated with a numeric `value` attribute.
                  *
                  * ```typescript
                  *  PointLineSeries.add({ x: 1, y: 2, value: 10 })
                  * ```
                  *
                  * Can be used for dynamic per data point coloring when points are styled with {@link PalettedFill}.
                  * See {@link setPointFillStyle}.
                  *
                  * @param enabled - Individual point values enabled or disabled.
                  * @public
                  */
                 setIndividualPointValueEnabled(enabled: boolean): this;
                 /**
                  * Gets if individual point values are enabled or disabled.
                  * @public
                  */
                 getIndividualPointValueEnabled(): boolean;
                 /**
                  * Set element visibility.
                  *
                  * @param state - `true` when element should be visible and `false` when element should be hidden.
                  * @returns Object itself.
                  */
                 setVisible(state: boolean): this;
                 /**
                  * Set if cursor interpolates solved data-points along series by default.
                  *
                  * ```typescript
                  *  // Example, disable default interpolation of progressiveX point line series.
                  *  const series = ChartXY.addPointLineSeries({
                  *      dataPattern: {
                  *          pattern: 'ProgressiveX'
                  *      }
                  *  })
                  *      .setCursorInterpolationEnabled(false)
                  * ```
                  *
                  * Cursor interpolation is only supported with a collection of configuration combinations:
                  *
                  * - *Freeform data* + *cursor solve basis* = `'nearest'`
                  * - *ProgressiveX data* + *cursor solve basis* = `'nearestX'`
                  * - *ProgressiveY data* + *cursor solve basis* = `'nearestY'`
                  *
                  * With any other combination, or if cursor intepolation is disabled, the closest actual data point will be selected.
                  *
                  * **Related API:**
                  * - Information about specifying series *data pattern* {@link ChartXY.addPointLineSeries}
                  * - *Cursor solve basis* {@link PointLineSeries.setCursorSolveBasis}
                  *
                  * **Related API:**
                  *
                  * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                  * - {@link setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                  * - {@link setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
                  * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                  *
                  * @param state - Boolean flag
                  * @returns Object itself for fluent interface
                  * @public
                  */
                 setCursorInterpolationEnabled(state: boolean): this;
                 /**
                  * Get if cursor interpolates solved data-points along series by default.
                  * @returns Boolean flag
                  * @public
                  */
                 getCursorInterpolationEnabled(): boolean;
                 /**
                  * Set basis of solving data point nearest to a given location from this series.
                  *
                  * Default configuration is `'nearest-x'`.
                  *
                  * ```typescript
                  *  // Example, configure series cursor to snap to closest data point along both X and Y dimensions.
                  *  PointLineSeries.setCursorSolveBasis('nearest')
                  * ```
                  *
                  * **Related API:**
                  *
                  * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                  * - {@link setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                  * - {@link setCursorInterpolationEnabled} | configure automatic cursor interpolation between data points enabled.
                  * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                  *
                  * @param basis - String describing the desired solve behavior.
                  * @public
                  */
                 setCursorSolveBasis(basis: 'nearest' | 'nearest-x' | 'nearest-y'): this;
                 /**
                  * Get basis of solving data point nearest to a given location from this series.
                  *
                  * Default configuration is `'nearest'`.
                  *
                  * @returns String describing the desired solve behavior.
                  * @public
                  */
                 getCursorSolveBasis(): 'nearest' | 'nearest-x' | 'nearest-y';
                 /**
                  * Attach object to an legendBox entry
                  * @param entry - Object which has to be attached
                  * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
                  *                          when its respective Entry is clicked.
                  * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
                  * @returns Series itself for fluent interface
                  * @public
                  */
                 attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
                 /**
                  * Clear all previously pushed data points from the *series*.
                  *
                  * ```ts
                  *  // Example usage
                  *  LineSeries.clear()
                  * ```
                  *
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 clear(): this;
                 /**
                  * Method for solving the nearest data point from a given coordinate on screen.
                  *
                  * ```ts
                  *  // Example usage, from mouse move event.
                  *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                  *      const result = LineSeries.solveNearestFromScreen(event)
                  *  })
                  * ```
                  *
                  * ```ts
                  *  // Example usage, arbitrary coordinate on client coordinate system.
                  *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                  * ```
                  *
                  * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                  *
                  * @param   location -  Location in HTML client coordinates.
                  * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                  * @public
                  */
                 solveNearestFromScreen(location: CoordinateClient, interpolate?: boolean): undefined | CursorPoint;
                 /**
                  * Solves the nearest datapoint to a given coordinate on screen.
                  * @param location - Location on screen
                  * @returns Undefined or data-structure for positioning of cursors
                  * @public
                  * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                  */
                 solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
             }
             /**
              * Series type for visualizing a collection of `{ x, y, z }` coordinates by a continuous line stroke and markers.
              *
              * `PointLineSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
              *
              * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
              * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
              *
              * **Creating PointLineSeries3D:**
              *
              * `PointLineSeries3D` are created with {@link Chart3D.addPointLineSeries} method.
              *
              * ```typescript
              *  // Example syntax, create point line series 3D
              *  const pointLineSeries3D = Chart3D.addPointLineSeries()
              * ```
              *
              * **Frequently used methods:**
              *
              * - Append data points to series | {@link add}
              * - Remove all data points from series | {@link clear}
              * - Configure style of line stroke | {@link setStrokeStyle}
              * - Configure style of markers | {@link setPointStyle}
              * - Destroy series permanently | {@link dispose}
              *
              * **Color shading style**.
              *
              * By default, `PointLineSeries3D` uses _Phong_ shading style.
              *
              * This can be changed with `PointLineSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
              *
              * **Related information:**
              *
              * For series with only line stroke, see {@link LineSeries3D}.
              *
              * For series with only markers, see {@link PointSeries3D}.
              * @public
              */
             export declare class PointLineSeries3D extends LineAndPointSeries3D {
                 /**
                  * Set point style of Series.
                  *
                  * Example usage:
                  *
                  * - **New TriangulatedPoints3D object**
                  * ```ts
                  *  pointLineSeries3D.setPointStyle( new PointStyle3D.Triangulated({
                  *      size: 10,
                  *      shape: 'sphere',
                  *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
                  *  }) )
                  * ```
                  * - **Change point size**
                  * ```ts
                  *  pointLineSeries3D.setPointStyle( (pointStyle) => pointStyle
                  *      .setSize( 10 )
                  *  )
                  * ```
                  * - **Change point shape**
                  * ```ts
                  *  pointLineSeries3D.setPointStyle( (pointStyle) => pointStyle
                  *      .setShape( 'cube' )
                  *  )
                  * ```
                  *
                  * **NOTE:** Currently `PointLineSeries3D` only supports Solid filled points.
                  * Alternatively, `PointSeries3D` can be used for various dynamic and powerful coloring features. See {@link PointSeries3D.setPointStyle} for examples and more information.
                  *
                  * @param value - A TriangulatedPoints3D object, or a function which modifies the current style.
                  * @returns Object itself for fluent interface
                  * @public
                  */
                 setPointStyle(value: TriangulatedPoints3D | ImmutableMutator<TriangulatedPoints3D>): this;
                 /**
                  * Get normal points style.
                  * @returns TriangulatedPoints3D
                  * @public
                  */
                 getPointStyle(): TriangulatedPoints3D;
                 /**
                  * Set stroke style of Series.
                  *
                  * Supported line styles:
                  * - {@link SolidLine}
                  *
                  * ```ts
                  *  // Example syntax, specify LineStyle
                  *  LineSeries3D.setStrokeStyle(new SolidLine({
                  *      thickness: 2,
                  *      fillStyle: new SolidFill({ color: ColorHEX('#F00') })
                  *  }))
                  * ```
                  *
                  * ```ts
                  *  // Example syntax, change active LineStyle
                  *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(5))
                  * ```
                  *
                  * Use `-1` thickness to enable primitive line rendering.
                  * Primitive line rendering can have slightly better rendering performance than line with `1` thickness but the quality of line is not as good.
                  * ```typescript
                  *  LineSeries3D.setStrokeStyle((solidLine) => solidLine.setThickness(-1))
                  * ```
                  *
                  * - **Supported fill styles:**
                  *
                  * {@link SolidFill}:
                  *
                  * Solid color for entire line series.
                  *
                  * ```ts
                  *  // Example, solid colored line.
                  *  LineSeries3D.setStrokeStyle(new SolidLine({
                  *      thickness: 2,
                  *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                  *  }))
                  * ```
                  *
                  * To learn more about available *Color* factories, see {@link ColorRGBA}
                  *
                  * {@link PalettedFill}:
                  *
                  * Color line stroke dynamically based on `x`, `y` or `z` coordinate.
                  *
                  * ```ts
                  *  // Example, dynamic color by Y coordinates
                  *  LineSeries3D.setStrokeStyle(new SolidLine({
                  *      thickness: 2,
                  *      fillStyle: new PalettedFill({
                  *          lookUpProperty: 'y',
                  *          lut: new LUT({
                  *              interpolate: true,
                  *              steps: [
                  *                  { value: 0, color: ColorRGBA(255, 0, 0) },
                  *                  { value: 100, color: ColorRGBA(0, 255, 0) },
                  *              ]
                  *          })
                  *      })
                  *  }))
                  * ```
                  *
                  * To learn more about Color lookup tables, see {@link LUT}.
                  *
                  * - **Primitive 3D line rendering**
                  *
                  * `LineSeries3D` has a special feature for drawing *primitive* line sets.
                  *
                  * When enabled, this will draw all line segments as exactly 1 pixel thick on the monitor (regardless of distance from camera).
                  *
                  * As a benefit, this is considerably lighter on the GPU, which is especially good with mobile and laptop devices with weak GPUs.
                  *
                  * *Primitive* drawing is enabled by setting stroke thickness to `-1`:
                  *
                  * ```ts
                  *  // Enable primitive 3D line drawing.
                  *  LineSeries3D.setStrokeStyle((stroke) => stroke.setThickness(-1))
                  * ```
                  *
                  * - **Other information**
                  *
                  * In 3D, line thickness is not configured exactly as pixels (since the size of pixel is not affected by distance from camera).
                  *
                  * However, for usage convenience, you can consider line thickness in 3D as pixels just the same as 2D,
                  * even if the resulting visualization will have some differences.
                  *
                  * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setStrokeStyle(value: LineSeriesStyle3D | ImmutableMutator<LineSeriesStyle3D>): this;
                 /**
                  * Method matches highlight point size with that of the supplied line style.
                  */
                 private _matchJointHighlightSize;
             }
             /**
              * Interface for readonly configuration of {@link PointLineSeries}.
              *
              * **Commonly used properties:**
              * - {@link PointLineSeriesOptions.pointShape}: Specify shape of *point markers*.
              * - {@link PointLineSeriesOptions.xAxis}: Attach series on non-default X Axis.
              * - {@link PointLineSeriesOptions.yAxis}: Attach series on non-default Y Axis.
              * - {@link PointLineSeriesOptions.dataPattern}: Enable powerful application specific optimizations if input data follows a *specific pattern*.
              *
              * **Example usage:**
              *
              * ```typescript
              *  // Example 1, create series with default configuration.
              *  const series = ChartXY.addPointLineSeries({})
              * ```
              *
              * ```typescript
              *  // Example 2, select shape of point markers.
              *  const series = ChartXY.addPointLineSeries({
              *      pointShape: PointShape.Circle
              *  })
              * ```
              *
              * ```typescript
              *  // Example 3, specify progressive X data pattern for enabling application specific optimizations.
              *  const series = ChartXY.addPointLineSeries({
              *      dataPattern: {
              *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
              *          pattern: 'ProgressiveX',
              *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
              *          regularProgressiveStep: true,
              *      }
              *  })
              * ```
              * @public
              */
             export declare interface PointLineSeriesOptions extends SeriesOptionsXY {
                 /**
                  * Shape of *point markers*.
                  *
                  * Select value from {@link PointShape}.
                  *
                  * ```typescript
                  *  // Example, select Circle shape of points.
                  *  const series = ChartXY.addPointLineSeries({
                  *      pointShape: PointShape.Circle
                  *  })
                  * ```
                  */
                 pointShape?: PointShape;
                 /**
                  * Interface for enabling powerful application specific optimizations if input data follows a *specific pattern*.
                  *
                  * See {@link DataPattern} to learn if your data is eligible for such optimizations.
                  *
                  * **Example usage:**
                  *
                  * ```typescript
                  *  // Example, Line Chart with timestamp X values that always progress by exactly 1 minute (60000 ms).
                  *  // => 'ProgressiveX' + regularProgressiveStep can be used
                  *  ChartXY.addLineSeries({
                  *      dataPattern: {
                  *          // pattern: 'ProgressiveX' => Each consecutive data point has increased X coordinate.
                  *          pattern: 'ProgressiveX',
                  *          // regularProgressiveStep: true => The X step between each consecutive data point is regular (for example, always `1.0`).
                  *          regularProgressiveStep: true,
                  *      }
                  *  })
                  * ```
                  */
                 dataPattern?: DataPattern;
             }
             /**
              * Interface that can be used to specify readonly parameters when creating a {@link PointLineSeries3D}.
              * @public
              */
             export declare interface PointLineSeriesOptions3D {
             }
             /**
              * Visual that is displayed at the Cursors position.
              * Has customizable fill and border.
              * @public
              */
             export declare interface PointMarker extends Marginable, Interactable {
                 /**
                  * Set displayed shape.
                  *
                  * ```ts
                  *  // Example
                  *  setShape(PointShape.Star)
                  * ```
                  *
                  * See {@link PointShape} for all available options.
                  *
                  * @public
                  */
                 setShape(shape: PointShape): this;
                 /**
                  * Get displayed shape.
                  * @public
                  */
                 getShape(): PointShape;
                 /**
                  * Set rotation of point shape in degrees.
                  * @param   rotationDeg - Rotation in degrees.
                  * @returns     Object itself.
                  * @public
                  */
                 setRotation(rotationDeg: number): this;
                 /**
                  * Get rotation of point shape in degrees.
                  * @returns     Rotation as degrees
                  * @public
                  */
                 getRotation(): number;
                 /**
                  * Set origin position of PointMarker
                  * @param origin - (-1 to 1 which specifies position of origin, 0 is center of the object)
                  * @returns Object itself for fluent interface
                  * @public
                  */
                 setOrigin: (origin: Point) => this;
                 /**
                  * Get origin position of PointMarker
                  * @returns (-1 to 1 which specifies position of origin, 0 is center of the object)
                  * @public
                  */
                 getOrigin: () => Point;
                 /**
                  * Set size of PointMarker
                  * @param size - Size of PointMarker in pixels
                  * @returns Object itself
                  * @public
                  */
                 setSize: (size: Point) => this;
                 /**
                  * Get size of PointMarker
                  * @returns Size of PointMarker in pixels
                  * @public
                  */
                 getSize: () => Point;
                 /**
                  * Set fillStyle of PointMarker
                  * @param fillStyle - FillStyle object or mutator to modify existing one
                  * @returns Object itself
                  * @public
                  */
                 setFillStyle: (fillStyle: FillStyle | ImmutableMutator<FillStyle>) => this;
                 /**
                  * Get fillStyle of PointMarker
                  * @returns FillStyle object
                  * @public
                  */
                 getFillStyle: () => FillStyle;
             }
             /**
              * Implementation of *SeriesXY* for visualizing a collection of *Points* by filling them with a specifiable {@link PointShape}.
              *
              * *PointSeries* are created with {@link ChartXY.addPointSeries}.
              *
              * NOTE: Points shape must be specified when series is created.
              *
              * Frequently used API:
              *
              * - Enable individual point size {@link setIndividualPointSizeEnabled}
              * - Enable individual point rotation {@link setIndividualPointRotationEnabled}
              * - Enable individual point palette coloring {@link setIndividualPointValueEnabled}
              * - Append data points to series | {@link add}
              * - Remove all data points from series | {@link clear}
              * - Configure style of points | {@link setPointFillStyle}
              * - Configure size of points | {@link setPointSize}
              * - Configure cursor enabled | {@link setCursorEnabled}
              * - Destroy series permanently | {@link dispose}
              * - Configure automatic data cleaning | {@link setDataCleaning}
              * - Solve nearest data point from specified location | {@link solveNearestFromScreen}
              * @public
              */
             export declare class PointSeries extends BasicSeries<PointSeriesDataPoint, LinearScaleXY | MixedScaleXY> implements Pointed, IndividualPointed, AttachableWithLUT {
                 /**
                  * Append a single `XY` coordinate or list of coordinates into the *series*.
                  *
                  * ```ts
                  *  // Example syntax
                  *  PointSeries.add({ x: 0, y: 100 })
                  *
                  *  PointSeries.add([
                  *      { x: 0, y: 100 },
                  *      { x: 10, y: 50 },
                  *      { x: 20, y: 75 },
                  *  ])
                  * ```
                  *
                  * **Additional extra data point properties**
                  *
                  * There is also a set of extra properties that can be supplied for each data point:
                  *
                  * - `color`    | Associate data point with a color. Can be used for individual point coloring, when point fill style is {@link IndividualPointFill}.
                  * - `size`     | Associate data point with a size. Can be used for individual point size. Must be enabled with {@link setIndividualPointSizeEnabled}.
                  * - `rotation` | Associate data point with a rotation. Can be used for individual point rotation. Must be enabled with {@link setIndividualPointRotationEnabled}.
                  * - `value`    | Associate data point with a value. Can be used for paletted point coloring. Must be enabled with {@link setIndividualPointValueEnabled}.
                  *
                  * ```ts
                  *  PointSeries
                  *      .setIndividualPointSizeEnabled(true)
                  *      .setIndividualPointRotationEnabled(true)
                  *      .setIndividualPointValueEnabled(true)
                  *      .add({
                  *          x: 0,
                  *          y: 0,
                  *          color: ColorRGBA(255, 0, 0),
                  *          size: 10,
                  *          rotation: 45,
                  *          value: 62.5
                  *      })
                  * ```
                  *
                  * @param points - Single XY coordinate or list of coordinates.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 add(points: PointSeriesDataPoint | Array<PointSeriesDataPoint>): this;
                 /**
                  * Attach object to an legendBox entry
                  * @param entry - Object which has to be attached
                  * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
                  *                          when its respective Entry is clicked.
                  * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
                  * @returns Series itself for fluent interface
                  * @public
                  */
                 attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
                 /**
                  * Set point fill style of Series.
                  * Use {@link IndividualPointFill} object to enable individual coloring of points.
                  *
                  * Example usage:
                  *```javascript
                  * // Create a new style
                  * PointSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                  * // Change transparency
                  * PointSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
                  * // Set hidden
                  * PointSeries.setPointFillStyle(emptyFill)
                  * ```
                  * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                  * @returns Series itself for fluent interface.
                  * @public
                  */
                 setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                 /**
                  * Get normal points fill style.
                  * @returns Normal point fillStyle
                  * @public
                  */
                 getPointFillStyle(): FillStyle;
                 /**
                  * Set size of point in pixels.
                  * @param size - Size of point in pixels.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setPointSize(size: number): this;
                 /**
                  * Get current size of points in pixels.
                  * @returns Size of point in pixels.
                  * @public
                  */
                 getPointSize(): number;
                 /**
                  * Get shape of points.
                  *
                  * This is defined upon creation of series, and cannot be changed afterwards.
                  * @returns PointShape
                  * @public
                  */
                 getPointShape(): PointShape;
                 /**
                  * Set the rotation of points in degrees.
                  * @param angle - Rotation angle in degrees
                  * @public
                  */
                 setPointRotation(angle: number): this;
                 /**
                  * Get the current rotation of points.
                  * @public
                  */
                 getPointRotation(): number;
                 /**
                  * Enable or disable individual point sizing.
                  *
                  * When enabled, size for each point can be provided with the location of the point.
                  * ```js
                  * pointSeries.add({x: 1, y: 2, size: 10 })
                  * ```
                  * @param enabled - Boolean state for individual point size enabled
                  * @public
                  */
                 setIndividualPointSizeEnabled(enabled: boolean): this;
                 /**
                  * Gets if individual point sizing is enabled or not.
                  * @public
                  */
                 getIndividualPointSizeEnabled(): boolean;
                 /**
                  * Enable or disable individual point rotation.
                  *
                  * When enabled, rotation for each point can be provided with the location of the point.
                  * ```js
                  * pointSeries.add({x: 1, y: 2, rotation: 45 })
                  * ```
                  * @param enabled - Boolean state for individual point size enabled
                  * @public
                  */
                 setIndividualPointRotationEnabled(enabled: boolean): this;
                 /**
                  * Gets if individual point rotation is enabled or not.
                  * @public
                  */
                 getIndividualPointRotationEnabled(): boolean;
                 /**
                  * Enable or disable individual point value attributes.
                  *
                  * When enabled, each added data point can be associated with a numeric `value` attribute.
                  *
                  * ```typescript
                  *  PointSeries.add({ x: 1, y: 2, value: 10 })
                  * ```
                  *
                  * Can be used for dynamic per data point coloring when points are styled with {@link PalettedFill}.
                  * See {@link setPointFillStyle}.
                  *
                  * @param enabled - Individual point values enabled or disabled.
                  * @public
                  */
                 setIndividualPointValueEnabled(enabled: boolean): this;
                 /**
                  * Gets if individual point values are enabled or disabled.
                  * @public
                  */
                 getIndividualPointValueEnabled(): boolean;
                 /**
                  * Method for solving the nearest data point from a given coordinate on screen.
                  *
                  * ```ts
                  *  // Example usage, from mouse move event.
                  *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                  *      const result = LineSeries.solveNearestFromScreen(event)
                  *  })
                  * ```
                  *
                  * ```ts
                  *  // Example usage, arbitrary coordinate on client coordinate system.
                  *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                  * ```
                  *
                  * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                  *
                  * @param   location -  Location in HTML client coordinates.
                  * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                  * @public
                  */
                 solveNearestFromScreen(location: CoordinateClient): undefined | CursorPoint;
                 /**
                  * Solves the nearest data point to a given coordinate on screen.
                  * @param location - Location on screen
                  * @returns Undefined or data-structure for positioning of cursors
                  * @public
                  * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                  */
                 solveNearestFromScreen(location: Point): undefined | CursorPoint;
                 /**
                  * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                  *
                  * ```typescript
                  *  // Example usage
                  *  LineSeries.setCursorResultTableFormatter((tableBuilder, series, x, y, dataPoint) => {
                  *      return tableBuilder
                  *          .addRow(`Pointing at`, '', series.getName())
                  *          .addRow(`X:`, '', dataPoint.x.toFixed(1))
                  *          .addRow(`Y:`, '', dataPoint.y.toFixed(1))
                  *  })
                  * ```
                  *
                  * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                  * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                  *
                  * ```typescript
                  *  // Using TableContentBuilder.
                  *  LineSeries.setCursorResultTableFormatter((tableBuilder, series, x, y) => {
                  *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                  *      tableBuilder
                  *          .addRow('Item 0:', '', 'Value 0')
                  *          .addRow('Item 1:', '', 'Value 1')
                  *          .addRow('Long row that highlights the idea of empty strings')
                  *
                  *      // After configuration, the table builder must be returned!
                  *      return tableBuilder
                  *  })
                  * ```
                  *
                  * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
                  *
                  * The additional values that are supplied to the callback function, **vary per series**,
                  * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                  * For example, `LineSeries` receives three extra parameters:
                  * 1. `series` | reference to the series itself.
                  * 2. `x` | pointed data point X coordinate.
                  * 3. `y` | pointed data point Y coordinate.
                  * 4. `dataPoint` | reference to the pointed data point as supplied by user.
                  *
                  * **Related API:**
                  *
                  * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                  * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                  *
                  * @param formatter - Function which builds *ResultTable* content.
                  * @returns Object itself
                  * @public
                  */
                 setCursorResultTableFormatter(formatter: SeriesXYFormatter): this;
             }
             /**
              * Series type for visualizing a collection of `{ x, y, z }` coordinates by different markers
              *
              * `PointSeries3D` is optimized for *massive* amounts of data - here are some reference specs to give an idea:
              *
              * - A static data set in millions data points range is rendered in hundreds of milliseconds (~200ms). Afterwards chart can be rotated and zoomed with 60 FPS.
              * - With streaming data, even millions of data points can be streamed in every second, while retaining an interactive document.
              *
              * **Creating PointSeries3D:**
              *
              * `PointSeries3D` are created with {@link Chart3D.addPointSeries} method.
              *
              * Some properties of `PointSeries3D` can only be configured when it is created. These arguments are all optional,
              * and are wrapped in a single object parameter:
              *
              * ```typescript
              *  // Example,
              *  const pointSeries3D = Chart3D.addPointSeries({
              *      // Enable individual data points size.
              *      individualPointSizeEnabled: true
              *  })
              * ```
              *
              * To learn about available properties, refer to {@link PointSeriesOptions3D}.
              *
              * **Frequently used methods:**
              *
              * - Append data points to series | {@link add}
              * - Remove all data points from series | {@link clear}
              * - Configure style of points | {@link setPointStyle}
              * - Destroy series permanently | {@link dispose}
              *
              * **Color shading style**.
              *
              * By default, `PointSeries3D` uses _Phong_ shading style.
              *
              * This can be changed with `PointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())`
              *
              * **Related information:**
              *
              * There is another series type for visualizing large sets of 3D coordinates with markers: {@link PointCloudSeries3D}
              *
              * `PointCloudSeries3D` works otherwise same, except that it has simplified render process (all markers are 2D geometry),
              * which is faster and can be really powerful in visualizing large low-detail data sets!
              * @public
              */
             export declare class PointSeries3D extends AbstractPointSeries3D<TriangulatedPoints3D> implements AttachableWithLUT {
                 /**
                  * Set point style of Series.
                  *
                  * **Example syntax:**
                  *
                  * ```ts
                  *  // Example syntax, Specify new style
                  *  pointSeries3D.setPointStyle( new PointStyle3D.Triangulated({
                  *      size: 10,
                  *      shape: 'sphere',
                  *      fillStyle: new SolidFill({ color: ColorHEX('#FFF') })
                  *  }) )
                  * ```
                  *
                  * ```ts
                  *  // Example syntax, Change point color
                  *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
                  *      .setFillStyle( new SolidFill({ color: ColorHEX('#FFF') }) )
                  *  )
                  * ```
                  *
                  * ```ts
                  *  // Example syntax, Change point size
                  *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
                  *      .setSize( 10 )
                  *  )
                  * ```
                  *
                  * ```ts
                  *  // Example syntax, Change point shape
                  *  pointSeries3D.setPointStyle( (pointStyle) => pointStyle
                  *      .setShape( 'cube' )
                  *  )
                  * ```
                  *
                  * **Point coloring:**
                  *
                  * Color of points is configured by the `fillStyle` property of active point style.
                  *
                  * Here is a list of all supported _fill styles_ with feature descriptions and example syntax:
                  *
                  * {@link SolidFill}:
                  *
                  * Solid color for all points in series.
                  *
                  * ```js
                  *  // Example syntax, solid points color.
                  *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
                  *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }),
                  *      size: 10,
                  *      shape: 'sphere'
                  *  }))
                  * ```
                  *
                  * {@link PalettedFill}:
                  *
                  * Look-up dynamic per-point color based on a _look up property_ (number) and a color look up table ({@link LUT}).
                  *
                  * ```js
                  *  // Example syntax, dynamic points color.
                  *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
                  *      fillStyle: new PalettedFill({
                  *          // lookUpProperty defines basis of selecting look up value (number).
                  *          lookUpProperty: 'value',
                  *          // lut defines table for mapping look up value (number) to a color.
                  *          lut: new LUT({
                  *              interpolate: true,
                  *              steps: [
                  *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                  *                  { value: 1, color: ColorRGBA(255, 0, 0) }
                  *              ]
                  *          })
                  *      }),
                  *      size: 10,
                  *      shape: 'sphere'
                  *  }))
                  * ```
                  *
                  * `PointSeries3D` supports several different look-up modes:
                  *
                  * `lookUpProperty: 'value'`:
                  *
                  * **IMPORTANT:** In order to use `value` property on data points, the feature has to be explicitly activated **when the series is created**:
                  *
                  * ```js
                  *  // Example syntax, enable individual data point values.
                  *  const pointSeries3D = chart3D.addPointSeries({
                  *      individualLookupValuesEnabled: true
                  *  })
                  * ```
                  *
                  * `value` property is then added for every data point along side `x`, `y` and `z`:
                  *
                  * ```js
                  *  // Example syntax, individual data point values.
                  *  pointSeries3D.add([
                  *      { x: 0, y: 0, z: 0, value: 0 },
                  *      { x: 1, y: 0, z: 2, value: 1 },
                  *  ])
                  * ```
                  *
                  * Look-up value is read from data point `value` property.
                  *
                  * `lookUpProperty: 'x'`:
                  *
                  * Look-up value is set to data point `x` coordinate on Axis.
                  *
                  * `lookUpProperty: 'y'`:
                  *
                  * Look-up value is set to data point `y` coordinate on Axis.
                  *
                  * `lookUpProperty: 'z'`:
                  *
                  * Look-up value is set to data point `z` coordinate on Axis.
                  *
                  * {@link IndividualPointFill}:
                  *
                  * Supply individual color for each data point.
                  *
                  * **IMPORTANT:** In order to use `IndividualPointFill`, the feature has to be explicitly activated **when the series is created**:
                  *
                  * ```js
                  *  // Example syntax, enable individual data point colors.
                  *  const pointSeries3D = chart3D.addPointSeries({
                  *      individualPointColorEnabled: true
                  *  })
                  * ```
                  *
                  * `color` property is then added for every data point along side `x`, `y` and `z`:
                  *
                  * ```js
                  *  // Example syntax, individual data point colors.
                  *  pointSeries3D.add([
                  *      { x: 0, y: 0, z: 0, color: ColorRGBA(255, 0, 0) },
                  *      { x: 1, y: 0, z: 2, color: ColorRGBA(0, 255, 0) },
                  *  ])
                  * ```
                  *
                  * **Point size:**
                  *
                  * Size of points is configured by the `size` property of active point style.
                  *
                  * If required, points can also be individually sized by adding a `size` property to data points.
                  *
                  * **IMPORTANT:** In order to use `size` property, the feature has to be explicitly activated **when the series is created**:
                  *
                  * ```js
                  *  // Example syntax, enable individual data point size.
                  *  const pointSeries3D = chart3D.addPointSeries({
                  *      individualPointSizeEnabled: true
                  *  })
                  * ```
                  *
                  * `size` property is then added for every data point along side `x`, `y` and `z`:
                  *
                  * ```js
                  *  // Example syntax, individual data point sizes.
                  *  pointSeries3D.add([
                  *      { x: 0, y: 0, z: 0, size: 5 },
                  *      { x: 1, y: 0, z: 2, size: 10 },
                  *  ])
                  * ```
                  *
                  *
                  * **Point size 3D:**
                  *
                  * As an alternative method to `size`, each 3D point can also be sized with individual sizes for each Axis (X, Y and Z).
                  *
                  * This is done by adding `sizeAxisX`, `sizeAxisY`, and `sizeAxisZ` properties to data points.
                  *
                  * **IMPORTANT:** In order to use these properties, the feature has to be explicitly activated **when the series is created**:
                  *
                  * ```js
                  *  // Example syntax, enable individual data point 3D axis size.
                  *  const pointSeries3D = chart3D.addPointSeries({
                  *      individualPointSizeAxisEnabled: true
                  *  })
                  * ```
                  *
                  * `sizeAxisX`, `sizeAxisY` and `sizeAxisZ` properties are then added for every data point along side `x`, `y` and `z`:
                  *
                  * ```js
                  *  // Example syntax, individual data point 3D axis sizes.
                  *  pointSeries3D.add([
                  *      { x: 0, y: 0, z: 0, sizeAxisX: 1, sizeAxisY: 10, sizeAxisZ: 5 },
                  *      { x: 1, y: 0, z: 2, sizeAxisX: 1, sizeAxisY: 10, sizeAxisZ: 5 },
                  *  ])
                  * ```
                  *
                  *
                  * **IMPORTANT:** in order for points to be sized based on `sizeAxisX`, `sizeAxisY` and `sizeAxisZ` properties, the active point style must also have a fallback point size definition **as axis dimensions**:
                  *
                  * ```js
                  *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
                  *      // IMPORTANT: fallback `size` must be defined with { x, y, z } syntax!
                  *      size: { x: 1, y: 1, z: 1 },
                  *      shape: 'sphere',
                  *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                  *  }))
                  * ```
                  *
                  * @param value - A TriangulatedPoints3D object, or a function which modifies the current style.
                  * @returns Object itself for fluent interface
                  * @public
                  */
                 setPointStyle(value: TriangulatedPoints3D | ImmutableMutator<TriangulatedPoints3D>): this;
                 /**
                  * Get normal points style.
                  * @returns TriangulatedPoints3D
                  * @public
                  */
                 getPointStyle(): TriangulatedPoints3D;
             }
             /**
              * Interface for data points that can be added to a {@link PointSeries}.
              * @public
              */
             export declare interface PointSeriesDataPoint extends Point, ColorValue, SizeValue, RotationValue, DataValue {
             }
             /**
              * Interface can be used to define the X and Y Axis that a series should be attached to,
              * and define Shape for points of series.
              * @public
              */
             export declare interface PointSeriesOptions extends SeriesOptionsXY {
                 /**
                  * PointShape Shape for points of series.
                  */
                 pointShape?: PointShape;
             }
             /**
              * Interface that can be used to specify readonly parameters when creating a {@link PointSeries3D}.
              *
              * `PointSeries3D` is created with {@link Chart3D.addPointSeries} method.
              * @public
              */
             export declare interface PointSeriesOptions3D<T extends PointSeriesTypes3D = PointSeriesTypes3D> extends SeriesOptions {
                 /**
                  * Defines the type of *Point Series 3D*.
                  *
                  * See {@link PointSeriesTypes3D} for a collection of options.
                  *
                  * ```js
                  *  // Example syntax,
                  *  const pointSeries3D = chart3D.addPointSeries({
                  *      type: PointSeriesTypes3D.Triangulated
                  *  })
                  * ```
                  */
                 type?: T;
                 /**
                  * Flag that can be used to enable data points `color` property on top of `x`, `y` and `z`.
                  * By default this is disabled.
                  *
                  * This feature can be used to color data points individually by user supplied color.
                  *
                  * If required, this must be enabled **when the series is created**.
                  *
                  * ```js
                  *  // Example, enable PointSeries3D data `color` property.
                  *  const pointSeries3D = chart3D.addPointSeries({
                  *      individualPointColorEnabled: true
                  *  })
                  *
                  *  // 'color' property can now be included in data points.
                  *  pointSeries3D.add([
                  *      { x: 0, y: 0, z: 0, color: ColorRGBA(255, 0, 0) }
                  *  ])
                  * ```
                  *
                  * `individualPointColorEnabled` must be enabled in order to style `PointSeries3D` with {@link IndividualPointFill}.
                  * See {@link PointSeries3D.setPointStyle} for more detailed information.
                  *
                  * **Performance side-effects from enabling**:
                  * - Increases CPU scripting time very slightly.
                  * - Slightly increased GPU memory usage.
                  */
                 individualPointColorEnabled?: boolean;
                 /**
                  * Flag that can be used to enable data points `size` property on top of `x`, `y` and `z`.
                  * By default this is disabled.
                  *
                  * This feature can be used to size data points individually by user supplied values.
                  *
                  * If required, this must be enabled **when the series is created**.
                  *
                  * ```js
                  * // Example, enable PointSeries3D data `size` property.
                  * const pointSeries3D = chart3D.addPointSeries({
                  *     individualPointSizeEnabled: true
                  * })
                  *
                  * // 'size' property can now be included in data points.
                  * pointSeries3D.add([
                  *     { x: 0, y: 0, z: 0, size: 5 }
                  * ])
                  * ```
                  *
                  * **Performance side-effects from enabling**:
                  * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
                  */
                 individualPointSizeEnabled?: boolean;
                 /**
                  * Flag that can be used to enable data points 'sizeAxisX', 'sizeAxisY' and 'sizeAxisZ' properties on top of `x`, `y` and `z`.
                  * By default this is disabled.
                  *
                  * This feature can be used to size data points individually as 3D Axis dimensions.
                  *
                  * If required, this must be enabled **when the series is created**.
                  *
                  * ```js
                  *  // Example, enable PointSeries3D data point individual axis size properties.
                  *  const pointSeries3D = chart3D.addPointSeries({
                  *      individualPointSizeAxisEnabled: true
                  *  })
                  *
                  *  // 'sizeAxisX', 'sizeAxisY' and 'sizeAxisZ' properties can now be included in data points.
                  *  pointSeries3D.add([
                  *      { x: 0, y: 0, z: 0, sizeAxisX: 1, sizeAxisY: 10, sizeAxisZ: 5 }
                  *  ])
                  * ```
                  *
                  * **NOTE:** in order for points to be sized based on `sizeAxisX`, `sizeAxisY` and `sizeAxisZ` properties, the active point style must also have a fallback point size definition **as axis dimensions**:
                  *
                  * ```js
                  *  pointSeries3D.setPointStyle(new PointStyle3D.Triangulated({
                  *      // IMPORTANT: fallback `size` must be defined with { x, y, z } syntax!
                  *      size: { x: 1, y: 1, z: 1 },
                  *      shape: 'sphere',
                  *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                  *  }))
                  * ```
                  *
                  * **Performance side-effects from enabling**:
                  * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
                  */
                 individualPointSizeAxisEnabled?: boolean;
                 /**
                  * Flag that can be used to enable data points `value` property on top of `x`, `y` and `z`.
                  * By default this is disabled.
                  *
                  * This feature can be used to color data points individually by dynamic color look up.
                  *
                  * If required, this must be enabled **when the series is created**.
                  *
                  * ```js
                  *  // Example, enable PointSeries3D data `value` property.
                  *  const pointSeries3D = chart3D.addPointSeries({
                  *      individualLookupValuesEnabled: true
                  *  })
                  *
                  *  // 'value' property can now be included in data points.
                  *  pointSeries3D.add([
                  *      { x: 0, y: 0, z: 0, value: 5 }
                  *  ])
                  * ```
                  *
                  * `individualLookupValuesEnabled` must be enabled in order to style `PointSeries3D` with {@link PalettedFill} of `lookUpProperty: 'value'`.
                  * See {@link PointSeries3D.setPointStyle} for more detailed information.
                  *
                  * **Performance side-effects from enabling**:
                  * - With detailed point geometry (like 'sphere'), the geometry precision will be maximized, resulting in considerable increase in GPU processing time.
                  */
                 individualLookupValuesEnabled?: boolean;
             }
             /**
              * Collection of *PointSeries3D* implementations.
              *
              * Used when creating an *PointSeries3D* with {@link Chart3D.addPointSeries}.
              * Selected option tells what the returned *Series* type will be - *PointSeries3D* implementations are otherwise equal, but
              * their styling APIs expect different *Style* objects.
              *
              * - Select PointSeriesTypes3D.Triangulated for shaded geometries styled with {@link PointStyle3D | PointStyle3D.Triangulated}.
              * - Select PointSeriesTypes3D.Pixelated for pixels styled with {@link PointStyle3D | PointStyle3D.Pixelated}.
              * @public
              */
             export declare const PointSeriesTypes3D: {
                 /**
                  * Type of *Point Series 3D* that visualized points by shaded geometry styled using {@link PointStyle3D | PointStyle3D.Triangulated}.
                  */
                 Triangulated: typeof PointSeries3D;
                 /**
                  * Type of *Point Series 3D* that visualized points by pixels styled using {@link PointStyle3D | PointStyle3D.Pixelated}.
                  */
                 Pixelated: typeof PointCloudSeries3D;
             };
             /**
              * Available Point Series 3D types.
              *
              * Used internally for proper type casting. Should not be included in docs,
              * as it overrides the selection object just below, that has the same name.
              * @public
              */
             export declare type PointSeriesTypes3D = typeof PointSeriesTypes3D[keyof typeof PointSeriesTypes3D];
             /**
              * Enum for selecting shape of points for Point-based *Series*.
              * Supported by:
              * - {@link PointSeries}
              * - {@link PointLineSeries}
              * - {@link SpiderSeries}
              *
              * This must be specified when the *Series* is created, and can't be changed afterwards.
              * @public
              */
             export declare enum PointShape {
                 /**
                  * Square shape.
                  */
                 Square = 0,
                 /**
                  * Circle shape.
                  */
                 Circle = 1,
                 /**
                  * Triangle shape.
                  */
                 Triangle = 2,
                 /**
                  * Cross (X) shape.
                  */
                 Cross = 3,
                 /**
                  * Diamond (45 deg rotated square) shape.
                  */
                 Diamond = 4,
                 /**
                  * Plus (+) shape.
                  */
                 Plus = 5,
                 /**
                  * Minus (-) shape.
                  */
                 Minus = 6,
                 /**
                  * Arrow shape.
                  * Points up with 0 rotation.
                  */
                 Arrow = 7,
                 /**
                  * Star shape.
                  */
                 Star = 8
             }
             /**
              * Collection of constructors for specifying style of 3D points rendering.
              *
              * Used with:
              * - **PointSeries3D**
              * - **PointCloudSeries3D**
              * @public
              */
             export declare const PointStyle3D: {
                 /**
                  * A style class used to specify style of 3D points rendering as triangulated Cubes.
                  */
                 Triangulated: typeof TriangulatedPoints3D;
                 /**
                  * A style class used to specify style of 3D points rendering as pixelated squares.
                  *
                  * This rendering style is optimal for rendering large numbers of points that do not require great individual detail.
                  */
                 Pixelated: typeof PixelatedPoints3D;
             };
             /**
              * Interface for a immutable data-structure which defines a location along the XZ plane, without any Y information.
              * @public
              */
             export declare interface PointXZ {
                 /**
                  * Location in X-dimension.
                  */
                 readonly x: number;
                 /**
                  * Location in Z-dimension.
                  */
                 readonly z: number;
             }
             /**
              * Abstract super class for Polar Area Series.
              * @public
              */
             export declare abstract class PolarAreaSeries extends PolarSeries<CursorPoint> {
                 /**
                  * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                  *
                  * ```typescript
                  *  // Example usage
                  *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                  *      return tableBuilder
                  *          .addRow(`Pointing at`, '', series.getName())
                  *          .addRow(`Angle:`, '', angleDeg.toFixed(0) + ' deg')
                  *          .addRow(`Amplitude:`, '', amplitude.toFixed(1))
                  *  })
                  * ```
                  *
                  * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                  * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                  *
                  * ```typescript
                  *  // Using TableContentBuilder.
                  *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                  *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                  *      tableBuilder
                  *          .addRow('Item 0:', '', 'Value 0')
                  *          .addRow('Item 1:', '', 'Value 1')
                  *          .addRow('Long row that highlights the idea of empty strings')
                  *
                  *      // After configuration, the table builder must be returned!
                  *      return tableBuilder
                  *  })
                  * ```
                  *
                  * The additional values that are supplied to the callback function vary between different chart types,
                  * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                  * All `Polar Series` receive three extra parameters:
                  * 1. `series` | reference to the series itself.
                  * 2. `angleDeg` | pointed data point angle as degrees.
                  * 3. `amplitude` | pointed data point amplitude.
                  *
                  * **Related API:**
                  *
                  * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                  * - {@link PolarChart.setAutoCursorMode} | configure behavior when auto cursor is visible.
                  *
                  * @param formatter - Function which builds *ResultTable* content.
                  * @returns Object itself
                  * @public
                  */
                 setCursorResultTableFormatter(formatter: PolarSeriesFormatter): this;
                 /**
                  * Get ResultTable Formatter.
                  * @returns Function which builds ResultTable content for SpiderSeries.
                  * @public
                  */
                 getCursorResultTableFormatter(): PolarSeriesFormatter;
                 /**
                  * Set data for PolarSeries to render as a list of {@link PolarPoint}s.
                  * @param points - List of {@link PolarPoint}s.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setData(points: PolarPoint[]): this;
                 /**
                  * Set fill style of Series.
                  *
                  * Example usage:
                  *```javascript
                  * // Create a new style
                  * PolarAreaSeries.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                  * // Change transparency
                  * PolarAreaSeries.setFillStyle((solidFill) => solidFill.setA(80))
                  * // Set hidden
                  * PolarAreaSeries.setFillStyle(emptyFill)
                  * ```
                  * @param value - Either a FillStyle object or a function, which will be used to create a new SolidLine based on current value.
                  * @returns Chart itself
                  * @public
                  */
                 setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                 /**
                  * Get fill style of Series.
                  * @returns FillStyle object
                  * @public
                  */
                 getFillStyle(): FillStyle;
                 /**
                  * Set stroke style of Series.
                  *
                  * Supported line styles:
                  * - {@link SolidLine}
                  * - {@link emptyLine}
                  *
                  * Example usage:
                  *```javascript
                  * // Specified LineStyle
                  * PolarAreaSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                  * // Changed thickness
                  * PolarAreaSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                  * // Hidden
                  * PolarAreaSeries.setStrokeStyle(emptyLine)
                  * ```
                  * @param value - Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
                  * @returns Chart itself
                  * @public
                  */
                 setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                 /**
                  * Get stroke style of Series.
                  * @returns LineStyle object
                  * @public
                  */
                 getStrokeStyle(): LineStyle;
                 /**
                  * Set automatic connection of first and last data points enabled or not.
                  *
                  * **Disabled by default.**
                  * @param enabled - Boolean.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setConnectDataAutomaticallyEnabled(enabled: boolean): this;
                 /**
                  * Get automatic connection of first and last data points enabled or not.
                  * @returns Boolean.
                  * @public
                  */
                 getConnectDataAutomaticallyEnabled(): boolean;
                 /**
                  * Attach object to an legendBox entry
                  * @param entry - Object which has to be attached
                  * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
                  *                          when its respective Entry is clicked.
                  * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
                  * @returns Series itself for fluent interface
                  * @public
                  */
                 attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
             }
             /**
              * Type of *PolarAreaSeries* that fills the Polar area between data points and center of Polar Chart.
              *
              * **Example usage:**
              *
              * - *Plot sub section (\< 360 degrees) of the Polar Chart*
              * ```ts
              *  const areaSeries = polarChart.addAreaSeries()
              *      .setData(
              *          new Array( 90 ).fill( 0 ).map(( _, i ) => ({
              *              angle: i,
              *              amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
              *          }))
              *      )
              * ```
              *
              * - *Plot a fully connected (360 degrees) section of the Polar Chart*
              * ```ts
              *  const areaSeries = polarChart.addAreaSeries()
              *      .setConnectDataAutomaticallyEnabled(true)
              *      .setData(
              *          new Array(360).fill(0).map((_, i) => ({
              *              angle: i,
              *              amplitude: 60 + 25 * Math.cos((5 * i * Math.PI) / 180),
              *          })),
              *      )
              * ```
              * @public
              */
             export declare class PolarAreaSeriesInterior extends PolarAreaSeries {
                 /**
                  * Method for solving the nearest data point from a given coordinate on screen.
                  *
                  * ```ts
                  *  // Example usage, from mouse move event.
                  *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                  *      const result = LineSeries.solveNearestFromScreen(event)
                  *  })
                  * ```
                  *
                  * ```ts
                  *  // Example usage, arbitrary coordinate on client coordinate system.
                  *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                  * ```
                  *
                  * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                  *
                  * @param   location -  Location in HTML client coordinates.
                  * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                  * @public
                  */
                 solveNearestFromScreen(location: CoordinateClient): undefined | CursorPoint;
                 /**
                  * Abstract method that solves the nearest data point to a given coordinate on screen.
                  * @param location - Location on screen
                  * @returns Undefined or data-structure for positioning of cursors
                  * @public
                  * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                  */
                 solveNearestFromScreen(location: Point): CursorPoint | undefined;
             }
             /**
              * Generic super class for {@link PolarAxisAmplitude} and {@link PolarAxisRadial}.
              * @public
              */
             export declare abstract class PolarAxis extends GenericAxis<AxisScale, PolarAxisStrategy, PolarAxisTick, _AbstractTickPlottingVariables, undefined> implements StylableAxisLine {
                 /**
                  * Set *TickStrategy* of *Axis*.
                  *
                  * The *TickStrategy* defines the positioning and formatting logic of *Axis* ticks
                  * as well as the style of created ticks.
                  *
                  * **Example usage**:
                  *
                  * **DateTime Axis**:
                  * ```javascript
                  *  Axis.setTickStrategy( AxisTickStrategies.DateTime )
                  * ```
                  *
                  * **Disable automatic ticks completely**:
                  * ```javascript
                  *  Axis.setTickStrategy( AxisTickStrategies.Empty )
                  * ```
                  *
                  * **Customized TickStrategy**:
                  * ```javascript
                  *  Axis.setTickStrategy( AxisTickStrategies.Numeric, ( tickStrategy: NumericTickStrategy ) => tickStrategy
                  *      .setNumericUnits( true )
                  *      .setMajorTickStyle( ( tickStyle ) => tickStyle
                  *          .setLabelFont( ( font ) => font
                  *              .setWeight( 'bold' )
                  *          )
                  *      )
                  *  )
                  * ```
                  *
                  * **Type table for optional second parameter ('styler')**:
                  *
                  * | tickStrategy   | styler                                                        |
                  * | :------------- | :------------------------------------------------------------ |
                  * | 'Numeric'      | `( tickStrategy: **NumericTickStrategy** ) => tickStrategy`   |
                  * | 'Time'         | `( tickStrategy: **TimeTickStrategy** ) => tickStrategy`      |
                  * | 'DateTime'     | `( tickStrategy: **DateTimeTickStrategy** ) => tickStrategy`  |
                  * | 'Empty'        | `undefined`                                                   |
                  *
                  *
                  * @param tickStrategy - Selected TickStrategy.
                  *                          See {@link AxisTickStrategies} for a collection of options.
                  * @param styler - Optional callback that can be used to customize the *TickStrategy*.
                  *                          The type of supplied *TickStrategy* object depends on what was supplied to 'tickStrategy' parameter;
                  *                          See the above method documentation for a value table.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setTickStrategy<TickStrategy extends TickStrategyType>(tickStrategy: TickStrategy, styler?: TickStrategyStyler<TickStrategyParameters, TickStrategy>): this;
                 /**
                  * Specifies axis stroke
                  * @param value - Axis stroke style
                  * @returns Axis itself for fluent interface
                  * @public
                  */
                 setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                 /**
                  * @returns Axis stroke as a LineStyle object
                  * @public
                  */
                 getStrokeStyle(): LineStyle;
                 /**
                  * Enable / disable all interactions of Axis.
                  * @param enabled - Interactions enabled or not.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setMouseInteractions(enabled: boolean): this;
             }
             /**
              * Class that represents the **amplitude** value interval on a {@link PolarChart}.
              *
              * The Amplitude Axis is depicted as a single line segment starting from the very center of the PolarChart and ending at its right side.
              *
              * The Amplitude Axes' tick grid lines travel all over the PolarCharts Series space, doing a full 360 degree until returning to the other end of the tick, along the Amplitude Axis.
              *
              * The Amplitude Axes' title is positioned just below the Axis line and centered horizontally.
              *
              * Here is a list of the most commonly useful methods of Polar Amplitude Axis:
              * - {@link PolarAxisAmplitude.setTitle}            | Set title label.
              * - {@link PolarAxisAmplitude.setInterval}         | Set amplitude interval (start, end).
              * - {@link PolarAxisAmplitude.setScrollStrategy}   | Specify basis of automatic scrolling based on attached Series.
              * - {@link PolarAxisAmplitude.setStrokeStyle}      | Set style of Axis line.
              * - {@link PolarAxisAmplitude.setTickStrategy}     | Set style and creation basis of Axis ticks.
              * @public
              */
             export declare class PolarAxisAmplitude extends PolarAxis {
             }
             /**
              * Axis object that represents a {@link PolarChart}s *radial* dimension,
              * which is depicted as an angle on the Charts center.
              *
              *
              * Class that represents the **radial** value interval on a {@link PolarChart}.
              *
              * The Radial Axis is depicted as a continuous line traversing all the way along the outer edge of the PolarChart.
              *
              * The Radial Axes' ticks are positioned along this line, with the gridlines slicing the PolarChart into equally sized slices.
              *
              * The Radial Axes' title is positioned next to the charts right side, next to where the {@link PolarAxisAmplitude} ends.
              *
              * Here is a list of the most commonly useful methods of Polar Radial Axis:
              * - {@link PolarAxisRadial.setTitle}                   | Set title label.
              * - {@link PolarAxisRadial.setStrokeStyle}             | Set style of Axis line.
              * - {@link PolarAxisRadial.setTickStyle}               | Set style of Axis ticks.
              * - {@link PolarAxisRadial.setDivision}                | Set amount of sections of PolarChart (also amount of Radial ticks).
              * - {@link PolarAxisRadial.setClockwise}               | Set direction of radial progression. Default = Counter Clock-Wise.
              * - {@link PolarAxisRadial.setNorth}                   | Set rotation of Radial Axis.
              * - {@link PolarAxisRadial.setTickFormattingFunction}  | Set formatting of Axis ticks.
              * @public
              */
             export declare interface PolarAxisRadial extends StylableAxisLine, StylableAxisTitle {
                 /**
                  * Set style of Axis *ticks*.
                  *
                  * **Example usage:**
                  *
                  * - Modify default style (assuming its type as {@link TickStyle})
                  *
                  * ```ts
                  *  PolarAxisRadial.setTickStyle( ( ticks: TickStyle ) => ticks
                  *      .setLabelFillStyle( new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }) )
                  *  )
                  *
                  * ```
                  *
                  * - Pass a completely custom created TickStyle object
                  *
                  * ```ts
                  *  PolarAxisRadial.setTickStyle( new TickStyle({
                  *      labelFillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
                  *  }) )
                  * ```
                  *
                  * @param value - Either a {@link TickStyle} object or a function, which will be used to modify previous style.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
                 /**
                  * Get style of Axis *ticks*.
                  * @returns TickStyle object.
                  * @public
                  */
                 getTickStyle(): TickStyle;
                 /**
                  * Set whether PolarAxisRadial direction is clockwise or counterclockwise.
                  *
                  * Defaults to counterclockwise (false).
                  * @param clockwise - True for clockwise direction, False for counterclockwise.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setClockwise(clockwise: boolean): this;
                 /**
                  * Get whether PolarAxisRadial is clockwise or counterclockwise.
                  * @returns True for clockwise direction, False for counterclockwise.
                  * @public
                  */
                 getClockwise(): boolean;
                 /**
                  * Set rotation of Radial Axis by specifying degree angle that is depicted at *North* position (horizontally centered, vertically highest).
                  *
                  * Example usage:
                  * ```typescript
                  *  // Rotate Radial Axis so that 0 degrees is shown at North position.
                  *  PolarAxisRadial.setNorth(0)
                  * ```
                  * @param angle - Angle as *degrees* that will be depicted at *North* position. Defaults to 90.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setNorth(angle: number): this;
                 /**
                  * Get rotation of Radial Axis as degree angle that is depicted at *North* position (horizontally centered, vertically highest).
                  * @returns Angle as *degrees* that is depicted at *North* position. Defaults to 90.
                  * @public
                  */
                 getNorth(angle: number): number;
                 /**
                  * Set Axis tick formatting function. This defines text displayed by each tick.
                  * @param formattingFunction - {@link FormattingFunction}.
                  * @returns Object itself for fluent interface.
                  * @public
                  */
                 setTickFormattingFunction(formattingFunction: FormattingFunction): this;
                 /**
                  * Get Axis tick formatting function. This defines text displayed by each tick.
                  * @returns {@link FormattingFunction}
                      * @public
                      */
                  getTickFormattingFunction(): FormattingFunction;
                  /**
                   * Set how many sections the Radial Axis is divided into by Ticks.
                   * @param sectionsCount - Amount of sections.
                   * @returns Object itself for fluent interface.
                   * @public
                   */
                  setDivision(sectionsCount: number): this;
                  /**
                   * Get how many sections the Radial Axis is divided into by Ticks.
                   * @returns Amount of sections.
                   * @public
                   */
                  getDivision(): number;
                 }
                 /**
                  * @public
                  */
                 declare interface PolarAxisStrategy extends AbstractAxisStrategy {
                 }
                 /**
                  * Implementation of Polar Axis Tick.
                  * @public
                  */
                 export declare class PolarAxisTick extends Tick {
                 }
                 /**
                  * Chart for visualizing data in a *Polar coordinate system* ( **angle** + **amplitude** ).
                  * It has a multitude of methods for adding various types of Series. For example:
                  * - {@link PolarChart.addPointLineSeries}
                  * - {@link PolarChart.addAreaSeries}
                  * - {@link PolarChart.addPolygonSeries}
                  * - {@link PolarChart.addHeatmapSeries}
                  * - {@link PolarChart.addSector}
                  *
                  * *PolarCharts* *Axes* can be styled similarly as those of {@link ChartXY}.
                  * Refer to them via methods:
                  * - {@link PolarChart.getAmplitudeAxis}
                  * - {@link PolarChart.getRadialAxis}
                  *
                  * *Charts* are created by methods of {@link LightningChart} interface or a {@link Dashboard}.
                  * @public
                  */
                 export declare class PolarChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<PolarSeries> implements ChartWithAxis<PolarAxis>, ChartWithCursor<CursorResultTableBackgroundType> {
                     /**
                      * Selector for "client" _Coordinate System_.
                      *
                      * This references the coordinate system used in HTML.
                      * It starts at top left of the web page and is measured in pixels.
                      * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
                      *
                      * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
                      *
                      * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
                      * For example, in order to:
                      * - Position LCJS UI elements in client coordinates
                      * - Find client coordinate that matches a location along LCJS Axis or Chart.
                      * - etc.
                      *
                      * See {@link translateCoordinate} for more detailed use case information and example usage.
                      *
                      * @public
                      */
                     readonly coordsClient: CoordinateSystemClient;
                     /**
                      * Selector for Polar Axis Coordinate System, measured in angles and amplitudes.
                      *
                      * This selector can be used for translating Polar coordinates to other coordinate systems and vice versa.
                      * For example, in order to:
                      * - Position LCJS UI elements in Polar coordinates
                      * - Find client coordinate that matches a location at Polar amplitude & angle
                      * - Translating user click event location to a Polar amplitude & angle.
                      * - etc.
                      *
                      * See {@link translateCoordinate} for more detailed use case information and example usage.
                      *
                      * @public
                      */
                     readonly coordsAxis: CoordinateSystemPolar;
                     /**
                      * Get series of a chart
                      * @returns Array of series
                      * @public
                      */
                     getSeries(): PolarSeries[];
                     /**
                      * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
                      *
                      * **Example usage:**
                      *
                      * ```typescript
                      *  // Example 1, style AutoCursor ResultTable.
                      *  PolarChart.setAutoCursor((autoCursor) => autoCursor
                      *      .setResultTable((resultTable) => resultTable
                      *          .setOrigin(UIOrigins.LeftTop)
                      *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                      *          .setTextFont((font) => font
                      *              .setSize(12)
                      *              .setFamily('sans-serif')
                      *          )
                      *          .setBackground((background) => background
                      *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
                      *          )
                      *      )
                      *  )
                      * ```
                      *
                      * ```typescript
                      *  // Example 2, style AutoCursor PointMarker.
                      *  PolarChart.setAutoCursor((autoCursor) => autoCursor
                      *      .setPointMarker((marker) => marker
                      *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                      *          .setSize({ x: 10, y: 10 })
                      *          .setStrokeStyle(emptyLine),
                      *      ),
                      *  )
                      * ```
                      * @param mutator - Callback function that receives reference to the charts `AutoCursor`.
                      * @returns Object itself for fluent interface.
                      * @public
                      */
                     setAutoCursor(mutator: Mutator<AutoCursor<CursorResultTableBackgroundType>>): this;
                     /**
                      * Get reference to charts `AutoCursor`.
                      *
                      * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
                      *
                      * @returns `AutoCursor`.
                      * @public
                      */
                     getAutoCursor(): AutoCursor<CursorResultTableBackgroundType>;
                     /**
                      * Set chart `AutoCursor` behavior, by selecting a preset option from {@link AutoCursorModes}.
                      *
                      * Possible values:
                      * - `AutoCursorModes.snapToClosest` (default) | *AutoCursor* snaps to closest data point from mouse location.
                      * - `AutoCursorModes.onHover` | *AutoCursor* is only shown when it is directly over a *series*. NOTE: Series mouse interactions must be enabled for this to work!
                      * - `AutoCursorModes.disabled` | *AutoCursor* is disabled
                      *
                      * ```typescript
                      *  // Example, disable AutoCursor
                      *  PolarChart.setAutoCursorMode(AutoCursorModes.disabled)
                      * ```
                      *
                      * **Related information:**
                      *
                      * On *series* level, *AutoCursor* behavior can be configured individually for each *series*, and there are also more *series* specific options available.
                      * Here is `LineSeries` for example:
                      *
                      * - {@link Series2D.setCursorEnabled} | configure whether cursor should pick on the series or not.
                      * - {@link SeriesXY.setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                      * - {@link LineSeries.setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
                      * - {@link SeriesXY.setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
                      *
                      * @param mode - Selection of *AutoCursor* behavior.
                      * @returns Object itself for fluent interface.
                      * @public
                      */
                     setAutoCursorMode(mode: AutoCursorModes): this;
                     /**
                      * Get `AutoCursor` behavior, from a collection of preset options ({@link AutoCursorModes}).
                      * @returns Active selection of *AutoCursor* behavior.
                      * @public
                      */
                     getAutoCursorMode(): AutoCursorModes;
                     /**
                      * Translate a coordinate to another coordinate system.
                      *
                      * Supports following coordinate systems:
                      *
                      * - HTML client coordinates ({@link CoordinateSystemClient | more information}).
                      * - Relative control coordinates ({@link CoordinateSystemRelative | more information}).
                      * - Polar Axis coordinates ({@link CoordinateSystemPolar | more information}).
                      *
                      * Most common example use cases:
                      *
                      * **(1) Translate a coordinate from HTML client coordinates to Polar axes**
                      *
                      * ```ts
                      *  PolarChart.onSeriesBackgroundMouseClick((_, event) => {
                      *      const locationAxis = chart.translateCoordinate(event, chart.coordsAxis)
                      *      // locationAxis tells the clicked location along Axis interval (in same value range as data points).
                      *  })
                      * ```
                      *
                      * **(2) Translate a coordinate from Polar axes to HTML client coordinates**
                      *
                      * ```ts
                      *  const locationAxis = { angle: 45, amplitude: 5 }
                      *  const locationClient = chart.translateCoordinate(locationAxis, chart.coordsClient)
                      * ```
                      *
                      * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                      *
                      * ```ts
                      *  myHTMLElement.style.position = 'absolute'
                      *  myHTMLElement.style.left = locationClient.clientX
                      *  myHTMLElement.style.top = locationClient.clientY
                      * ```
                      *
                      * **(3) Translate a coordinate from Polar axes to relative coordinates**
                      *
                      * ```ts
                      *  const locationAxis = { angle: 45, amplitude: 5 }
                      *  const locationRelative = chart.translateCoordinate(locationAxis, chart.coordsRelative)
                      * ```
                      *
                      * Relative coordinates can be used for positioning LightningChart JS UI components:
                      *
                      * ```ts
                      *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
                      *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
                      *      .setOrigin(UIOrigins.LeftBottom)
                      *      .setPosition({ x: 20, y: 20 })
                      * ```
                      *
                      * **(4) Translate a coordinate from relative chart coordinates to axes**
                      *
                      *
                      * ```ts
                      *  const locationRelative = { x: 0, y: 0 }
                      *  const locationAxis = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsAxis)
                      * ```
                      *
                      * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                      * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                      *
                      * ```ts
                      *  LineSeries.add(myData)
                      *  requestAnimationFrame(() => {
                      *      // translateCoordinate should now consider data added just now.
                      *  })
                      * ```
                      *
                      * @public
                      */
                     translateCoordinate<T extends CoordinateSystemClient | CoordinateSystemPolar | CoordinateSystemRelative>(coordinate: CoordinateClient | CoordinatePolar | CoordinateXY, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : T extends CoordinateSystemPolar ? CoordinatePolar : T extends CoordinateSystemRelative ? CoordinateXY : never;
                     /**
                      * Translate a coordinate from relative control coordinates to another coordinate system.
                      *
                      * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
                      * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
                      *
                      * **(1) Polar axis coordinate system:**
                      *
                      * ```ts
                      *  const locationRelative = { x: 100, y: 200 }
                      *  const locationAxis = polarChart.translateCoordinate(locationRelative, polarChart.coordsRelative, polarChart.coordsAxis)
                      * ```
                      *
                      * Polar axis locations can be used for example with different Polar Series, like {@link PolarPointSeries}.
                      *
                      * **(2) HTML client coordinate system**
                      *
                      * ```ts
                      *  const locationRelative = { x: 100, y: 200 }
                      *  const locationClient = polarChart.translateCoordinate(locationRelative, polarChart.coordsRelative, polarChart.client)
                      * ```
                      *
                      * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                      *
                      * ```ts
                      *  myHTMLElement.style.position = 'absolute'
                      *  myHTMLElement.style.left = locationClient.clientX
                      *  myHTMLElement.style.top = locationClient.clientY
                      * ```
                      *
                      * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                      * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                      *
                      * ```ts
                      *  LineSeries.add(myData)
                      *  requestAnimationFrame(() => {
                      *      // translateCoordinate should now consider data added just now.
                      *  })
                      * ```
                      *
                      * @public
                      */
                     translateCoordinate<T extends CoordinateSystemClient | CoordinateSystemPolar>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : T extends CoordinateSystemPolar ? CoordinatePolar : never;
                     /**
                      * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
                      *
                      * ```ts
                      *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
                      *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
                      *  // locationRelative is in pixels relative to bottom left corner of the chart
                      * ```
                      *
                      * Relative coordinates can be used for positioning LightningChart JS UI components:
                      *
                      * ```ts
                      *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
                      *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
                      *      .setOrigin(UIOrigins.LeftBottom)
                      *      .setPosition({ x: 20, y: 20 })
                      * ```
                      *
                      * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                      * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                      *
                      * ```ts
                      *  LineSeries.add(myData)
                      *  requestAnimationFrame(() => {
                      *      // translateCoordinate should now consider data added just now.
                      *  })
                      * ```
                      *
                      * @public
                      * @privateRemarks  This definition of the method originates from the super class.
                      */
                     translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
                     /**
                      * Translate a coordinate from relative control coordinates to HTML client coordinate system.
                      *
                      * ```ts
                      *  // 10 pixels left and 20 pixels up from controls bottom left corner
                      *  const locationRelative = { x: 10, y: 20 }
                      *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
                      * ```
                      *
                      * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                      *
                      * ```ts
                      *  myHTMLElement.style.position = 'absolute'
                      *  myHTMLElement.style.left = locationClient.clientX
                      *  myHTMLElement.style.top = locationClient.clientY
                      * ```
                      *
                      * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                      * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                      *
                      * ```ts
                      *  LineSeries.add(myData)
                      *  requestAnimationFrame(() => {
                      *      // translateCoordinate should now consider data added just now.
                      *  })
                      * ```
                      *
                      * @public
                      * @privateRemarks  This definition of the method originates from the super class.
                      */
                     translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
                     /**
                      * Add a Line series to the PolarChart.
                      *
                      * {@link PolarLineSeries} are used to render a list of {@link PolarPoint}s
                      * by a continuous line that can be styled arbitrarily.
                      *
                      * **Example usage:**
                      *
                      * ```ts
                      *  const lineSeries = polarChart.addLineSeries().setData(
                      *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                      *          angle: i,
                      *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                      *      }))
                      *  )
                      * ```
                      * @returns {@link PolarLineSeries}.
                          * @public
                          */
                      addLineSeries(options?: SeriesOptions): PolarLineSeries;
                      /**
                       * Add a Point series to the PolarChart.
                       *
                       * {@link PolarPointSeries} are used to render a list of {@link PolarPoint}s
                       * by different shapes.
                       *
                       * **Example usage:**
                       *
                       * ```ts
                       *  const pointSeries = polarChart.addPointSeries().setData(
                       *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                       *          angle: i,
                       *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                       *      }))
                       *  )
                       * ```
                       * @returns {@link PolarPointSeries}.
                           * @public
                           */
                       addPointSeries(options?: SeriesOptions): PolarPointSeries;
                       /**
                        * Add a Point Line series to the PolarChart.
                        *
                        * {@link PolarPointLineSeries} are used to render a list of {@link PolarPoint}s
                        * by a continuous line drawn between the points plus configurable shapes over each data point.
                        *
                        * **Example usage:**
                        *
                        * ```ts
                        *  const pointLineSeries = polarChart.addPointLineSeries().setData(
                        *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                        *          angle: i,
                        *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                        *      }))
                        *  )
                        * ```
                        * @returns {@link PolarPointLineSeries}.
                            * @public
                            */
                        addPointLineSeries(options?: SeriesOptions): PolarPointLineSeries;
                        /**
                         * Add a Area series to the PolarChart.
                         *
                         * {@link PolarAreaSeries} are used to render a list of {@link PolarPoint}s
                         * by filling the enclosed area.
                         *
                         * **Example usage:**
                         *
                         * - *Plot sub section (\< 360 degrees) of the Polar Chart*
                         * ```ts
                         *  const areaSeries = polarChart.addAreaSeries()
                         *      .setData(
                         *          new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                         *              angle: i,
                         *              amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                         *          }))
                         *      )
                         * ```
                         *
                         * - *Plot a fully connected (360 degrees) section of the Polar Chart*
                         * ```ts
                         *  const areaSeries = polarChart.addAreaSeries()
                         *      .setConnectDataAutomaticallyEnabled(true)
                         *      .setData(
                         *          new Array(360).fill(0).map((_, i) => ({
                         *              angle: i,
                         *              amplitude: 60 + 25 * Math.cos((5 * i * Math.PI) / 180),
                         *          })),
                         *      )
                         * ```
                         * @returns {@link PolarAreaSeries}.
                             * @public
                             */
                         addAreaSeries(options?: SeriesOptions): PolarAreaSeriesInterior;
                         /**
                          * Add a Polygon series to the PolarChart.
                          *
                          * {@link PolarPolygonSeries} are used to render a collection of *polygons* inside the Polar coordinate system. They are especially useful for highlighting parts of the Polar coordinate system.
                          *
                          * **Example usage:**
                          *
                          * ```ts
                          *  const polygonSeries = polarChart.addPolygonSeries()
                          *  let ang = 45
                          *  let amplitude = 50
                          *  const polygon = polygonSeries.addPolygon()
                          *      .setGeometry([
                          *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                          *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                          *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                          *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
                          *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                          *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
                          *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
                          *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                          *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                          *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                          *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
                          *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
                          *      ])
                          * ```
                          * @returns {@link PolarPolygonSeries}.
                              * @public
                              */
                          addPolygonSeries(options?: SeriesOptions): PolarPolygonSeries;
                          /**
                           * Add a Series for visualizing a *Polar Heatmap* with a static sector and annuli count. Has API for fast modification of cell values.
                           *
                           * `PolarHeatmapSeries` is optimized for high resolution data. For example, 1 degree precision or less along Radial Axis, and up to 2000 samples along Amplitude Axis.
                           *
                           * To learn more about its features and usage, refer to {@link PolarHeatmapSeries}.
                           *
                           * **Readonly configuration:**
                           *
                           * Some properties of `PolarHeatmapSeries` can only be configured when it is created. Some of these arguments are **mandatory**, while some are optional.
                           * They are wrapped in a single object parameter:
                           *
                           * ```js
                           *  // Example,
                           *  const series = PolarChart.addHeatmapSeries({
                           *      sectors: 360,
                           *      annuli: 100
                           *  })
                           * ```
                           *
                           * To learn about available properties, refer to {@link PolarHeatmapSeriesOptions}.
                           *
                           * Each cell of the heatmap is associated with a *numeric intensity value*, which can be used together with a
                           * Color look up table ({@link LUT}).
                           *
                           * @param options - Configuration parameters for Polar Heatmap Series.
                           * @returns Polar Heatmap Series.
                           * @public
                           */
                          addHeatmapSeries(options: PolarHeatmapSeriesOptions): PolarHeatmapSeries;
                          /**
                           * Add a Sector highlighter to the PolarChart.
                           *
                           * {@link PolarSector}s can be used to highlight areas in the *polar coordinate system*.
                           * @returns {@link PolarSector}.
                               * @public
                               */
                           addSector(): PolarSector;
                           /**
                            * Get {@link PolarAxisAmplitude} object that represents the PolarCharts *amplitude* dimension,
                            * which is depicted as a distance away from the Charts center.
                            * @returns {@link PolarAxisAmplitude}.
                                * @public
                                */
                            getAmplitudeAxis(): PolarAxisAmplitude;
                            /**
                             * Get {@link PolarAxisRadial} object that represents the PolarCharts *radial* dimension,
                             * which is depicted as an angle on the Charts center.
                             * @returns {@link PolarAxisRadial}.
                                 * @public
                                 */
                             getRadialAxis(): PolarAxisRadial;
                             /**
                              * Cached axis margins from last plot.
                              *
                              * Used to detect scenario when margins significantly change to display axis correctly, even though their design is faulty.
                              */
                             private _previousAxisMargins?;
                             /**
                              * Disable/enable all animations for the chart.
                              * @param animationsEnabled - Boolean value to enable/disable animations.
                              * @returns Chart itself for fluent interface.
                              * @public
                              * @privateRemarks  Override to also apply to axes.
                              */
                             setAnimationsEnabled(animationsEnabled: boolean): this;
                             /**
                              * Set if mouse-interactions on chart are enabled or not
                              * @param enabled - Boolean flag
                              * @returns Object itself
                              * @public
                              */
                             setMouseInteractions(enabled: boolean): this;
                             /**
                              * Get are mouse-interactions on chart enabled or not
                              * @returns Boolean flag
                              * @public
                              */
                             getMouseInteractions(): boolean;
                             /**
                              * Get minimum size of Panel.
                              * Depending on the type of class this value might be automatically computed to fit different elements.
                              * @returns Vec2 minimum size or undefined if unimplemented
                              * @public
                              */
                             getMinimumSize(): Point | undefined;
                             /**
                              * Iterate over each Axis of Chart.
                              * @param clbk - Callback function for each Axis.
                              * @public
                              */
                             forEachAxis(clbk: (axis: PolarAxis) => void): this;
                             /**
                              * **Permanently** destroy the component.
                              *
                              * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                              * **to the component and its children** in application code.
                              * ```javascript
                              * let chart = ...ChartXY()
                              * let axisX = chart.getDefaultAxisX()
                              * // Dispose Chart, and remove all references so that they can be garbage-collected.
                              * chart.dispose()
                              * chart = undefined
                              * axisX = undefined
                              * ```
                              * @returns Object itself for fluent interface
                              * @public
                              */
                             dispose(): this;
                            }
                            /**
                             * Interface for readonly configuration of {@link PolarChart}.
                             *
                             * Some properties of `PolarChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
                             *
                             * ```typescript
                             *  // Example, create chart with specified color theme.
                             *  const chart = LightningChart.Polar({
                             *      theme: Themes.light,
                             *  })
                             * ```
                             *
                             * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
                             *
                             * For *standalone* `PolarChart`, more parameters are documented in {@link LightningChart.Polar}.
                             *
                             * For *dashboard* `PolarChart`, more parameters are documented in {@link Dashboard.createPolarChart}.
                             *
                             *
                             * **Commonly used properties:**
                             *
                             * - {@link PolarChartOptions.theme}: Specify chart color *theme*.
                             * - {@link PolarChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
                             *
                             * **Example usage:**
                             *
                             * ```typescript
                             *  // Example 1, create chart with default configuration.
                             *  const chart = LightningChart.Polar({})
                             * ```
                             *
                             * ```typescript
                             *  // Example 2, create chart with specified color theme.
                             *  const chart = LightningChart.Polar({
                             *      theme: Themes.light,
                             *  })
                             * ```
                             * @public
                             */
                            export declare interface PolarChartOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                                /**
                                 * Builder for the charts' *auto cursor*. Use {@link AutoCursorBuilders | AutoCursorBuilders.Polar} to modify the default builder, using methods of {@link AutoCursor2DBuilder}.
                                 *
                                 * ```typescript
                                 *  // Example, change cursor ResultTable background shape.
                                 *  const chart = LightningChart.Polar({
                                 *      autoCursorBuilder: AutoCursorBuilders.Polar
                                 *          .setResultTableBackground(UIBackgrounds.Circle)
                                 *  })
                                 * ```
                                 * @public
                                 */
                                autoCursorBuilder?: AutoCursor2DBuilder<CursorResultTableBackgroundType>;
                            }
                            /**
                             * Series for visualizing a *Polar Heatmap* with a static sector and annuli count. Has API for fast modification of cell values.
                             *
                             * `PolarHeatmapSeries` is optimized for high resolution data. For example, 1 degree precision or less along Radial Axis, and up to more than 2000 samples along Amplitude Axis.
                             * There is no hard cap on how much data you can put into a polar heatmap, the limit is the running device's GPU memory.
                             * Generally several million data points are no problem.
                             *
                             * Created with {@link PolarChart.addHeatmapSeries}.
                             *
                             * Frequently used API:
                             * - Set intensity data {@link invalidateIntensityValues}
                             * - Set fill style {@link setFillStyle}
                             * - Set intensity interpolation {@link setIntensityInterpolation}
                             * - Format auto cursor {@link setCursorResultTableFormatter}
                             * @public
                             */
                            export declare class PolarHeatmapSeries extends PolarSeries<CursorPoint> implements AttachableWithLUT {
                                /**
                                 * Invalidate range of heatmap intensity values starting from first sector and annulus, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link setFillStyle}).
                                 *
                                 * ```js
                                 *  // Example, 3x3 grid full invalidation.
                                 *  const heatmapSeries = PolarChart.addHeatmapSeries({
                                 *      sectors: 3,
                                 *      annuli: 3
                                 *  })
                                 *
                                 *  heatmapSeries.invalidateIntensityValues([
                                 *      // Annulus 0 intensity values.
                                 *      [0, 0, 0],
                                 *      // Annulus 1 intensity values.
                                 *      [1, 1, 1],
                                 *      // Annulus 2 intensity values.
                                 *      [0, 2, 0],
                                 *  ])
                                 * ```
                                 *
                                 * Data interpretation basis is defined by {@link PolarHeatmapSeriesOptions.dataOrder} property from when the series was created.
                                 *
                                 * `invalidateIntensityValues` can trigger warnings when used controversially.
                                 * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                 *
                                 * @param value - Matrix containing intensity values for each data slot of the grid.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                invalidateIntensityValues(value: number[][]): this;
                                /**
                                 * Invalidate a partial range of heatmap intensity values, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link setFillStyle}).
                                 *
                                 * ```js
                                 *  // Example, 100x10 grid invalidate partial section of grid.
                                 *
                                 *  const heatmapSeries = PolarChart.addHeatmapSeries({
                                 *      sectors: 100,
                                 *      annuli: 10
                                 *  })
                                 *
                                 *  heatmapSeries.invalidateIntensityValues({
                                 *      // Index of first invalidated annulus.
                                 *      iAnnulus: 5,
                                 *      // Index of first invalidated sector.
                                 *      iSector: 10,
                                 *      // Intensity values matrix. It's dimensions imply the amount of invalidated sectors and annuli.
                                 *      values: [
                                 *          // 1st invalidated annuli intensity values.
                                 *          [1, 1, 1, 1, 1],
                                 *          // 2nd invalidated annuli intensity values.
                                 *          [2, 2, 2, 2, 2],
                                 *          // 3rd invalidated annuli intensity values.
                                 *          [1, 0, 0, 0, 1],
                                 *          // 4th invalidated annuli intensity values.
                                 *          [0, 1, 0, 1, 0],
                                 *          // 5th invalidated annuli intensity values.
                                 *          [0, 0, 1, 0, 0],
                                 *      ],
                                 *  })
                                 * ```
                                 *
                                 * `invalidateIntensityValues` can trigger warnings when used controversially.
                                 * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                 *
                                 * @param value - Partial invalidation information, where `values` is an intensity value matrix, `iSector` the first affected sector and `iAnnulus` the first affected annulus.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                invalidateIntensityValues(value: {
                                    iSector: number;
                                    iAnnulus: number;
                                    values: number[][];
                                }): this;
                                /**
                                 * Set fill style of heatmap series.
                                 *
                                 * **Supported fill styles:**
                                 *
                                 * {@link PalettedFill}:
                                 *
                                 * Colors heatmap fill by looking color up from {@link LUT} based on heatmap *intensity values*.
                                 *
                                 * ```js
                                 *  // Example, color look up by intensity values.
                                 *  heatmapSeries.setFillStyle(
                                 *      new PalettedFill({
                                 *          lut: new LUT({
                                 *              steps: [
                                 *                  { value: 0, color: ColorCSS('red') },
                                 *                  { value: 20, color: ColorCSS('blue') },
                                 *              ],
                                 *              interpolate: true,
                                 *          }),
                                 *      }),
                                 *  )
                                 * ```
                                 *
                                 * Assign *intensity values* with {@link invalidateIntensityValues}.
                                 *
                                 * {@link SolidFill}:
                                 *
                                 * Solid color for all heatmap cells. Supported for debugging purposes mainly.
                                 *
                                 * {@link emptyFill}:
                                 *
                                 * Disables heatmap fill.
                                 *
                                 * ```js
                                 *  // Example, hide heatmap fill.
                                 *  heatmapSeries
                                 *      .setFillStyle(emptyFill)
                                 * ```
                                 *
                                 * @param value - FillStyle object or function which modifies current value.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                /**
                                 * Get fill style of series.
                                 * @returns FillStyle.
                                 * @public
                                 */
                                getFillStyle(): FillStyle;
                                /**
                                 * Method for customizing contents of ResultTables when pointing at this Series.
                                 *
                                 * ```ts
                                 *  // Example
                                 *  PolarHeatmapSeries.setCursorResultTableFormatter((builder, series, dataPoint, formatAmplitude) => builder
                                 *      .addRow(series.getName())
                                 *      .addRow('Angle:', '', `${dataPoint.angleDeg.toFixed(0)}`)
                                 *      .addRow('Intensity:', '', `${dataPoint.intensity.toFixed(1)}`)
                                 *  )
                                 * ```
                                 *
                                 * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
                                 *
                                 * @param formatter - Function which builds ResultTable content.
                                 *                      See definition of {@link PolarHeatmapSeriesFormatter} for supplied formatting information.
                                 * @returns Object itself
                                 * @public
                                 */
                                setCursorResultTableFormatter(formatter: PolarHeatmapSeriesFormatter): this;
                                /**
                                 * Get ResultTable Formatter.
                                 * @returns Function which builds ResultTable content for this series type.
                                 * @public
                                 */
                                getCursorResultTableFormatter(): PolarHeatmapSeriesFormatter;
                                /**
                                 * Clear all previous data pushed to the series.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                clear(): this;
                                /**
                                 * Set cursor interpolation enabled.
                                 *
                                 * If enabled, cursors will display bilinearly interpolated *intensity* values from the four closest heatmap cells
                                 * to the mouse pointer. Otherwise, cursor will display the nearest actual data point supplied by user.
                                 *
                                 * @param state - Boolean flag
                                 * @returns Object itself for fluent interface
                                 * @public
                                 */
                                setCursorInterpolationEnabled(state: boolean): this;
                                /**
                                 * Get if cursor interpolates solved data-points along series by default.
                                 * @returns Boolean flag
                                 * @public
                                 */
                                getCursorInterpolationEnabled(): boolean;
                                /**
                                 * Configure whether *cursors* should pick on this particular *series* or not.
                                 *
                                 * ```typescript
                                 *  // Example, prevent chart auto cursor from snapping to a series.
                                 *  LineSeries.setCursorEnabled(false)
                                 * ```
                                 *
                                 * **Related API:**
                                 *
                                 * - {@link setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
                                 * This method is not available for all *series* types.
                                 * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                 * @public
                                 */
                                setCursorEnabled(state: boolean): this;
                                /**
                                 * Set heatmap intensity interpolation mode.
                                 *
                                 * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
                                 *
                                 * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
                                 *
                                 * @param interpolationMode - Heatmap intensity interpolation mode selection.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
                                /**
                                 * Get heatmap intensity interpolation mode.
                                 * @returns Heatmap intensity interpolation mode selection.
                                 * @public
                                 */
                                getIntensityInterpolation(): IntensityInterpolationMode;
                                /**
                                 * Method for solving the nearest data point from a given coordinate on screen.
                                 *
                                 * ```ts
                                 *  // Example usage, from mouse move event.
                                 *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                                 *      const result = LineSeries.solveNearestFromScreen(event)
                                 *  })
                                 * ```
                                 *
                                 * ```ts
                                 *  // Example usage, arbitrary coordinate on client coordinate system.
                                 *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                                 * ```
                                 *
                                 * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                                 *
                                 * @param   location -  Location in HTML client coordinates.
                                 * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                                 * @public
                                 */
                                solveNearestFromScreen(location: CoordinateClient): undefined | CursorPoint;
                                /**
                                 * Abstract method that solves the nearest datapoint to a given coordinate on screen.
                                 * @param location - Location on screen
                                 * @returns Undefined or data-structure for positioning of cursors
                                 * @public
                                 * @deprecated  Deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                                 */
                                solveNearestFromScreen(location: Point): CursorPoint | undefined;
                                /**
                                 * Attach object to an legendBox entry
                                 * @param entry - Object which has to be attached
                                 * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
                                 *                          when its respective Entry is clicked.
                                 * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
                                 * @returns Series itself for fluent interface
                                 * @public
                                 */
                                attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
                            }
                            /**
                             * Interface for a function which builds ResultTable content when pointing at a {@link PolarHeatmapSeries}.
                             *
                             * ```ts
                             *  // Example
                             *  PolarHeatmapSeries.setCursorResultTableFormatter((builder, series, dataPoint, formatAmplitude) => builder
                             *      .addRow(series.getName())
                             *      .addRow('Angle:', '', `${dataPoint.angleDeg.toFixed(0)}`)
                             *      .addRow('Intensity:', '', `${dataPoint.intensity.toFixed(1)}`)
                             *  )
                             * ```
                             *
                             * @param tableContentBuilder - Builder that is used to build contents of ResultTable.
                             *                                  Use addRow() method for adding content.
                             * @param series - PolarSeries
                             * @param dataPoint - Pointed data point.
                             * @param formatAmplitude - Formatting function for similar formatting as Charts Amplitude Axis.
                             * @returns TableContentBuilder that was supplied
                             * @public
                             */
                            export declare type PolarHeatmapSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: PolarHeatmapSeries, dataPoint: {
                                angleDeg: number;
                                amplitude: number;
                                intensity: number;
                                iSector: number;
                                iAnnulus: number;
                            }, formatAmplitude: (amplitude: number) => string) => T;
                            /**
                             * Interface describing readonly configurations of a {@link PolarHeatmapSeries}.
                             *
                             * **Required properties:**
                             * - {@link sectors}
                             * - {@link annuli}
                             *
                             * **Optional properties:**
                             * - {@link amplitudeStart}
                             * - {@link amplitudeStep}
                             * - {@link amplitudeEnd}
                             * - {@link dataOrder}
                             * @public
                             */
                            export declare interface PolarHeatmapSeriesOptions {
                                /**
                                 * Amount of unique data samples along Radial Axis.
                                 *
                                 * There is no hard cap on how much data you can put into a polar heatmap, the limit is the running device's GPU memory.
                                 * Generally several million data points are no problem.
                                 */
                                sectors: number;
                                /**
                                 * Amount of unique data samples along Amplitude Axis.
                                 *
                                 * There is no hard cap on how much data you can put into a polar heatmap, the limit is the running device's GPU memory.
                                 * Generally several million data points are no problem.
                                 */
                                annuli: number;
                                /**
                                 * Amplitude value where Polar Heatmap originates at.
                                 *
                                 * Defaults to `0`.
                                 */
                                amplitudeStart?: number;
                                /**
                                 * Amplitude step between each ring (`annuli`) of the Polar Heatmap.
                                 *
                                 * Defaults to `0`.
                                 */
                                amplitudeStep?: number;
                                /**
                                 * Amplitude value where Polar Heatmap ends at.
                                 *
                                 * If both are defined, `amplitudeEnd` has priority over `amplitudeStep`.
                                 */
                                amplitudeEnd?: number;
                                /**
                                 * Select order of data.
                                 *
                                 * Determines whether new data is processed as list of "sectors" or "annuli".
                                 *
                                 * `'annuli'` -\> Supply lists of "annuli"
                                 *
                                 * ```typescript
                                 *  const intensityValues = [
                                 *      [
                                 *          0, // 1st ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise) = 0
                                 *          0, // 1st ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise) = 1
                                 *          0, // 1st ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise) = n
                                 *      ],
                                 *      [
                                 *          0, // 2nd ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise)
                                 *          0, // 2nd ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise)
                                 *          0, // 2nd ring counting from inner most, sector (starting at 0 deg, rotating counter clockwise)
                                 *      ],
                                 *  ]
                                 * ```
                                 *
                                 * `'sectors'` -\> Supply lists of "sectors"
                                 *
                                 * ```typescript
                                 *  const intensityValues = [
                                 *      [
                                 *          0, // 1st ring counting from inner most, sector 0 (starting at 0 deg, rotating counter clockwise)
                                 *          0, // 2nd ring counting from inner most, sector 0 (starting at 0 deg, rotating counter clockwise)
                                 *          0, // 3rd ring counting from inner most, sector 0 (starting at 0 deg, rotating counter clockwise)
                                 *      ],
                                 *      [
                                 *          0, // 1st ring counting from inner most, sector 1 (starting at 0 deg, rotating counter clockwise)
                                 *          0, // 2nd ring counting from inner most, sector 1 (starting at 0 deg, rotating counter clockwise)
                                 *          0, // 3rd ring counting from inner most, sector 1 (starting at 0 deg, rotating counter clockwise)
                                 *      ],
                                 *  ]
                                 * ```
                                 *
                                 * Defaults to `annuli`.
                                 */
                                dataOrder?: 'annuli' | 'sectors';
                            }
                            /**
                             * Type of *PolarSeries* for visualizing a collection of {@link PolarPoint | PolarPoints} by connecting them with a line.
                             *
                             * *PolarLineSeries* are created with {@link PolarChart.addLineSeries}.
                             *
                             * Set data with {@link PolarLineSeries.setData}:
                             *
                             * ```ts
                             *  PolarSeries.setData(
                             *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                             *          angle: i,
                             *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                             *      }))
                             *  )
                             * ```
                             * @public
                             */
                            export declare class PolarLineSeries extends PolarSeries<CursorPoint> implements Lined {
                                /**
                                 * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                                 *
                                 * ```typescript
                                 *  // Example usage
                                 *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                                 *      return tableBuilder
                                 *          .addRow(`Pointing at`, '', series.getName())
                                 *          .addRow(`Angle:`, '', angleDeg.toFixed(0) + ' deg')
                                 *          .addRow(`Amplitude:`, '', amplitude.toFixed(1))
                                 *  })
                                 * ```
                                 *
                                 * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                                 * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                                 *
                                 * ```typescript
                                 *  // Using TableContentBuilder.
                                 *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                                 *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                                 *      tableBuilder
                                 *          .addRow('Item 0:', '', 'Value 0')
                                 *          .addRow('Item 1:', '', 'Value 1')
                                 *          .addRow('Long row that highlights the idea of empty strings')
                                 *
                                 *      // After configuration, the table builder must be returned!
                                 *      return tableBuilder
                                 *  })
                                 * ```
                                 *
                                 * The additional values that are supplied to the callback function vary between different chart types,
                                 * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                                 * All `Polar Series` receive three extra parameters:
                                 * 1. `series` | reference to the series itself.
                                 * 2. `angleDeg` | pointed data point angle as degrees.
                                 * 3. `amplitude` | pointed data point amplitude.
                                 *
                                 * **Related API:**
                                 *
                                 * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                 * - {@link PolarChart.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                 *
                                 * @param formatter - Function which builds *ResultTable* content.
                                 * @returns Object itself
                                 * @public
                                 */
                                setCursorResultTableFormatter(formatter: PolarSeriesFormatter): this;
                                /**
                                 * Get ResultTable Formatter.
                                 * @returns Function which builds ResultTable content for SpiderSeries.
                                 * @public
                                 */
                                getCursorResultTableFormatter(): PolarSeriesFormatter;
                                /**
                                 * Set data for PolarSeries to render as a list of {@link PolarPoint}s.
                                 * @param points - List of {@link PolarPoint}s.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setData(points: PolarPoint[]): this;
                                /**
                                 * Set stroke style of Series.
                                 *
                                 * Supported line styles:
                                 * - {@link SolidLine}
                                 * - {@link DashedLine}
                                 * - {@link emptyLine}
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Specified LineStyle
                                 * PolarLineSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                 * // Changed thickness
                                 * PolarLineSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                 * // Hidden must be done with setVisible() method, emptyLine is not supported
                                 * ```
                                 * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
                                 * @returns Chart itself
                                 * @public
                                 */
                                setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                /**
                                 * Get stroke style of Series.
                                 * @returns LineStyle object
                                 * @public
                                 */
                                getStrokeStyle(): LineStyle;
                                /**
                                 * Set automatic connection of first and last data points enabled or not.
                                 *
                                 * **Disabled by default.**
                                 * @param enabled - Boolean.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setConnectDataAutomaticallyEnabled(enabled: boolean): this;
                                /**
                                 * Get automatic connection of first and last data points enabled or not.
                                 * @returns Boolean.
                                 * @public
                                 */
                                getConnectDataAutomaticallyEnabled(): boolean;
                                /**
                                 * Method for solving the nearest data point from a given coordinate on screen.
                                 *
                                 * ```ts
                                 *  // Example usage, from mouse move event.
                                 *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                                 *      const result = LineSeries.solveNearestFromScreen(event)
                                 *  })
                                 * ```
                                 *
                                 * ```ts
                                 *  // Example usage, arbitrary coordinate on client coordinate system.
                                 *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                                 * ```
                                 *
                                 * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                                 *
                                 * @param   location -  Location in HTML client coordinates.
                                 * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                                 * @public
                                 */
                                solveNearestFromScreen(location: CoordinateClient): undefined | CursorPoint;
                                /**
                                 * Abstract method that solves the nearest datapoint to a given coordinate on screen.
                                 * @param location - Location on screen
                                 * @returns Undefined or data-structure for positioning of cursors
                                 * @public
                                 * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                                 */
                                solveNearestFromScreen(location: Point): CursorPoint | undefined;
                                /**
                                 * Attach object to an legendBox entry
                                 * @param entry - Object which has to be attached
                                 * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
                                 *                          when its respective Entry is clicked.
                                 * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
                                 * @returns Series itself for fluent interface
                                 * @public
                                 */
                                attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
                            }
                            /**
                             * Interface that can be used to define {@link PolarChart} configurations, when inside a  {@link Dashboard},
                             * that can't be changed after creation.
                             *
                             *  Example usage:
                             *```javascript
                             * // Specified AutoCursor ResultTable Background
                             * { polarChartOptions: { autoCursorBuilder: AutoCursorBuilders.Polar.setResultTableBackground(UIBackgrounds.Circle) } }
                             * ```
                             * @public
                             */
                            export declare interface PolarOptions<CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, PolarChartOptions<CursorResultTableBackgroundType> {
                            }
                            /**
                             * Data-structure for describing a point in a Polar coordinate system.
                             *
                             * Used with {@link PolarChart} and *Polar series*.
                             * @public
                             */
                            export declare interface PolarPoint {
                                /**
                                 * Angle value in degrees [ 0, 360 ].
                                 * @public
                                 */
                                readonly angle: number;
                                /**
                                 * Amplitude value.
                                 * @public
                                 */
                                readonly amplitude: number;
                                /**
                                 * Optional point specific color.
                                 *
                                 * Usable with {@link PolarPointSeries} when styled with {@link IndividualPointFill}.
                                 * @public
                                 */
                                readonly color?: Color;
                            }
                            /**
                             * Type of *PolarSeries* for visualizing a collection of {@link PolarPoint | PolarPoints} by filling them with a specifiable {@link PointShape},
                             * as well as connecting them with a line.
                             *
                             * *PolarPointLineSeries* are created with {@link PolarChart.addPointLineSeries}.
                             *
                             * Set data with {@link PolarPointLineSeries.setData}:
                             *
                             * ```ts
                             *  PolarSeries.setData(
                             *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                             *          angle: i,
                             *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                             *      }))
                             *  )
                             * ```
                             * @public
                             */
                            export declare class PolarPointLineSeries extends PolarSeries<CursorPoint> implements Lined, Pointed {
                                /**
                                 * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                                 *
                                 * ```typescript
                                 *  // Example usage
                                 *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                                 *      return tableBuilder
                                 *          .addRow(`Pointing at`, '', series.getName())
                                 *          .addRow(`Angle:`, '', angleDeg.toFixed(0) + ' deg')
                                 *          .addRow(`Amplitude:`, '', amplitude.toFixed(1))
                                 *  })
                                 * ```
                                 *
                                 * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                                 * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                                 *
                                 * ```typescript
                                 *  // Using TableContentBuilder.
                                 *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                                 *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                                 *      tableBuilder
                                 *          .addRow('Item 0:', '', 'Value 0')
                                 *          .addRow('Item 1:', '', 'Value 1')
                                 *          .addRow('Long row that highlights the idea of empty strings')
                                 *
                                 *      // After configuration, the table builder must be returned!
                                 *      return tableBuilder
                                 *  })
                                 * ```
                                 *
                                 * The additional values that are supplied to the callback function vary between different chart types,
                                 * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                                 * All `Polar Series` receive three extra parameters:
                                 * 1. `series` | reference to the series itself.
                                 * 2. `angleDeg` | pointed data point angle as degrees.
                                 * 3. `amplitude` | pointed data point amplitude.
                                 *
                                 * **Related API:**
                                 *
                                 * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                 * - {@link PolarChart.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                 *
                                 * @param formatter - Function which builds *ResultTable* content.
                                 * @returns Object itself
                                 * @public
                                 */
                                setCursorResultTableFormatter(formatter: PolarSeriesFormatter): this;
                                /**
                                 * Get ResultTable Formatter.
                                 * @returns Function which builds ResultTable content for SpiderSeries.
                                 * @public
                                 */
                                getCursorResultTableFormatter(): PolarSeriesFormatter;
                                /**
                                 * Set data for `PolarPointSeries` to render as a list of {@link PolarPoint}s.
                                 * @param points - List of {@link PolarPoint}s.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setData(points: PolarPoint[]): this;
                                /**
                                 * Set stroke style of Series.
                                 *
                                 * Supported line styles:
                                 * - {@link SolidLine}
                                 * - {@link DashedLine}
                                 * - {@link emptyLine}
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Specified LineStyle
                                 * PolarLineSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                 * // Changed thickness
                                 * PolarLineSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                 * // Hidden must be done with setVisible() method, emptyLine is not supported
                                 * ```
                                 * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
                                 * @returns Chart itself
                                 * @public
                                 */
                                setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                /**
                                 * Get stroke style of Series.
                                 * @returns LineStyle object
                                 * @public
                                 */
                                getStrokeStyle(): LineStyle;
                                /**
                                 * Set point fill style of Series.
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Create a new style
                                 * PolarPointSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                 * // Change transparency
                                 * PolarPointSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
                                 * // Set hidden
                                 * PolarPointSeries.setPointFillStyle(emptyFill)
                                 * // Individual point style (required for using 'color' properties in data points)
                                 * PolarPointSeries.setPointFillStyle(new IndividualPointFill())
                                 *
                                 * ```
                                 * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                                 * @returns Series itself for fluent interface.
                                 * @public
                                 */
                                setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                /**
                                 * Get normal points fill style.
                                 * @returns Normal point fillStyle
                                 * @public
                                 */
                                getPointFillStyle(): FillStyle;
                                /**
                                 * Set size of point in pixels.
                                 * @param size - Size of point in pixels.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setPointSize(size: number): this;
                                /**
                                 * Get current size of points in pixels.
                                 * @returns Size of point in pixels.
                                 * @public
                                 */
                                getPointSize(): number;
                                /**
                                 * Set shape of points.
                                 * @param shape - One of {@link PointShape} options.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setPointShape(shape: PointShape): this;
                                /**
                                 * Get shape of points.
                                 * @returns PointShape
                                 * @public
                                 */
                                getPointShape(): PointShape;
                                /**
                                 * Set the rotation of points in degrees.
                                 * @param angle - Rotation angle in degrees
                                 * @public
                                 */
                                setPointRotation(angle: number): this;
                                /**
                                 * Get the current rotation of points.
                                 * @public
                                 */
                                getPointRotation(): number;
                                /**
                                 * Set automatic connection of first and last data points enabled or not.
                                 *
                                 * **Disabled by default.**
                                 * @param enabled - Boolean.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setConnectDataAutomaticallyEnabled(enabled: boolean): this;
                                /**
                                 * Get automatic connection of first and last data points enabled or not.
                                 * @returns Boolean.
                                 * @public
                                 */
                                getConnectDataAutomaticallyEnabled(): boolean;
                                /**
                                 * Method for solving the nearest data point from a given coordinate on screen.
                                 *
                                 * ```ts
                                 *  // Example usage, from mouse move event.
                                 *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                                 *      const result = LineSeries.solveNearestFromScreen(event)
                                 *  })
                                 * ```
                                 *
                                 * ```ts
                                 *  // Example usage, arbitrary coordinate on client coordinate system.
                                 *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                                 * ```
                                 *
                                 * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                                 *
                                 * @param   location -  Location in HTML client coordinates.
                                 * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                                 * @public
                                 */
                                solveNearestFromScreen(location: CoordinateClient): undefined | CursorPoint;
                                /**
                                 * Abstract method that solves the nearest datapoint to a given coordinate on screen.
                                 * @param location - Location on screen
                                 * @returns Undefined or data-structure for positioning of cursors
                                 * @public
                                 * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                                 */
                                solveNearestFromScreen(location: Point): CursorPoint | undefined;
                            }
                            /**
                             * Type of *PolarSeries* for visualizing a collection of {@link PolarPoint | PolarPoints} by filling them with a specifiable {@link PointShape}.
                             *
                             * *PointShape* can be configured with {@link PolarPointSeries.setPointShape}.
                             *
                             * *PolarPointSeries* are created with {@link PolarChart.addPointSeries}.
                             *
                             * Set data with {@link PolarPointSeries.setData}:
                             *
                             * ```ts
                             *  PolarSeries.setData(
                             *      new Array( 90 ).fill( 0 ).map(( _, i ) => ({
                             *          angle: i,
                             *          amplitude: 60 + 25 * Math.cos( 5 * i * Math.PI / 180 )
                             *      }))
                             *  )
                             * ```
                             * @public
                             */
                            export declare class PolarPointSeries extends PolarSeries<CursorPoint> implements Pointed {
                                /**
                                 * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                                 *
                                 * ```typescript
                                 *  // Example usage
                                 *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                                 *      return tableBuilder
                                 *          .addRow(`Pointing at`, '', series.getName())
                                 *          .addRow(`Angle:`, '', angleDeg.toFixed(0) + ' deg')
                                 *          .addRow(`Amplitude:`, '', amplitude.toFixed(1))
                                 *  })
                                 * ```
                                 *
                                 * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                                 * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                                 *
                                 * ```typescript
                                 *  // Using TableContentBuilder.
                                 *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                                 *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                                 *      tableBuilder
                                 *          .addRow('Item 0:', '', 'Value 0')
                                 *          .addRow('Item 1:', '', 'Value 1')
                                 *          .addRow('Long row that highlights the idea of empty strings')
                                 *
                                 *      // After configuration, the table builder must be returned!
                                 *      return tableBuilder
                                 *  })
                                 * ```
                                 *
                                 * The additional values that are supplied to the callback function vary between different chart types,
                                 * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                                 * All `Polar Series` receive three extra parameters:
                                 * 1. `series` | reference to the series itself.
                                 * 2. `angleDeg` | pointed data point angle as degrees.
                                 * 3. `amplitude` | pointed data point amplitude.
                                 *
                                 * **Related API:**
                                 *
                                 * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                 * - {@link PolarChart.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                 *
                                 * @param formatter - Function which builds *ResultTable* content.
                                 * @returns Object itself
                                 * @public
                                 */
                                setCursorResultTableFormatter(formatter: PolarSeriesFormatter): this;
                                /**
                                 * Get ResultTable Formatter.
                                 * @returns Function which builds ResultTable content for SpiderSeries.
                                 * @public
                                 */
                                getCursorResultTableFormatter(): PolarSeriesFormatter;
                                /**
                                 * Set data for PolarSeries to render as a list of {@link PolarPoint}s.
                                 * @param points - List of {@link PolarPoint}s.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setData(points: PolarPoint[]): this;
                                /**
                                 * Set point fill style of Series.
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Create a new style
                                 * PolarPointSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                 * // Change transparency
                                 * PolarPointSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
                                 * // Set hidden
                                 * PolarPointSeries.setPointFillStyle(emptyFill)
                                 * // Individual point style (required for using 'color' properties in data points)
                                 * PolarPointSeries.setPointFillStyle(new IndividualPointFill())
                                 *
                                 * ```
                                 * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                                 * @returns Series itself for fluent interface.
                                 * @public
                                 */
                                setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                /**
                                 * Get normal points fill style.
                                 * @returns Normal point fillStyle
                                 * @public
                                 */
                                getPointFillStyle(): FillStyle;
                                /**
                                 * Set size of point in pixels.
                                 * @param size - Size of point in pixels.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setPointSize(size: number): this;
                                /**
                                 * Get current size of points in pixels.
                                 * @returns Size of point in pixels.
                                 * @public
                                 */
                                getPointSize(): number;
                                /**
                                 * Set shape of points.
                                 * @param shape - One of {@link PointShape} options.
                                 * @returns Object itself for fluent interface.
                                 * @public
                                 */
                                setPointShape(shape: PointShape): this;
                                /**
                                 * Get shape of points.
                                 * @returns PointShape
                                 * @public
                                 */
                                getPointShape(): PointShape;
                                /**
                                 * Set the rotation of points in degrees.
                                 * @param angle - Rotation angle in degrees
                                 * @public
                                 */
                                setPointRotation(angle: number): this;
                                /**
                                 * Get the current rotation of points.
                                 * @public
                                 */
                                getPointRotation(): number;
                                /**
                                 * Method for solving the nearest data point from a given coordinate on screen.
                                 *
                                 * ```ts
                                 *  // Example usage, from mouse move event.
                                 *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                                 *      const result = LineSeries.solveNearestFromScreen(event)
                                 *  })
                                 * ```
                                 *
                                 * ```ts
                                 *  // Example usage, arbitrary coordinate on client coordinate system.
                                 *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                                 * ```
                                 *
                                 * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                                 *
                                 * @param   location -  Location in HTML client coordinates.
                                 * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                                 * @public
                                 */
                                solveNearestFromScreen(location: CoordinateClient): undefined | CursorPoint;
                                /**
                                 * Abstract method that solves the nearest datapoint to a given coordinate on screen.
                                 * @param location - Location on screen
                                 * @returns Undefined or data-structure for positioning of cursors
                                 * @public
                                 * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                                 */
                                solveNearestFromScreen(location: Point): CursorPoint | undefined;
                                /**
                                 * Attach object to an legendBox entry
                                 * @param entry - Object which has to be attached
                                 * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
                                 *                          when its respective Entry is clicked.
                                 * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
                                 * @returns Series itself for fluent interface
                                 * @public
                                 */
                                attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
                            }
                            /**
                             * Class that represents a single *polygon* from the collection of a {@link PolarPolygonSeries}.
                             *
                             * The geometry of the *polygon* can be mutated at any time.
                             *
                             * Note, that the style of *PolarPolygon*s is managed by the owning *PolarPolygonSeries*, to change the style, refer to the API of the Series.
                             *
                             * **Example usage:**
                             *
                             * ```ts
                             *  const polygonSeries = polarChart.addPolygonSeries()
                             *  let ang = 45
                             *  let amplitude = 50
                             *  const polygon = polygonSeries.addPolygon()
                             *      .setGeometry([
                             *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                             *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                             *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                             *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
                             *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                             *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
                             *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
                             *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                             *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                             *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                             *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
                             *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
                             *      ])
                             * ```
                             * @public
                             */
                            export declare class PolarPolygon implements HideableEvents {
                                /**
                                 * Set *polygon* geometry as a list of {@link PolarPoint}s.
                                 *
                                 * **NOTE: points have to be in either clockwise or counter-clockwise order**. The polygon coordinates should also not intersect with themselves.
                                 *
                                 * Example usage:
                                 * ```ts
                                 *  let ang = 45
                                 *  let amplitude = 50
                                 *  polarPolygon.setGeometry([
                                 *      { angle: (ang += 10), amplitude: (amplitude += 10) },
                                 *      { angle: (ang += 10), amplitude: (amplitude += 5) },
                                 *      { angle: (ang += 10), amplitude: (amplitude += 10) },
                                 *      { angle: (ang += 10), amplitude: (amplitude -= 5) },
                                 *      { angle: (ang += 10), amplitude: (amplitude += 5) },
                                 *      { angle: (ang += 5), amplitude: (amplitude -= 5) },
                                 *      { angle: (ang += 0), amplitude: (amplitude -= 10) },
                                 *      { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                                 *      { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                                 *      { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                                 *      { angle: (ang -= 10), amplitude: (amplitude += 5) },
                                 *      { angle: (ang -= 10), amplitude: (amplitude += 10) },
                                 * ])
                                 * ```
                                 * @param geometry - List of *PolarPoints* that form the contour of the desired polygon. Automatically closed.
                                 * @public
                                 */
                                setGeometry(geometry: PolarPoint[]): this;
                                /**
                                 * Get *polygon* geometry as a list of {@link PolarPoint}s.
                                 *
                                 * **NOTE: points have to be in either clockwise or counter-clockwise order**
                                 * @returns List of *PolarPoints* that form the contour of the desired polygon. Automatically closed.
                                 * @public
                                 */
                                getGeometry(): PolarPoint[] | undefined;
                                /**
                                 * Set mouse interactions enabled or disabled
                                 * @param state - Specifies state of mouse interactions
                                 * @returns Object itself for fluent interface
                                 * @public
                                 */
                                setMouseInteractions(state: boolean): this;
                                /**
                                 * **Permanently** destroy the component.
                                 *
                                 * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                 * **to the component and its children** in application code.
                                 * ```javascript
                                 * let chart = ...ChartXY()
                                 * let axisX = chart.getDefaultAxisX()
                                 * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                 * chart.dispose()
                                 * chart = undefined
                                 * axisX = undefined
                                 * ```
                                 * @returns Object itself for fluent interface
                                 * @public
                                 */
                                dispose(): this;
                                /**
                                 * Subscribe `onDispose` event.
                                 * This event is triggered whenever the Control (Dashboards and all chart types) is disposed.
                                 *
                                 * ```typescript
                                 *  // Example usage
                                 *
                                 * Chart.onDispose(() => {
                                 *   console.log('chert was disposed')
                                 * })
                                 *
                                 * Chart.dispose()
                                 * ```
                                 *
                                 * @param handler - Handler function for event
                                 * @returns Token of subscription
                                 * @public
                                 */
                                onDispose(handler: (object: this) => unknown): Token;
                                /**
                                 * Remove event listener from dispose event.
                                 * @param token - Token of event listener which has to be removed
                                 * @returns True if the listener is successfully removed and false if it is not found
                                 * @public
                                 */
                                offDispose(token: Token): boolean;
                                /**
                                 * Set element visibility.
                                 *
                                 * @param state - `true` when element should be visible and `false` when element should be hidden.
                                 * @returns Object itself.
                                 * @public
                                 */
                                setVisible(state: boolean): this;
                                /**
                                 * Get element visibility.
                                 *
                                 * @returns `true` when element is set to be visible and `false` otherwise.
                                 * @public
                                 */
                                getVisible(): boolean;
                                /**
                                 * Register new event listener to `visibleStateChanged` event.
                                 *
                                 * @param listener - Event listener for `visibleStateChanged`
                                 * @public
                                 */
                                onVisibleStateChanged(listener: VisibleStateChangedHandler<this>): Token;
                                /**
                                 * Remove event listener from `visibleStateChanged`
                                 * @public
                                 */
                                offVisibleStateChanged(token: Token): boolean;
                            }
                            /**
                             * Type of *PolarSeries* for visualizing a collection of *polygons* inside the Polar coordinate system. They are especially useful for highlighting parts of the Polar coordinate system.
                             *
                             * *PolarPolygonSeries* are created with {@link PolarChart.addPolygonSeries}.
                             *
                             * Create a {@link PolarPolygon} with {@link PolarPolygonSeries.addPolygon}.
                             *
                             * **Example usage:**
                             *
                             * ```ts
                             *  const polygonSeries = polarChart.addPolygonSeries()
                             *  let ang = 45
                             *  let amplitude = 50
                             *  const polygon = polygonSeries.addPolygon()
                             *      .setGeometry([
                             *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                             *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                             *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                             *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
                             *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                             *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
                             *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
                             *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                             *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                             *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                             *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
                             *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
                             *      ])
                             * ```
                             * @public
                             */
                            export declare class PolarPolygonSeries extends PolarSeries<PolarPolygonSeriesCursorPoint> {
                                /**
                                 * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                                 *
                                 * ```typescript
                                 *  // Example usage
                                 *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                                 *      return tableBuilder
                                 *          .addRow(`Pointing at`, '', series.getName())
                                 *          .addRow(`Angle:`, '', angleDeg.toFixed(0) + ' deg')
                                 *          .addRow(`Amplitude:`, '', amplitude.toFixed(1))
                                 *  })
                                 * ```
                                 *
                                 * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                                 * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                                 *
                                 * ```typescript
                                 *  // Using TableContentBuilder.
                                 *  PolarLineSeries.setCursorResultTableFormatter((tableBuilder, series, angleDeg, amplitude) => {
                                 *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                                 *      tableBuilder
                                 *          .addRow('Item 0:', '', 'Value 0')
                                 *          .addRow('Item 1:', '', 'Value 1')
                                 *          .addRow('Long row that highlights the idea of empty strings')
                                 *
                                 *      // After configuration, the table builder must be returned!
                                 *      return tableBuilder
                                 *  })
                                 * ```
                                 *
                                 * The additional values that are supplied to the callback function vary between different chart types,
                                 * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                                 * All `Polar Series` receive three extra parameters:
                                 * 1. `series` | reference to the series itself.
                                 * 2. `angleDeg` | pointed data point angle as degrees.
                                 * 3. `amplitude` | pointed data point amplitude.
                                 *
                                 * **Related API:**
                                 *
                                 * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                 * - {@link PolarChart.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                 *
                                 * @param formatter - Function which builds *ResultTable* content.
                                 * @returns Object itself
                                 * @public
                                 */
                                setCursorResultTableFormatter(formatter: PolarSeriesFormatter): this;
                                /**
                                 * Get ResultTable Formatter.
                                 * @returns Function which builds ResultTable content for SpiderSeries.
                                 * @public
                                 */
                                getCursorResultTableFormatter(): PolarSeriesFormatter;
                                /**
                                 * Create new *polygon* to the Series.
                                 *
                                 * The style of *polygons* is shared, and can be modified with the Series API: {@link PolarPolygonSeries.setFillStyle} and {@link PolarPolygonSeries.setStrokeStyle}.
                                 *
                                 * Specify the *polygon* geometry with {@link PolarPolygon.setGeometry}
                                 *
                                 * **Example usage:**
                                 *
                                 * ```ts
                                 *  const polygonSeries = polarChart.addPolygonSeries()
                                 *  let ang = 45
                                 *  let amplitude = 50
                                 *  const polygon = polygonSeries.addPolygon()
                                 *      .setGeometry([
                                 *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                                 *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                                 *          { angle: (ang += 10), amplitude: (amplitude += 10) },
                                 *          { angle: (ang += 10), amplitude: (amplitude -= 5) },
                                 *          { angle: (ang += 10), amplitude: (amplitude += 5) },
                                 *          { angle: (ang += 5), amplitude: (amplitude -= 5) },
                                 *          { angle: (ang += 0), amplitude: (amplitude -= 10) },
                                 *          { angle: (ang -= 5), amplitude: (amplitude -= 5) },
                                 *          { angle: (ang -= 10), amplitude: (amplitude -= 10) },
                                 *          { angle: (ang -= 10), amplitude: (amplitude -= 5) },
                                 *          { angle: (ang -= 10), amplitude: (amplitude += 5) },
                                 *          { angle: (ang -= 10), amplitude: (amplitude += 10) },
                                 *      ])
                                 * ```
                                 * @returns {@link PolarPolygon}
                                     * @public
                                     */
                                 addPolygon(): PolarPolygon;
                                 /**
                                  * Set fill style of Series.
                                  *
                                  * Example usage:
                                  *```javascript
                                  * // Create a new style
                                  * PolarPolygonSeries.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                  * // Change transparency
                                  * PolarPolygonSeries.setFillStyle((solidFill) => solidFill.setA(80))
                                  * // Set hidden
                                  * PolarPolygonSeries.setFillStyle(emptyFill)
                                  * ```
                                  * @param value - Either a FillStyle object or a function, which will be used to create a new LineStyle based on current value.
                                  * @returns Chart itself
                                  * @public
                                  */
                                 setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                 /**
                                  * Get fill style of Series.
                                  * @returns FillStyle object
                                  * @public
                                  */
                                 getFillStyle(): FillStyle;
                                 /**
                                  * Set stroke style of Series.
                                  *
                                  * Supported line styles:
                                  * - {@link SolidLine}
                                  * - {@link emptyLine}
                                  *
                                  * Example usage:
                                  *```javascript
                                  * // Specified LineStyle
                                  * PolarPolygonSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                  * // Changed thickness
                                  * PolarPolygonSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                  * // Hidden
                                  * PolarPolygonSeries.setStrokeStyle(emptyLine)
                                  * ```
                                  * @param value - Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
                                  * @returns Chart itself
                                  * @public
                                  */
                                 setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                 /**
                                  * Get stroke style of Series.
                                  * @returns LineStyle object
                                  * @public
                                  */
                                 getStrokeStyle(): LineStyle;
                                 /**
                                  * Method for solving the nearest data point from a given coordinate on screen.
                                  *
                                  * ```ts
                                  *  // Example usage, from mouse move event.
                                  *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                                  *      const result = LineSeries.solveNearestFromScreen(event)
                                  *  })
                                  * ```
                                  *
                                  * ```ts
                                  *  // Example usage, arbitrary coordinate on client coordinate system.
                                  *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                                  * ```
                                  *
                                  * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                                  *
                                  * @param   location -  Location in HTML client coordinates.
                                  * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                                  * @public
                                  */
                                 solveNearestFromScreen(location: CoordinateClient): undefined | PolarPolygonSeriesCursorPoint;
                                 /**
                                  * Abstract method that solves the nearest datapoint to a given coordinate on screen.
                                  * @param location - Location on screen
                                  * @returns Undefined or data-structure for positioning of cursors
                                  * @public
                                  * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                                  */
                                 solveNearestFromScreen(location: Point): PolarPolygonSeriesCursorPoint | undefined;
                                 /**
                                  * Attach object to an legendBox entry
                                  * @param entry - Object which has to be attached
                                  * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
                                  *                          when its respective Entry is clicked.
                                  * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
                                  * @returns Series itself for fluent interface
                                  * @public
                                  */
                                 attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
                                }
                                /**
                                 * Interface that is used to point a Cursor to a specific data-point of a {@link PolarPolygonSeries}.
                                 * @public
                                 */
                                export declare interface PolarPolygonSeriesCursorPoint extends CursorPoint {
                                    /**
                                     * {@link PolarPolygon} that the data point belongs to.
                                     * @public
                                     */
                                    polarPolygon: PolarPolygon;
                                }
                                /**
                                 * Highlighter component that lives under {@link PolarChart}.
                                 *
                                 * Can be used to highlight sectors in the *polar coordinate* system,
                                 * specified by four values:
                                 * - **start angle**
                                 * - **end angle**
                                 * - **start amplitude**
                                 * - **end amplitude**
                                 *
                                 * Created with {@link PolarChart.addSector}.
                                 * @public
                                 */
                                export declare class PolarSector extends ChartComponent {
                                    /**
                                     * Set Sectors start angle in degrees.
                                     * @param angleStart - Start angle in degrees, restricted to [0, 360].
                                     *                      This doesn't have to be less than angle end value.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAngleStart(angleStart: number): this;
                                    /**
                                     * Get Sectors start angle in degrees.
                                     * @returns Start angle  in degrees, restricted to [0, 360].
                                     *                      This doesn't have to be less than angle end value.
                                     * @public
                                     */
                                    getAngleStart(): number;
                                    /**
                                     * Set Sectors end angle in degrees.
                                     * @param angleEnd - End angle in degrees, restricted to [0, 360].
                                     *                      This doesn't have to be greater than angle start value.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAngleEnd(angleEnd: number): this;
                                    /**
                                     * Get Sectors end angle in degrees.
                                     * @returns End angle in degrees, restricted to [0, 360].
                                     *                      This doesn't have to be greater than angle start value.
                                     * @public
                                     */
                                    getAngleEnd(): number;
                                    /**
                                     * Set Sectors start amplitude.
                                     * @param amplitudeStart - Start amplitude. Setting to *undefined* results in tracking the *PolarAxes* start value.
                                     *                          This doesn't have to be less than amplitude end value.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAmplitudeStart(amplitudeStart: number): this;
                                    /**
                                     * Get Sectors start amplitude.
                                     * @returns Start amplitude. Setting to *undefined* results in tracking the *PolarAxes* start value.
                                     *                      This doesn't have to be less than amplitude end value.
                                     * @public
                                     */
                                    getAmplitudeStart(): number | undefined;
                                    /**
                                     * Set Sectors end amplitude.
                                     * @param amplitudeEnd - End amplitude. Setting to *undefined* results in tracking the *PolarAxes* end value.
                                     *                      This doesn't have to be greater than amplitude start value.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAmplitudeEnd(amplitudeEnd: number | undefined): this;
                                    /**
                                     * Get Sectors end amplitude.
                                     * @returns End amplitude. Setting to *undefined* results in tracking the *PolarAxes* end value.
                                     *                      This doesn't have to be greater than amplitude start value.
                                     * @public
                                     */
                                    getAmplitudeEnd(): number | undefined;
                                    /**
                                     * Set Fill Style of Sector.
                                     *
                                     * Example use:
                                     *
                                     * ```javascript
                                     * // Create a new style
                                     * PolarSector.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                     * // Change transparency
                                     * PolarSector.setFillStyle((solidFill) => solidFill.setA(80))
                                     * // Set hidden
                                     * PolarSector.setFillStyle(emptyFill)
                                     * ```
                                     *
                                     * @param value - FillStyle object or function which mutates existing value.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get Fill Style of Sector.
                                     * @returns FillStyle
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stroke style of PolarSector.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Specified SolidLine
                                     * PolarSector.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                     * // Changed thickness
                                     * PolarSector.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                     * // Hidden
                                     * PolarSector.setStrokeStyle(emptyLine)
                                     * ```
                                     * @param value - Either a LineStyle object or a function, which will be used to create a new SolidLine based on current value.
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of PolarSector.
                                     * @returns Normal StrokeStyle
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Attach object to an legendBox entry
                                     * @param entry - Object which has to be attached
                                     * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
                                     *                          when its respective Entry is clicked.
                                     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
                                     * @returns Series itself for fluent interface
                                     * @public
                                     */
                                    attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
                                }
                                /**
                                 * Abstract super class for all PolarSeries.
                                 * @public
                                 */
                                export declare abstract class PolarSeries<CursorPointInterface extends CursorPoint = CursorPoint> extends Series2D<CursorPointInterface> {
                                    /**
                                     * Scale of the series
                                     * @public
                                     */
                                    readonly scale: RadialScale;
                                    /**
                                     * Get min amplitude value of PolarSeries' data points.
                                     * @returns number or undefined if no data is set.
                                     * @public
                                     */
                                    getAmplitudeMin(): number | undefined;
                                    /**
                                     * Get max amplitude value of PolarSeries' data points.
                                     * @returns number or undefined if no data is set.
                                     * @public
                                     */
                                    getAmplitudeMax(): number | undefined;
                                }
                                /**
                                 * Interface for a function which builds ResultTable content when pointing at a PolarSeries.
                                 * @param tableContentBuilder - Builder that is used to build contents of ResultTable.
                                 *                                  Use addRow() method for adding content.
                                 * @param series - PolarSeries
                                 * @param angleDeg - Angle of data point as degrees
                                 * @param amplitude - Amplitude of data point
                                 * @param formatAmplitude - Formating function for similar formatting as Charts Amplitude Axis.
                                 * @returns TableContentBuilder that was supplied
                                 * @public
                                 */
                                export declare type PolarSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: PolarSeries, angleDeg: number, amplitude: number, formatAmplitude: (amplitude: number) => string) => T;
                                /**
                                 * Class for series visual that is a Polygon.
                                 * @public
                                 */
                                export declare class PolygonFigure extends Figure {
                                    /**
                                     * @public
                                     */
                                    readonly scale: LinearScaleXY;
                                    /**
                                     * Get boundaries that contain figure.
                                     * @returns Interval<Point>
                                     * @public
                                     */
                                    getBoundaries(): Interval<Point>;
                                    /**
                                     * Set new dimensions for figure.
                                     * @param polygonCoordinates - List of polygon coordinates
                                     * @returns Object itself
                                     * @remarks                  Owning series will be informed of change in size, possibly initiating scrolling.
                                     * @public
                                     */
                                    setDimensions(polygonCoordinates: Point[]): this;
                                    /**
                                     * Get current dimensions of figure as list of polygon coordinates.
                                     * @returns List of Polygon coordinates.
                                     * @public
                                     */
                                    getDimensions(): Point[];
                                    /**
                                     * Set fill style of Polygon.
                                     * @param value - FillStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Polygon.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stroke style of Polygon.
                                     *
                                     * Supported line styles:
                                     * - {@link SolidLine}
                                     * - {@link emptyLine}
                                     *
                                     * @param value - LineStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of Polygon.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Return some dominant fill style of the figure
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getDominantStyle(): FillStyle;
                                }
                                /**
                                 * Series that lets user draw Polygon with independent figures.
                                 * @public
                                 */
                                export declare class PolygonSeries extends FigureSeries<PolygonFigure, Point[], LinearScaleXY> {
                                    /**
                                     * Add new figure to the series.
                                     * @param dimensions - Dimensions that figure must represent
                                     * @returns Created figure
                                     * @public
                                     */
                                    add(dimensions: Point[]): PolygonFigure;
                                    /**
                                     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                                     *
                                     * ```typescript
                                     *  // Example usage
                                     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
                                     *      const rectangleDimensions = figure.getDimensionsTwoPoints()
                                     *      return tableBuilder
                                     *          .addRow(`Pointing at`, '', series.getName())
                                     *          .addRow(`X1:`, '', rectangleDimensions.x1)
                                     *          .addRow(`X2:`, '', rectangleDimensions.x2)
                                     *          .addRow(`Y1:`, '', rectangleDimensions.y1)
                                     *          .addRow(`Y2:`, '', rectangleDimensions.y2)
                                     *  })
                                     * ```
                                     *
                                     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                                     * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                                     *
                                     * ```typescript
                                     *  // Using TableContentBuilder.
                                     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
                                     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                                     *      tableBuilder
                                     *          .addRow('Item 0:', '', 'Value 0')
                                     *          .addRow('Item 1:', '', 'Value 1')
                                     *          .addRow('Long row that highlights the idea of empty strings')
                                     *
                                     *      // After configuration, the table builder must be returned!
                                     *      return tableBuilder
                                     *  })
                                     * ```
                                     *
                                     * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
                                     *
                                     * The additional values that are supplied to the callback function vary between different chart types,
                                     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                                     * `Figure Series` receive two extra parameters:
                                     * 1. `series` | reference to the series itself.
                                     * 2. `figure` | reference to the pointed *figure*.
                                     * This type is **generic** - for example, for `RectangleSeries` it is of type `RectangleFigure`.
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     *
                                     * @param formatter - Function which builds *ResultTable* content.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setCursorResultTableFormatter(formatter: FigureSeriesFormatter<PolygonFigure, PolygonSeries>): this;
                                    /**
                                     * Get ResultTable Formatter.
                                     * @returns Function which builds ResultTable content for the Series.
                                     * @public
                                     */
                                    getCursorResultTableFormatter(): FigureSeriesFormatter<PolygonFigure, PolygonSeries>;
                                }
                                /**
                                 * Interface for supplying readonly configurations to a {@link PolygonSeries}.
                                 * @public
                                 */
                                export declare interface PolygonSeriesOptions extends SeriesOptionsXY {
                                }
                                /**
                                 * Interface for end user API of the LCJS engine.
                                 * It provides some useful capabilities over the area enclosed by a single LCJS context (which can be just a single chart, or a Dashboard with several charts).
                                 *
                                 * **Commonly used properties:**
                                 *
                                 * - [layout]({@link PublicEngine.layout}): Trigger resizing of charts.
                                 * - [captureFrame]({@link PublicEngine.captureFrame}): Take a screenshot of charts.
                                 * - [scale]({@link PublicEngine.scale}): Coordinate system that encloses entire LCJS context in pixels starting from bottom left.
                                 * - [clientLocation2Engine]({@link PublicEngine.clientLocation2Engine}): Translate web page coordinate to LCJS engine coordinate.
                                 * - [engineLocation2Client]({@link PublicEngine.engineLocation2Client}): Translate LCJS engine coordinate to web page coordinate.
                                 * @public
                                 */
                                export declare interface PublicEngine {
                                    /**
                                     * HTML Div element that contains the rendering Engine.
                                     * @public
                                     */
                                    container: HTMLDivElement;
                                    /**
                                     * Coordinate system that encloses entire LCJS context in pixels starting from bottom left.
                                     *
                                     * Referenced usually by `chart.engine.scale`.
                                     *
                                     * The _engine scale_ is used as an intermediary step when translating locations from the web page into LCJS coordinates, or vice versa.
                                     *
                                     * See {@link clientLocation2Engine} for translating web page coordinate to `engine.scale` and
                                     * {@link engineLocation2Client} for translating `engine.scale` coordinate to web page.
                                     *
                                     * To further translate a location on `engine.scale` to another coordinate system, like _axis_, use {@link translatePoint} function.
                                     *
                                     * This feature is extremely powerful since it allows combining of LCJS and HTML/CSS or any web UI framework.
                                     * @public
                                     * @deprecated  Deprecated since v4.2.0. See {@link Control.translateCoordinate} for newer syntax of coordinate translations, and {@link Control.coordsRelative} for positioning LCJS UI elements in pixels.
                                     */
                                    scale: LinearScaleXY;
                                    /**
                                     * Set Mouse style.
                                     * @param presetName - Name of a Mouse preset in js.
                                     * @param existingKey - Key for existing request to refresh
                                     * @returns Key that can be used to restore Mouse style
                                     * @public
                                     */
                                    setMouseStyle: (presetName: string, existingKey?: number) => number;
                                    /**
                                     * Restore Mouse style.
                                     * @param key - Key generated using 'setMouseStyle'
                                     * @public
                                     */
                                    restoreMouseStyle: (key?: number) => void;
                                    /**
                                     * Translates a coordinate on the web page (for example, `MouseEvent.clientX`, `MouseEvent.clientY`) that originates from browser top-left,
                                     * to {@link PublicEngine.scale}.
                                     *
                                     * ```js
                                     *  // Example usage, listen to chartXY background mouse move and console the location on default axis.
                                     *  chart.onSeriesBackgroundMouseMove((_, event) => {
                                     *      // Translate mouse location to LCJS coordinate system for solving data points from series, and translating to Axes.
                                     *      const mouseLocationEngine = chart.engine.clientLocation2Engine(
                                     *          event.clientX,
                                     *          event.clientY
                                     *      );
                                     *
                                     *      // Translate LCJS coordinate to default chart axes.
                                     *      const mouseLocationAxis = translatePoint(mouseLocationEngine, chart.engine.scale, { x: chart.getDefaultAxisX(), y: chart.getDefaultAxisY() })
                                     *      console.log('axis', mouseLocationAxis)
                                     *  })
                                     * ```
                                     *
                                     * To further translate a location on `engine.scale` to another coordinate system, like _axis_, use {@link translatePoint} function.
                                     *
                                     * This feature is extremely powerful since it allows combining of LCJS and HTML/CSS or any web UI framework.
                                     *
                                     * @param x - Location of X in browser
                                     * @param y - Location of Y in browser
                                     * @returns Respective coordinate on `engine.scale`
                                     * @public
                                     * @deprecated  Deprecated since v4.2.0. See {@link Control.translateCoordinate} for newer syntax of coordinate translations
                                     */
                                    clientLocation2Engine(x: number, y: number): Point;
                                    /**
                                     * Translates a coordinate on `engine.scale` that originates from LCJS bottom-left to respective location on the web page currently.
                                     *
                                     * This coordinate can, for example, be used with absolute CSS positioning:
                                     *
                                     * ```
                                     *  // Example usage, absolute position a HTML element on a coordinate along two LCJS Axes.
                                     *  const element = document.createElement('span')
                                     *  chart.engine.container.append(element)
                                     *  element.style.position = 'absolute'
                                     *  element.style.display = 'block'
                                     *  element.innerHTML = 'hello'
                                     *  element.style.color = 'red'
                                     *
                                     *  const repositionElement = () => {
                                     *      // Position HTML element with CSS by translating LCJS Axis location to web page.
                                     *      const locationAxis = { x: chart.getDefaultAxisX().getInterval().start, y: chart.getDefaultAxisY().getInterval().end }
                                     *      const locationEngine = translatePoint(locationAxis, { x: chart.getDefaultAxisX(), y: chart.getDefaultAxisY() }, chart.engine.scale)
                                     *      const locationDocument = chart.engine.engineLocation2Client(locationEngine.x, locationEngine.y)
                                     *      element.style.left = `${locationDocument.x}px`
                                     *      element.style.top = `${locationDocument.y}px`
                                     *  }
                                     *
                                     *  // NOTE: Axis -> Document translation is invalid if one of many things changes:
                                     *  // 1. Axis interval, style or ticks change.
                                     *  // 2. Web page is scrolled, zoomed or resized.
                                     *  // 3. Dashboard splitter is resized.
                                     *  // In this example, the element is repositioned continuously, which might not always be for the best.
                                     *  setInterval(repositionElement)
                                     * ```
                                     *
                                     * This feature is extremely powerful since it allows combining of LCJS and HTML/CSS or any web UI framework.
                                     *
                                     * @param x - Location of X in engine
                                     * @param y - Location of Y in engine
                                     * @public
                                     * @deprecated  Deprecated since v4.2.0. See {@link Control.translateCoordinate} for newer syntax of coordinate translations
                                     */
                                    engineLocation2Client(x: number, y: number): Point;
                                    /**
                                     * Capture state of rendering Engines canvas. Returns the captured image as a Blob-object.
                                     *
                                     * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL:
                                     *
                                     * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
                                     *
                                     * @param type - A DOMString indicating the image format. The default format type is image/png.
                                     * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
                                     *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
                                     *                          the default value for image quality is used. The default value is 0.92. Other arguments are ignored.
                                     * @param asDataUrl - Return the captured frame as data url instead of as a Blob.
                                     * @returns JavaScript Blob whose 'type' depends on what was passed to 'type' parameter of this method. Or as a [data url](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs) if the `asDataUrl` option was set to `true`
                                     *          Defaults to image/png
                                     * @public
                                     */
                                    captureFrame(type?: string, encoderOptions?: number): Blob;
                                    captureFrame(type?: string, encoderOptions?: number, asDataUrl?: boolean): Blob | string;
                                    /**
                                     * Render a frame of specific size to a ArrayBuffer.
                                     *
                                     * Mainly for Node JS usage. In browser the chart itself will not be resized correctly.
                                     * @param width - Horizontal resolution
                                     * @param height - Vertical resolution
                                     * @param noFlip - Leave the image upside down
                                     * @public
                                     */
                                    renderFrame(width: number, height: number, noFlip?: boolean): Uint8Array;
                                    /**
                                     * Calculate the layout again. This should be called when the container of chart is resized.
                                     *
                                     * ```js
                                     *  // Example syntax, trigger chart resize on user event.
                                     *  myResizeEventCallback(() => {
                                     *      // Trigger chart resize manually.
                                     *      chart.engine.layout()
                                     *  })
                                     * ```
                                     * @public
                                     */
                                    layout(): void;
                                    /**
                                     * Set Fill Style of engine background.
                                     *
                                     * Every LCJS component has an Engine background under it. In case of Dashboard, there is only 1 shared engine background.
                                     *
                                     * **Transparent chart backgrounds:**
                                     *
                                     * LightningChart JS charts can be configured to be fully or partially transparent.
                                     *
                                     * ```ts
                                     *  // Example, partially transparent chart
                                     *
                                     *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
                                     *  chart.engine.setBackgroundFillStyle(emptyFill)
                                     *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
                                     *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                                     *  // Some charts also have a separate series background.
                                     *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                                     * ```
                                     *
                                     * @param fillStyle - FillStyle or mutator to modify existing one.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setBackgroundFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get Fill Style of engine background.
                                     * @returns FillStyle
                                     * @public
                                     */
                                    getBackgroundFillStyle(): FillStyle;
                                    /**
                                     * Set Stroke Style of engine background.
                                     * @param value - LineStyle
                                     * @returns Object itself
                                     * @public
                                     */
                                    setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get Stroke Style of engine background.
                                     * @returns LineStyle
                                     * @public
                                     */
                                    getBackgroundStrokeStyle(): LineStyle;
                                    /**
                                     * Register a custom Icon that can be used within the engine (all charts, panels, series, etc. using the same engine).
                                     *
                                     * Note that currently the _Icon_ concept is not widely supported, and can only be used with the {@link DataGrid} feature as cell content.
                                     * In the future, Icons will be more widely utilizable, for example in Legends, Cursors and UI elements.
                                     *
                                     * ```ts
                                     *  // Example, load a custom icon.
                                     *  const img = new Image()
                                     *  img.src = `my-icon-url.jpg`
                                     *  const icon = chart.engine.addCustomIcon(img, {})
                                     * ```
                                     *
                                     * Icon properties can be supplied with the optional second parameter.
                                     * For all available options, see {@link IconProperties}.
                                     *
                                     * ```ts
                                     *  // Example, specify icon width as pixels and maintain source aspect ratio.
                                     *  const icon = chart.engine.addCustomIcon(img, { width: 32 })
                                     * ```
                                     *
                                     * Icon properties can also be adjusted using setter methods on an existing `Icon` object.
                                     * **All setters return a new Icon object, leaving the original Icon unmodified!**
                                     *
                                     * ```ts
                                     *  // Example, make a second Icon object by adjusting an existing one.
                                     *  const icon2 = icon.setSize(16, 24)
                                     * ```
                                     *
                                     * When a custom icon is no longer needed, it is recommended to inform the engine by _disposing_ the Icon:
                                     *
                                     * ```ts
                                     *  // Example, inform engine that an Icon is no longer needed.
                                     *  icon.dispose()
                                     * ```
                                     *
                                     * @param   source - Graphics source for the Icon.
                                     * @param   opts   - Optional properties for configuring the Icon.
                                     * @returns          Icon object.
                                     * @public
                                     */
                                    addCustomIcon(source: ImageFillSource, opts?: Partial<IconProperties>): Icon;
                                }
                                /**
                                 * Abstract base class for *Pyramid Charts*.
                                 * Visualizes proportions and percentages between categories, by dividing a pyramid into proportional segments.
                                 *
                                 * Set data using *PyramidChart*.**addSlice( name: string, value: number )**
                                 *
                                 * There are multiple implementations of *PyramidChart*, each with their own visual design and *API* for customizing it.
                                 * List of selectable options can be found in: {@link PyramidChartTypes}
                                 * @public
                                 */
                                export declare abstract class PyramidChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends Chart implements SlicedCharts<PyramidSlice>, ChartWithCursor<CursorResultTableBackgroundType> {
                                    /**
                                     * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
                                     *
                                     * **Example usage:**
                                     *
                                     * ```typescript
                                     *  // Example 1, style AutoCursor ResultTable.
                                     *  PyramidChart.setAutoCursor((autoCursor) => autoCursor
                                     *      .setResultTable((resultTable) => resultTable
                                     *          .setOrigin(UIOrigins.LeftTop)
                                     *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                     *          .setTextFont((font) => font
                                     *              .setSize(12)
                                     *              .setFamily('sans-serif')
                                     *          )
                                     *          .setBackground((background) => background
                                     *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
                                     *          )
                                     *      )
                                     *  )
                                     * ```
                                     *
                                     * ```typescript
                                     *  // Example 2, style AutoCursor PointMarker.
                                     *  PyramidChart.setAutoCursor((autoCursor) => autoCursor
                                     *      .setPointMarker((marker) => marker
                                     *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                     *          .setSize({ x: 10, y: 10 })
                                     *          .setStrokeStyle(emptyLine),
                                     *      ),
                                     *  )
                                     * ```
                                     * @param mutator - Callback function that receives reference to the charts `AutoCursor`.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAutoCursor(mutator: Mutator<AutoCursor<CursorResultTableBackgroundType>>): this;
                                    /**
                                     * Get reference to charts `AutoCursor`.
                                     *
                                     * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
                                     *
                                     * @returns `AutoCursor`.
                                     * @public
                                     */
                                    getAutoCursor(): AutoCursor<CursorResultTableBackgroundType>;
                                    /**
                                     * Set chart `AutoCursor` behavior, by selecting a preset option from {@link AutoCursorModes}.
                                     *
                                     * Possible values:
                                     * - `AutoCursorModes.snapToClosest` (default) | *AutoCursor* snaps to closest data point from mouse location.
                                     * - `AutoCursorModes.onHover` | *AutoCursor* is only shown when it is directly over a *series*. NOTE: Series mouse interactions must be enabled for this to work!
                                     * - `AutoCursorModes.disabled` | *AutoCursor* is disabled
                                     *
                                     * ```typescript
                                     *  // Example, disable AutoCursor
                                     *  PyramidChart.setAutoCursorMode(AutoCursorModes.disabled)
                                     * ```
                                     *
                                     * **Related information:**
                                     *
                                     * On *series* level, *AutoCursor* behavior can be configured individually for each *series*, and there are also more *series* specific options available.
                                     * Here is `LineSeries` for example:
                                     *
                                     * - {@link Series2D.setCursorEnabled} | configure whether cursor should pick on the series or not.
                                     * - {@link SeriesXY.setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                                     * - {@link LineSeries.setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
                                     * - {@link SeriesXY.setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
                                     *
                                     * @param mode - Selection of *AutoCursor* behavior.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAutoCursorMode(mode: AutoCursorModes): this;
                                    /**
                                     * Get `AutoCursor` behavior, from a collection of preset options ({@link AutoCursorModes}).
                                     * @returns Active selection of *AutoCursor* behavior.
                                     * @public
                                     */
                                    getAutoCursorMode(): AutoCursorModes;
                                    /**
                                     * Set *ResultTable* formatter. Can be used to specify the information that is displayed, when hovering mouse/pointer
                                     * over the chart.
                                     *
                                     * ```ts
                                     *  // Example usage
                                     *  PyramidChart.setCursorResultTableFormatter((builder, chart, slice, relativeValue) => builder
                                     *      .addRow(slice.getName())
                                     *      .addRow(slice.getAnimatedValue().toFixed(2))
                                     *  )
                                     * ```
                                     *
                                     * @param formatter - Function which builds ResultTable content.
                                     *                      See definition of {@link SlicedChartResultTableFormatter} for supplied formatting information.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setCursorResultTableFormatter(formatter: SlicedChartResultTableFormatter): this;
                                    /**
                                     * This method is used for the adding slices in the pyramid chart.
                                     * @param title - Pyramid slice title
                                     * @param value - pyramid slice value
                                     * @public
                                     */
                                    addSlice(title: string, value: number): PyramidSlice;
                                    /**
                                     * This method is used for the adding multiple slices in the pyramid chart.
                                     * @param slices - Array of slices
                                     * @public
                                     */
                                    addSlices(slices: {
                                        name: string;
                                        value: number;
                                    }[]): Array<PyramidSlice>;
                                    /**
                                     * Get all Slices of Pyramid Chart.
                                     * NOTE: Manual modifications to returned Array can have unforeseen side-effects.
                                     * Removing or adding Slices is intended to be done using other APIs (PyramidChart.addSlice, Slice.dispose, ...)
                                     * @returns Array of Slices
                                     * @public
                                     */
                                    getSlices(): PyramidSlice[];
                                    /**
                                     * Set Pyramid Neck Width
                                     * @param neckWidth - Pyramid Neck Width range from 0 to 100
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setNeckWidth(neckWidth: number): this;
                                    /**
                                     * Get Pyramid Neck Width
                                     * @returns number (0 - 100)
                                     * @public
                                     */
                                    getNeckWidth(): number;
                                    /**
                                     * Set gap between Slice / start of label connector, and end of label connector / Label.
                                     * @param sliceGap - Gap as pixels. Clamped between [0, 20] !
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setSliceGap(sliceGap: pixel): this;
                                    /**
                                     * Set PyramidSliceMode. Can be used to select between different drawing approaches for Slices.
                                     *
                                     * See {@link PyramidSliceModes} for a collection of options.
                                     * @param sliceMode - PyramidSliceMode
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setSliceMode(sliceMode: PyramidSliceModes): this;
                                    /**
                                     * Get PyramidSliceMode. Can be used to select between different drawing approaches for Slices.
                                     *
                                     * See {@link PyramidSliceModes} for a collection of options.
                                     * @returns PyramidSliceMode
                                     * @public
                                     */
                                    getPyramidSliceMode(): PyramidSliceModes;
                                    /**
                                     * Attach lookup table (LUT) to fill the slices with Colors based on value.
                                     *
                                     * The color for the slice would be selected from a specified *LUT*, which contains the information about gradient steps.
                                     * After setting LUT to undefined all the slices stay colorized, but no further lookup.
                                     *
                                     * LUT class stores information about values and its associated colors,
                                     * * which provides efficient lookup of the color based on provided value
                                     * * as well as linear and step interpolation between colors.
                                     *
                                     * ``` javascript
                                     * const pyramid = lightningChart()
                                     *  .Pyramid( { type: PyramidChartTypes.LabelsOnSides } )
                                     *  .setLUT( new LUT (steps: [
                                     *          { value: 10, color: ColorRGBA( 0, 0, 0 ) },
                                     *          { value: 20, color: ColorRGBA( 30, 255, 0 ) },
                                     *          { value: 30, color: ColorRGBA( 60, 204, 0 ) },
                                     *          { value: 40, color: ColorRGBA( 90, 128, 0 ) },
                                     *          { value: 50, color: ColorRGBA( 255, 0, 0 ) } ) ],
                                     *      interpolate: true } )
                                     * ```
                                     * @param value - Lookup table
                                     * @returns Pyramid itself for fluent interface
                                     * @public
                                     */
                                    setLUT(value: LUT): this;
                                    /**
                                     * Set style of Pyramid Slices fill.
                                     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pyramid will be assigned an incremental index,
                                     * which will be used to pick its fill style from this Palette.
                                     *
                                     * So, for example... We have a Pyramid Chart with 5 Slices, and we give it a Palette with only 3 possible values
                                     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                                     * Note that this means, that the supplied Palette will have to work in a continuous manner!
                                     *
                                     * @param sliceFillStylePalette - Palette for FillStyle objects
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setSliceFillStyle(sliceFillStylePalette: Palette<FillStyle>): this;
                                    /**
                                     * Get style of Pyramid Slices fill.
                                     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Pyramid will be assigned an incremental index,
                                     * which will be used to pick its fill style from this Palette.
                                     *
                                     * So, for example... We have a Pyramid Chart with 5 Slices, and we give it a Palette with only 3 possible values
                                     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                                     * Note that this means, that the supplied Palette will have to work in a continuous manner!
                                     *
                                     * @returns Palette<FillStyle>
                                     * @public
                                     */
                                    getSliceFillStyle(): Palette<FillStyle>;
                                    /**
                                     * Set style of Pyramid Slices Stroke.
                                     * @param value - LineStyle object or function which creates a new style based on previous
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get style of Pyramid Slices Stroke.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getSliceStrokeStyle(): LineStyle;
                                    /**
                                     * Set theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @param enabled - Theme effect enabled
                                     * @returns          Object itself.
                                     * @public
                                     */
                                    setSliceEffect(enabled: boolean): this;
                                    /**
                                     * Get theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                     * @public
                                     */
                                    getSliceEffect(): boolean;
                                    /**
                                     * Set sorter of Pyramids' Slices as a comparator-function.
                                     *
                                     * For some commonly needed default implementations, can refer to SliceSorters-collection.
                                     * @param sliceSorter - SliceSorter - function which sorts Slices of Pyramid with JavaScript API: Array.sort.
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setSliceSorter(sliceSorter: SliceSorter<PyramidSlice>): this;
                                    /**
                                     * Get sorter of Pyramids' Slices as a comparator-function.
                                     * @returns SliceSorter - function which sorts Slices of Pyramid with JavaScript API: Array.sort.
                                     * @public
                                     */
                                    getSliceSorter(): SliceSorter<PyramidSlice>;
                                    /**
                                     * Set fill style of Pyramid Slices Labels.
                                     * @param value - FillStyle object or function which creates a new style based on previous
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Pyramid Slice Labels.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getLabelFillStyle(): FillStyle;
                                    /**
                                     * Set font of Slice Labels.
                                     * @param value - FontSettings or mutator function for existing settings
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of Slice Labels.
                                     * @returns FontSettings
                                     * @public
                                     */
                                    getLabelFont(): FontSettings;
                                    /**
                                     * Set theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @param enabled - Theme effect enabled
                                     * @returns          Object itself.
                                     * @public
                                     */
                                    setLabelEffect(enabled: boolean): this;
                                    /**
                                     * Get theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                     * @public
                                     */
                                    getLabelEffect(): boolean;
                                    /**
                                     * Set formatter of Slice Labels.
                                     *
                                     * See {@link SliceLabelFormatters} for a collection of default options.
                                     * @param labelFormatter - SliceLabelFormatter - function which generates text of Labels per Slice.
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setLabelFormatter(labelFormatter: SliceLabelFormatter<PyramidSlice>): this;
                                    /**
                                     * Get formatter of Slice Labels.
                                     * @returns SliceLabelFormatter - function which generates text of Labels per Slice.
                                     * @public
                                     */
                                    getLabelFormatter(): SliceLabelFormatter<PyramidSlice>;
                                    /**
                                     * Set if slices should be highlighted on mouse hover / touch. Applies to all Slices.
                                     * @param state - True if Slices should be highlighted on hover, false if not. This applies to all existing Slices and new Slices added.
                                     * @public
                                     */
                                    setSliceHighlightOnHover(state: boolean): this;
                                    /**
                                     * **Permanently** destroy the component.
                                     *
                                     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                     * **to the component and its children** in application code.
                                     * ```javascript
                                     * let chart = ...ChartXY()
                                     * let axisX = chart.getDefaultAxisX()
                                     * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                     * chart.dispose()
                                     * chart = undefined
                                     * axisX = undefined
                                     * ```
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    dispose(): this;
                                }
                                /**
                                 * Interface for readonly configuration of {@link PyramidChart}.
                                 *
                                 * Some properties of `PyramidChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
                                 *
                                 * ```typescript
                                 *  // Example, create chart with specified color theme.
                                 *  const chart = LightningChart.Pyramid({
                                 *      theme: Themes.light,
                                 *  })
                                 * ```
                                 *
                                 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
                                 *
                                 * For *standalone* `PyramidChart`, more parameters are documented in {@link LightningChart.Pyramid}.
                                 *
                                 * For *dashboard* `PyramidChart`, more parameters are documented in {@link Dashboard.createPyramidChart}.
                                 *
                                 *
                                 * **Commonly used properties:**
                                 *
                                 * - {@link PyramidChartOptions.type}: Specify visual design of *pyramid chart* from a collection of options.
                                 * - {@link PyramidChartOptions.theme}: Specify chart color *theme*.
                                 * - {@link PyramidChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
                                 *
                                 * **Example usage:**
                                 *
                                 * ```typescript
                                 *  // Example 1, create pyramid chart with default configuration.
                                 *  const chart = LightningChart.Pyramid({})
                                 * ```
                                 *
                                 * ```typescript
                                 *  // Example 2, create pyramid chart with labels inside slices.
                                 *  const chart = LightningChart.Pyramid({
                                 *      type: PyramidChartTypes.LabelsInsideSlices
                                 *  })
                                 * ```
                                 *
                                 * ```typescript
                                 *  // Example 3, create pyramid chart with specified color theme.
                                 *  const chart = LightningChart.Pyramid({
                                 *      theme: Themes.light,
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare interface PyramidChartOptions<PyramidChartType extends PyramidChartTypes = PyramidChartTypes, CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                                    /**
                                     * Interface for specifying desired "type" of Pyramid Chart.
                                     * This can be used to select different rendering approaches, mainly reflecting how Slice Labels are positioned.
                                     *
                                     * Options are located in {@link PyramidChartTypes} collection. If undefined, will default to {@link PyramidChartWithLabelsOnSides}.
                                     */
                                    type?: PyramidChartType;
                                    /**
                                     * Builder for the charts' *auto cursor*.
                                     *
                                     * For most use cases, it is not recommended to use this, but rather {@link PyramidChart.setAutoCursor} for a more convenient API.
                                     * @public
                                     */
                                    readonly autoCursorBuilder?: AutoCursor2DBuilder<CursorResultTableBackgroundType>;
                                }
                                /**
                                 * Collection of {@link PyramidChart} implementations. Each option can have their own visual type, and *API* for customization of it.
                                 *
                                 * This must be specified when the {@link PyramidChart} is created (or default one will be used).
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Create a PyramidChart with default type
                                 * LightningChart.Pyramid()
                                 * // Create a PyramidChart with specified type
                                 * LightningChart.Pyramid({ type: PyramidChartTypes.LabelsInsideSlices })
                                 * ```
                                 * @public
                                 */
                                export declare const PyramidChartTypes: {
                                    /**
                                     * Pyramid Chart type, where Slice Labels are positioned on the either left or right sides of Chart.
                                     * The side can be set using setLabelSide
                                     * Labels are connected to their Slices with lines, which can be styled using unique API for this Pyramid Chart type.
                                     */
                                    LabelsOnSides: typeof PyramidChartWithLabelsOnSides;
                                    /**
                                     * Pyramid Chart type, where Slice Labels inside the Slices.
                                     */
                                    LabelsInsideSlices: typeof PyramidChartWithLabelsInsideSlices;
                                };
                                /**
                                 * Available Pyramid Chart types
                                 * @public
                                 */
                                export declare type PyramidChartTypes = typeof PyramidChartTypes[keyof typeof PyramidChartTypes];
                                /**
                                 * {@link PyramidChart} implementation that draws Slice Labels inside the Slices.
                                 * Works well when Label texts are short and there are not a lot of Slices, as the actual Pyramid has more space.
                                 * @public
                                 */
                                export declare class PyramidChartWithLabelsInsideSlices extends PyramidChart {
                                    /**
                                     * Get minimum size of Panel.
                                     * Depending on the type of class this value might be automatically computed to fit different elements.
                                     * @returns Point
                                     * @public
                                     */
                                    getMinimumSize(): Point | undefined;
                                }
                                /**
                                 * {@link PyramidChart} implementation that draws Slice Labels on its left and right sides.
                                 * Slices and Labels are connected by 'label connector lines'.
                                 * @public
                                 */
                                export declare class PyramidChartWithLabelsOnSides extends PyramidChart {
                                    /**
                                     * Set style of Label connector lines.
                                     * @param labelConnectorStyle - LineStyle object
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setLabelConnectorStyle(labelConnectorStyle: LineStyle): this;
                                    /**
                                     * Get style of Label connector lines.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getLabelConnectorStyle(): LineStyle;
                                    /**
                                     * Set gap between Slice / start of label connector, and end of label connector / Label.
                                     * @param labelConnectorGap - Gap as pixels
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setLabelConnectorGap(labelConnectorGap: pixel): this;
                                    /**
                                     * Get gap between Slice / start of label connector, and end of label connector / Label.
                                     * @returns Gap as pixels
                                     * @public
                                     */
                                    getLabelConnectorGap(): number;
                                    /**
                                     * Set the side where label should display
                                     * @param labelSide - Left / Right
                                     * @returns Pyramid Chart itself
                                     * @public
                                     */
                                    setLabelSide(labelSide: PyramidLabelSide): this;
                                    /**
                                     * Get the side where label shown
                                     * @returns The label side
                                     * @public
                                     */
                                    getLabelSide(): PyramidLabelSide;
                                    /**
                                     * Get minimum size of Panel.
                                     * Depending on the type of class this value might be automatically computed to fit different elements.
                                     * @returns Point minimum size or undefined if unimplemented
                                     * @public
                                     */
                                    getMinimumSize(): Point | undefined;
                                }
                                /**
                                 * Options for selecting side of labels in a {@link PyramidChartWithLabelsOnSides}.
                                 *
                                 * Use with {@link PyramidChartWithLabelsOnSides.setLabelSide}
                                 * @public
                                 */
                                export declare enum PyramidLabelSide {
                                    /**
                                     * Label Side  - Right
                                     */
                                    Right = 0,
                                    /**
                                     * Label Side  - Left
                                     */
                                    Left = 1
                                }
                                /**
                                 * Interface that can be used to define {@link PyramidChart} configurations, when inside a {@link Dashboard}, that can't be changed after creation.
                                 *
                                 * Example usage:
                                 * ```javascript
                                 * // Pyramid Chart with default type
                                 * undefined
                                 * // Pyramid Chart with specified type
                                 * { pyramidOptions: { type: PyramidChartTypes.LabelsInsideSlices } }
                                 * ```
                                 * @public
                                 */
                                export declare interface PyramidOptions<PyramidChartType extends PyramidChartTypes> extends DashboardCellOptions, PyramidChartOptions<PyramidChartType> {
                                }
                                /**
                                 * Class that represents a single Slice of a Pyramid Chart.
                                 * It is given to users when a Slice is added.
                                 * @public
                                 */
                                export declare abstract class PyramidSlice extends Slice {
                                    /**
                                     * Set value of Slice.
                                     * @param value - Numeric value
                                     * @returns Slice itself
                                     * @public
                                     */
                                    abstract setValue(value: number): this;
                                    /**
                                     * Get value of Slice.
                                     * @returns Numeric value
                                     * @public
                                     */
                                    abstract getValue(): number;
                                }
                                /**
                                 * Enum for selecting different drawing approaches for {@link PyramidChart}.
                                 *
                                 * Use with {@link PyramidChart.setSliceMode}
                                 * @public
                                 */
                                export declare enum PyramidSliceModes {
                                    /**
                                     * Slices **height** represents its relative value inside the Pyramid Chart.
                                     */
                                    VariableHeight = 0,
                                    /**
                                     * Slices **width** represents its relative value inside the Pyramid Chart.
                                     */
                                    VariableWidth = 1
                                }
                                /**
                                 * Class of Radial Gauge represents the type of the gauge of a circular shape.
                                 * @public
                                 */
                                export declare abstract class RadialGauge<P extends GaugeSlice, I extends P> extends GaugeChart<P, I> {
                                    /**
                                     * Set angular interval of the gauge in degrees.
                                     * @param start - Start angle of the gauge in degrees.
                                     * @param end - End angle of the gauge in degrees.
                                     * @returns Gauge itself for fluent interface.
                                     * @public
                                     */
                                    setAngleInterval(start: number, end: number): this;
                                    /**
                                     * Get the angular interval of the gauge.
                                     * @returns Angle interval object \{min, max\} in degrees.
                                     * @public
                                     */
                                    getAngleInterval(): AngleInterval;
                                    /**
                                     * Apply new fill style to slice arc.
                                     * @param value - FillStyle or mutator to modify the existing one.
                                     * @returns Gauge itself for fluent interface.
                                     * @public
                                     */
                                    setGaugeFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Set stroke of gauge background
                                     * @param value - LineStyle or mutator to modify the existing one.
                                     * @returns Gauge itself for fluent interface.
                                     * @public
                                     */
                                    setGaugeStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Subscribe to Gauge Angle Change event.
                                     * @returns Token of the listener.
                                     * @public
                                     */
                                    onAngleIntervalChange(clbk: GaugeAngleIntervalEventHandler<this>): Token;
                                    /**
                                     * Remove listener with provided token.
                                     * @param token - Token of the listener.
                                     * @returns True if the listener is successfully removed and false if it is not found.
                                     * @public
                                     */
                                    offAngleIntervalChange(token: Token): boolean;
                                    /**
                                     * @public
                                     */
                                    dispose(): this;
                                }
                                /**
                                 * Radial Gradient fill style.
                                 *
                                 * Instances of RadialGradientFill are *immutable*, meaning that its setters don't modify the object,
                                 * but instead return a completely new modified object.
                                 * @public
                                 */
                                export declare class RadialGradientFill extends RadialGradientFillStyleRecord implements Gradient, FillStyle {
                                    /** @public */
                                    constructor(props?: Partial<RadialGradientFillStyleProperties>);
                                    /**
                                     * Set color stops for the gradient.
                                     * @param stops - Color Stops
                                     * @public
                                     */
                                    setColorStops(stops: ColorStop[]): this;
                                    /**
                                     * Get current color stops from the gradient.
                                     * @public
                                     */
                                    getColorStops(): ColorStop[];
                                    /**
                                     * Set the center position of the gradient.
                                     * @param position - Local XY coordinate in x: [0-1], y: [0-1] range
                                     * @public
                                     */
                                    setPosition(position: Point): this;
                                    /**
                                     * Get the center position of the gradient.
                                     * @public
                                     */
                                    getPosition(): Point;
                                    /**
                                     * Set the shape of the gradient
                                     * @param shape - Gradient Shape
                                     * @public
                                     */
                                    setShape(shape: GradientShape): this;
                                    /**
                                     * Get the shape of the gradient
                                     * @public
                                     */
                                    getShape(): GradientShape;
                                    /**
                                     * Set the extent of the gradient.
                                     * @param extent - Gradient Extent
                                     * @public
                                     */
                                    setExtent(extent: GradientExtent): this;
                                    /**
                                     * Get the extent of the gradient
                                     * @public
                                     */
                                    getExtent(): GradientExtent;
                                }
                                /**
                                 * Factory for creating a RadialGradientFill palette.
                                 * @param colorPalettes - Collection of default colors from PaletteFactory
                                 * @param amount - Amount of colors in the palette
                                 * @returns A new RadialGradientFill palette
                                 * @public
                                 */
                                export declare const RadialGradientFillPalette: (colorPalettes: PaletteFactory<Color>, amount: number, color?: Color) => Palette<FillStyle>;
                                /**
                                 * Interface for all properties of a RadialGradientFillStyle.
                                 * @public
                                 */
                                export declare interface RadialGradientFillStyleProperties {
                                    type: 'fillstyle';
                                    fillType: 'radial-gradient';
                                    /**
                                     * Gradient color stops
                                     */
                                    stops: ColorStop[];
                                    /**
                                     * Gradient center position.
                                     *
                                     * A element relative coordinate. 0 to 1 coordinate space.
                                     * `{ x: 0, y: 0 }` is bottom left.
                                     * `{ x: 1, y: 1 }` is top right.
                                     */
                                    position: Point;
                                    /**
                                     * The shape for the gradient
                                     */
                                    shape: GradientShape;
                                    /**
                                     * The extent for gradient.
                                     *
                                     * Defines where the gradient takes it's size.
                                     */
                                    extent: GradientExtent;
                                }
                                /**
                                 * Record contractor for RadialGradientFillStyleProperties.
                                 * @public
                                 */
                                declare const RadialGradientFillStyleRecord: Record_2.Factory<RadialGradientFillStyleProperties>;
                                /**
                                 * RadialScale is a two dimensional Scale:
                                 * - Amplitude ( radius on circle )
                                 * - Angle ( angle along circle, always in range [0, 2 pi] )
                                 *
                                 * It is configured by its cell size and margins, always representing a circle, maintaining symmetric X and Y radius
                                 * as defined by margins.
                                 *
                                 * Basically the same as what PieChart logic does with its Scales,
                                 * but at a different place in library hierarchy ( Chart -\> Scale -\> Engine ).
                                 * Could be used for PieChart just as well, but why bother.
                                 *
                                 * @public
                                 */
                                declare class RadialScale extends ScaleXY<LinearScale1D> {
                                }
                                /**
                                 * The abstact class implements the most part of general logic for mountains.
                                 * The series contains the following elements:
                                 * - Junction area with stylable and switchable fill styles for High and Low values.
                                 * - Line with points for High values border.
                                 * - Line with points for Low values border.
                                 * @public
                                 */
                                export declare abstract class RangeSeries extends SeriesXY<CursorPoint, LinearScaleXY | MixedScaleXY> implements SeriesWithDataCleaning, AttachableWithLUT {
                                    /**
                                     * Disable automatic data cleaning.
                                     *
                                     * ```js
                                     *  // Example syntax, disable data cleaning.
                                     *  series.setDataCleaning(undefined)
                                     * ```
                                     *
                                     * @param arg - Data cleaning configuration.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setDataCleaning(arg: undefined): this;
                                    /**
                                     * Enable automatic data cleaning by `minDataPointCount` configuration.
                                     *
                                     * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
                                     *
                                     * ```js
                                     *  // Example syntax for specifying minDataPointCount
                                     *  series.setDataCleaning({ minDataPointCount: 10000 })
                                     * ```
                                     *
                                     * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
                                     * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
                                     *
                                     * ```js
                                     *  // Example, enable lazy data cleaning of out of view data.
                                     *  series.setDataCleaning({ minDataPointCount: 1 })
                                     * ```
                                     *
                                     * @param arg - Data cleaning configuration.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setDataCleaning(arg: {
                                        minDataPointCount: number | undefined;
                                    }): this;
                                    /**
                                     * Clear all previously pushed data points from the *series*.
                                     *
                                     * ```ts
                                     *  // Example usage
                                     *  LineSeries.clear()
                                     * ```
                                     *
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    clear(): this;
                                    /**
                                     * Get amount of points that series currently has.
                                     * @returns Number of points
                                     * @public
                                     */
                                    getPointAmount(): number;
                                    /**
                                     * Set if cursor interpolates solved data-points along series by default.
                                     *
                                     * ```typescript
                                     *  // Example, disable default interpolation of area series.
                                     *  const series = ChartXY.addAreaSeries()
                                     *      .setCursorInterpolationEnabled(false)
                                     * ```
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                     * - {@link setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                                     * - `setCursorSolveBasis` | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
                                     * NOTE: This method is not yet available for *range series*, stay tuned for future updates!.
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     *
                                     * @param state - Boolean flag
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setCursorInterpolationEnabled(state: boolean): this;
                                    /**
                                     * Get if cursor interpolates solved data-points along series by default.
                                     * @returns Boolean flag
                                     * @public
                                     */
                                    getCursorInterpolationEnabled(): boolean;
                                    /**
                                     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                                     *
                                     * ```typescript
                                     *  // Example usage
                                     *  AreaSeries.setCursorResultTableFormatter((tableBuilder, series, position, high, low) => {
                                     *      return tableBuilder
                                     *          .addRow(`Pointing at`, '', series.getName())
                                     *          .addRow(`X:`, '', position.toFixed(1))
                                     *          .addRow(`Y:`, '', high.toFixed(1))
                                     *  })
                                     * ```
                                     *
                                     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                                     * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                                     *
                                     * ```typescript
                                     *  // Using TableContentBuilder.
                                     *  AreaSeries.setCursorResultTableFormatter((tableBuilder, series, position, high, low) => {
                                     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                                     *      tableBuilder
                                     *          .addRow('Item 0:', '', 'Value 0')
                                     *          .addRow('Item 1:', '', 'Value 1')
                                     *          .addRow('Long row that highlights the idea of empty strings')
                                     *
                                     *      // After configuration, the table builder must be returned!
                                     *      return tableBuilder
                                     *  })
                                     * ```
                                     *
                                     * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
                                     *
                                     * The additional values that are supplied to the callback function, **vary per series**,
                                     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                                     * All `Range Series` (*area* and *area-range*) receive four extra parameters:
                                     * 1. `series` | reference to the series itself.
                                     * 2. `position` | pointed data point X coordinate.
                                     * 3. `high` | pointed data point high Y coordinate.
                                     * 3. `low` | pointed data point low Y coordinate.
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                     * - {@link setCursorInterpolationEnabled} | configure whether cursor interpolates solved data-points.
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     *
                                     * @param formatter - Function which builds *ResultTable* content.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setCursorResultTableFormatter(formatter: RangeSeriesFormatter): this;
                                    /**
                                     * Configure whether *cursors* should pick on this particular *series* or not.
                                     *
                                     * ```typescript
                                     *  // Example, prevent chart auto cursor from snapping to a series.
                                     *  RangeSeries.setCursorEnabled(false)
                                     * ```
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                                     * - {@link setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
                                     * This method is not available for all *series* types.
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     * @public
                                     */
                                    setCursorEnabled(state: boolean): this;
                                    /**
                                     * Get ResultTable Formatter.
                                     * @returns Function which builds ResultTable content for RangeSeries.
                                     * @public
                                     */
                                    getCursorResultTableFormatter(): RangeSeriesFormatter;
                                    /**
                                     * @returns Max X value of the series
                                     * @public
                                     */
                                    getXMax(): number;
                                    /**
                                     * @returns Min X value of the series
                                     * @public
                                     */
                                    getXMin(): number;
                                    /**
                                     * @returns Max Y value of the series
                                     * @public
                                     */
                                    getYMax(): number;
                                    /**
                                     * @returns Min Y value of the series
                                     * @public
                                     */
                                    getYMin(): number;
                                    /**
                                     * Method for solving the nearest data point from a given coordinate on screen.
                                     *
                                     * ```ts
                                     *  // Example usage, from mouse move event.
                                     *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                                     *      const result = LineSeries.solveNearestFromScreen(event)
                                     *  })
                                     * ```
                                     *
                                     * ```ts
                                     *  // Example usage, arbitrary coordinate on client coordinate system.
                                     *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                                     * ```
                                     *
                                     * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                                     *
                                     * @param   location -  Location in HTML client coordinates.
                                     * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                                     * @public
                                     */
                                    solveNearestFromScreen(location: CoordinateClient, interpolate?: boolean): undefined | CursorPoint;
                                    /**
                                     * Method that solves the nearest datapoint on mountain to a given coordinate on screen.
                                     * @param location - Location on screen
                                     * @returns Undefined or data-structure for positioning of cursors
                                     * @public
                                     * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                                     */
                                    solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
                                }
                                /**
                                 * Interface for a function which builds ResultTable content when pointing at a RangeSeries.
                                 * @param tableContentBuilder - Builder that is used to build contents of ResultTable.
                                 *                                  Use addRow() method for adding content.
                                 * @param series - RangeSeries.
                                 * @param position - Position on the axis.
                                 * @param high - High value on the axis.
                                 * @param low - Low value on the axis.
                                 * @returns TableContentBuilder that was supplied
                                 * @public
                                 */
                                export declare type RangeSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: RangeSeries, position: number, high: number, low: number) => T;
                                /**
                                 * Class for series visual that is a Rectangle.
                                 * @public
                                 */
                                export declare class RectangleFigure extends Figure {
                                    /**
                                     * @public
                                     */
                                    readonly scale: LinearScaleXY | MixedScaleXY;
                                    /**
                                     * Get boundaries that contain figure.
                                     * @returns Interval<Point>
                                     * @public
                                     */
                                    getBoundaries(): Interval<Point>;
                                    /**
                                     * Set new dimensions for figure.
                                     * @param dimensions - Dimensions as either of supported Rectangle interfaces
                                     * @returns Object itself
                                     * @remarks          Owning series will be informed of change in size, possible initiating scrolling.
                                     * @public
                                     */
                                    setDimensions(dimensions: RectanglePositionAndSize | RectangleTwoPoints): this;
                                    /**
                                     * Get current dimensions of figure as interface 'RectanglePositionAndSize'.
                                     * @returns RectanglePositionAndSize
                                     * @public
                                     */
                                    getDimensionsPositionAndSize(): RectanglePositionAndSize;
                                    /**
                                     * Get current dimensions of figure as interface 'RectangleTwoPoints'.
                                     * @returns RectangleTwoPoints
                                     * @public
                                     */
                                    getDimensionsTwoPoints(): RectangleTwoPoints;
                                    /**
                                     * Set fill style of Rectangle.
                                     * @param value - FillStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Rectangle.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stroke style of Rectangle.
                                     *
                                     * Supported line styles:
                                     * - {@link SolidLine}
                                     * - {@link emptyLine}
                                     *
                                     * @param value - LineStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of Rectangle.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Get state of component highlighting.
                                     *
                                     * @returns Boolean or number between 0 and 1, where 1 is fully highlighted.
                                     * @public
                                     */
                                    getDominantStyle(): FillStyle;
                                }
                                /**
                                 * Interface for defining dimensions of a Rectangle with position and size.
                                 * @public
                                 */
                                export declare interface RectanglePositionAndSize {
                                    /**
                                     * X coordinate of rectangles bottom-left corner.
                                     */
                                    readonly x: number;
                                    /**
                                     * Y coordinate of rectangles bottom-left corner.
                                     */
                                    readonly y: number;
                                    /**
                                     * Width of rectangle
                                     */
                                    readonly width: number;
                                    /**
                                     * Height of rectangle
                                     */
                                    readonly height: number;
                                }
                                /**
                                 * Series that lets user draw Rectangles with independent figures.
                                 * @public
                                 */
                                export declare class RectangleSeries extends FigureSeries<RectangleFigure, RectanglePositionAndSize | RectangleTwoPoints, LinearScaleXY | MixedScaleXY> {
                                    /**
                                     * Add new figure to the series.
                                     * @param dimensions - Dimensions that figure must represent
                                     * @returns Created figure
                                     * @public
                                     */
                                    add(dimensions: RectanglePositionAndSize | RectangleTwoPoints): RectangleFigure;
                                    /**
                                     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                                     *
                                     * ```typescript
                                     *  // Example usage
                                     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
                                     *      const rectangleDimensions = figure.getDimensionsTwoPoints()
                                     *      return tableBuilder
                                     *          .addRow(`Pointing at`, '', series.getName())
                                     *          .addRow(`X1:`, '', rectangleDimensions.x1)
                                     *          .addRow(`X2:`, '', rectangleDimensions.x2)
                                     *          .addRow(`Y1:`, '', rectangleDimensions.y1)
                                     *          .addRow(`Y2:`, '', rectangleDimensions.y2)
                                     *  })
                                     * ```
                                     *
                                     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                                     * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                                     *
                                     * ```typescript
                                     *  // Using TableContentBuilder.
                                     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
                                     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                                     *      tableBuilder
                                     *          .addRow('Item 0:', '', 'Value 0')
                                     *          .addRow('Item 1:', '', 'Value 1')
                                     *          .addRow('Long row that highlights the idea of empty strings')
                                     *
                                     *      // After configuration, the table builder must be returned!
                                     *      return tableBuilder
                                     *  })
                                     * ```
                                     *
                                     * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
                                     *
                                     * The additional values that are supplied to the callback function vary between different chart types,
                                     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                                     * `Figure Series` receive two extra parameters:
                                     * 1. `series` | reference to the series itself.
                                     * 2. `figure` | reference to the pointed *figure*.
                                     * This type is **generic** - for example, for `RectangleSeries` it is of type `RectangleFigure`.
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     *
                                     * @param formatter - Function which builds *ResultTable* content.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setCursorResultTableFormatter(formatter: FigureSeriesFormatter<RectangleFigure, RectangleSeries>): this;
                                    /**
                                     * Get ResultTable Formatter.
                                     * @returns Function which builds ResultTable content for the Series.
                                     * @public
                                     */
                                    getCursorResultTableFormatter(): FigureSeriesFormatter<RectangleFigure, RectangleSeries>;
                                }
                                /**
                                 * Interface for supplying readonly configurations to a {@link RectangleSeries}.
                                 * @public
                                 */
                                export declare interface RectangleSeriesOptions extends SeriesOptionsXY {
                                }
                                /**
                                 * Interface for defining dimensions of a Rectangle with two locations.
                                 * @public
                                 */
                                export declare interface RectangleTwoPoints {
                                    /**
                                     * X coordinate of rectangles bottom-left corner.
                                     */
                                    readonly x1: number;
                                    /**
                                     * Y coordinate of rectangles bottom-left corner.
                                     */
                                    readonly y1: number;
                                    /**
                                     * X coordinate of rectangles top-right corner.
                                     */
                                    readonly x2: number;
                                    /**
                                     * Y coordinate of rectangles top-right corner.
                                     */
                                    readonly y2: number;
                                }
                                /**
                                 * Convenience function that maps a color palette + value range to Color Lookup Table steps.
                                 *
                                 * Equal to following one-liner:
                                 *
                                 * ```ts
                                 *  const steps = colorPalette.map((color, i) => ({ color, value: valueMin + (i / (colorPalette.length - 1)) * (valueMax - valueMin) }))
                                 * ```
                                 *
                                 * Used like this:
                                 *
                                 * ```ts
                                 *  // Example, construct LUT with regular color steps from an array of colors.
                                 *  const lut = new LUT({
                                 *      interpolate: true,
                                 *      steps: regularColorSteps(0, 100, [ ColorCSS('red'), ColorCSS('blue'), ColorCSS('green') ])
                                 *  })
                                 * ```
                                 *
                                 * @param   valueMin      -  Min LUT value. Attached to the first color in the palette.
                                 * @param   valueMax      -  Max LUT value. Attached to the last color in the palette.
                                 * @param   opts          -  Optional extra options.
                                 * @param   formatLabels  -  Optional callback function for mapping each {@link LUTStep.value} to value of {@link LUTStep.label}.
                                 * @param   alpha         -  Optional specific Alpha value [0, 255] to use with each color.
                                 * @returns                  Array of LUTSteps which can be used to construct a {@link LUT} object.
                                 * @public
                                 */
                                export declare const regularColorSteps: (valueMin: number, valueMax: number, colorPalette: Color[], opts?: {
                                    formatLabels?: ((value: number) => string) | undefined;
                                    alpha?: number | undefined;
                                } | undefined) => LUTStep[];
                                /**
                                 * Public interface for ResultTable.
                                 * Part of Cursor that displays information about current data-point.
                                 * @public
                                 */
                                export declare interface ResultTable<BackgroundType extends UIBackground = UIBackground> extends Marginable, ComponentWithEffects {
                                    /**
                                     * Set displayed data of ResultTable
                                     * @param data - TableContent
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setContent: (data: ResultTableContent) => this;
                                    /**
                                     * Set origin position of ResultTable
                                     * @param origin - (-1 to 1 which specifies position of origin, 0 is center of the object)
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setOrigin: (origin: Point) => this;
                                    /**
                                     * Get origin position of v
                                     * @returns (-1 to 1 which specifies position of origin, 0 is center of the object)
                                     * @public
                                     */
                                    getOrigin: () => Point;
                                    /**
                                     * Set text fillStyle of ResultTable text
                                     * @param fillStyle - FillStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setTextFillStyle: (fillStyle: FillStyle | ImmutableMutator<FillStyle>) => this;
                                    /**
                                     * Get text fillStyle of ResultTable
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getTextFillStyle: () => FillStyle;
                                    /**
                                     * Set text font of ResultTable text
                                     * @param value - FontSettings or mutator function for existing settings
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get text font of ResultTable text
                                     * @returns FontSettings
                                     * @public
                                     */
                                    getTextFont(): FontSettings;
                                    /**
                                     * Set rotation of ResultTable label.
                                     * @param value - Rotation in degrees
                                     * @returns Object itself
                                     * @public
                                     */
                                    setTextRotation(value: number): this;
                                    /**
                                     * Get rotation of ResultTable text.
                                     * @returns Rotation in degrees
                                     * @public
                                     */
                                    getTextRotation(): number;
                                    /**
                                     * Mutator function for Background of ResultTable.
                                     * @param mutator - Mutator function
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setBackground(mutator: Mutator<BackgroundType>): this;
                                    /**
                                     * Get background object of ResultTable
                                     * @returns Background object
                                     * @public
                                     */
                                    getBackground(): BackgroundType;
                                    /**
                                     * Set padding of ResultTable in pixels
                                     * @param padding - Number with pixel padding for all sides or data structure with individual pixel paddings
                                     *                      for each side. Any side can be omitted, only passed values will be overridden.
                                     * @returns Background object
                                     * @public
                                     */
                                    setPadding(padding: Partial<Padding> | number): this;
                                    /**
                                     * Get padding of object in pixels.
                                     * @returns padding datastructure
                                     * @public
                                     */
                                    getPadding(): Padding;
                                }
                                /**
                                 * Interface that represents content displayable by a ResultTable.
                                 *
                                 * Currently simply a grid of strings, but in the future this could be extended to contain images or such.
                                 * @public
                                 */
                                export declare type ResultTableContent = (string | {
                                    text: string;
                                    font?: Partial<FontProperties>;
                                    fillStyle?: FillStyle;
                                } | undefined)[][];
                                /**
                                 * @public
                                 */
                                export declare interface RotationPoint extends Point {
                                    /**
                                     * Point rotation as degrees.
                                     */
                                    rotation: number;
                                }
                                /**
                                 * Interface for a data point that contains an associated rotation property.
                                 *
                                 * Can be used for individual configuration of data points rotation.
                                 *
                                 * For some series types, individually rotated data points might have to be explicitly enabled when the series is created.
                                 * Refer to series documentation for more detailed information.
                                 * @public
                                 */
                                export declare interface RotationValue {
                                    /**
                                     * Data point rotation as degrees.
                                     *
                                     * Can be used for individual configuration of data points rotation.
                                     *
                                     * For some series types, individually rotated data points might have to be explicitly enabled when the series is created.
                                     * Refer to series documentation for more detailed information.
                                     */
                                    readonly rotation?: number;
                                }
                                /**
                                 * Capture rendered state in an image file. Prompts the browser to download the created file.
                                 *
                                 * **NOTE: The download might be blocked by browser/plugins as harmful.**
                                 * To prevent this, only call the method in events tied to user-interactions.
                                 * From mouse-event handlers, for example.
                                 *
                                 * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
                                 * For supported image formats, compression quality, Etc. refer to:
                                 *
                                 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Download 'screenshot.png'
                                 * saveToFile(chart.engine, 'screenshot')
                                 * // Attempt download 'maybeNotSupported.bmp'
                                 * saveToFile(chart.engine, 'maybeNotSupported', 'image/bmp')
                                 * // Attempt download jpeg.file with specified compression quality
                                 * saveToFile(chart.engine, 'fileName', 'image/jpeg', 0.50)
                                 * ```
                                 *
                                 * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
                                 *
                                 * @param engine - [PublicEngine] reference of a chart which you would like to save to a file.
                                 * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
                                 *                          as it is automatically detected from 'type'-argument.
                                 * @param type - A DOMString indicating the image format. The default format type is image/png.
                                 * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
                                 *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
                                 *                          the default value for image quality is used. The default value is 0.92.
                                 * @public
                                 */
                                export declare const saveToFile: (engine: PublicEngine, fileName: string, type?: string, encoderOptions?: number) => void;
                                /**
                                 * Abstract base class for 1 Dimensional Scale object.
                                 *
                                 * Describes an abstract virtual number interval (start - end).
                                 *
                                 * Scale1D is defined within an (optional) dashboard cell, allocating a sub section of the whole dashboard for the Scale.
                                 * @public
                                 */
                                declare abstract class Scale1D {
                                    /**
                                     * Get start coordinate on Scale. NOT necessarily smaller than end coordinate!
                                     * @returns number.
                                     * @public
                                     */
                                    getInnerStart(): number;
                                    /**
                                     * Get end coordinate on Scale. NOT necessarily higher than start coordinate!
                                     * @returns number.
                                     * @public
                                     */
                                    getInnerEnd(): number;
                                    /**
                                     * Get absolute interval of Scale. Calculated by:
                                     *
                                     * ```ts
                                     * const innerInterval = Math.abs( Scale1D.getInnerEnd() - Scale1D.getInnerStart() )
                                     * ```
                                     * @returns number.
                                     * @public
                                     */
                                    getInnerInterval(): number;
                                }
                                /**
                                 * Scale class that directly represents the XY viewport (e.g. X scale = width, Y scale = height).
                                 *
                                 * e.g. "ViewportScaleXY"
                                 *
                                 * If Polar coordinate transformation is moved to shared, or some similar feature is implemented
                                 * we would then need a higher level ScaleXY abstraction that would allow the creation of a Scale
                                 * defined without X and Y planes (e.g. Polar = amplitude, angle ).
                                 * @public
                                 */
                                declare abstract class ScaleXY<T extends ViewportScale1D = ViewportScale1D> {
                                    /**
                                     * Scale that represents viewport width.
                                     * @public
                                     */
                                    x: T;
                                    /**
                                     * Scale that represents viewport height.
                                     * @public
                                     */
                                    y: T;
                                    /**
                                     * Get size of Scales interval as pixels on the viewport, with its margins deducted (starting from START to END of Scale).
                                     *
                                     * Equal to getting cell size and subtracting margins.
                                     * @public
                                     */
                                    getInnerIntervalPixels(): Point;
                                }
                                /**
                                 * Data structure that defines dimensions of a line-segment
                                 * @public
                                 */
                                export declare interface SegmentDimensions {
                                    /**
                                     * X value of start location
                                     */
                                    startX: number;
                                    /**
                                     * Y value of start location
                                     */
                                    startY: number;
                                    /**
                                     * X value of end location
                                     */
                                    endX: number;
                                    /**
                                     * Y value of end location
                                     */
                                    endY: number;
                                }
                                /**
                                 * Class for series visual that is a Segment.
                                 * @public
                                 */
                                export declare class SegmentFigure extends Figure {
                                    /**
                                     * @public
                                     */
                                    readonly scale: LinearScaleXY | MixedScaleXY;
                                    /**
                                     * Get boundaries that contain figure.
                                     * @returns Interval<Point>
                                     * @public
                                     */
                                    getBoundaries(): Interval<Point>;
                                    /**
                                     * Set new dimensions for figure.
                                     * @param dimensions - Dimensions
                                     * @returns Object itself
                                     * @remarks          Owning series will be informed of change in size, possible initiating scrolling.
                                     * @public
                                     */
                                    setDimensions(dimensions: SegmentDimensions): this;
                                    /**
                                     * Get current dimensions of figure.
                                     * @returns Dimensions
                                     * @public
                                     */
                                    getDimensions(): SegmentDimensions;
                                    /**
                                     * Set stroke style of Segment.
                                     *
                                     * Supported line styles:
                                     * - {@link SolidLine}
                                     * - {@link DashedLine}
                                     * - {@link emptyLine}
                                     *
                                     * @param value - FillStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of Segment.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Return some dominant fill style of the figure
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getDominantStyle(): FillStyle;
                                }
                                /**
                                 * Series for that lets user draw Segments with independent figures.
                                 * @public
                                 */
                                export declare class SegmentSeries extends FigureSeries<SegmentFigure, SegmentDimensions, LinearScaleXY | MixedScaleXY> {
                                    /**
                                     * Add new figure to the series.
                                     * @param dimensions - Dimensions that figure must represent
                                     * @returns Created figure
                                     * @public
                                     */
                                    add(dimensions: SegmentDimensions): SegmentFigure;
                                    /**
                                     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                                     *
                                     * ```typescript
                                     *  // Example usage
                                     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
                                     *      const rectangleDimensions = figure.getDimensionsTwoPoints()
                                     *      return tableBuilder
                                     *          .addRow(`Pointing at`, '', series.getName())
                                     *          .addRow(`X1:`, '', rectangleDimensions.x1)
                                     *          .addRow(`X2:`, '', rectangleDimensions.x2)
                                     *          .addRow(`Y1:`, '', rectangleDimensions.y1)
                                     *          .addRow(`Y2:`, '', rectangleDimensions.y2)
                                     *  })
                                     * ```
                                     *
                                     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                                     * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                                     *
                                     * ```typescript
                                     *  // Using TableContentBuilder.
                                     *  RectangleSeries.setCursorResultTableFormatter((tableBuilder, series, figure) => {
                                     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                                     *      tableBuilder
                                     *          .addRow('Item 0:', '', 'Value 0')
                                     *          .addRow('Item 1:', '', 'Value 1')
                                     *          .addRow('Long row that highlights the idea of empty strings')
                                     *
                                     *      // After configuration, the table builder must be returned!
                                     *      return tableBuilder
                                     *  })
                                     * ```
                                     *
                                     * Default Axis formatting can be referenced by using {@link Axis.formatValue} method.
                                     *
                                     * The additional values that are supplied to the callback function vary between different chart types,
                                     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                                     * `Figure Series` receive two extra parameters:
                                     * 1. `series` | reference to the series itself.
                                     * 2. `figure` | reference to the pointed *figure*.
                                     * This type is **generic** - for example, for `RectangleSeries` it is of type `RectangleFigure`.
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     *
                                     * @param formatter - Function which builds *ResultTable* content.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setCursorResultTableFormatter(formatter: FigureSeriesFormatter<SegmentFigure, SegmentSeries>): this;
                                    /**
                                     * Get ResultTable Formatter.
                                     * @returns Function which builds ResultTable content for the Series.
                                     * @public
                                     */
                                    getCursorResultTableFormatter(): FigureSeriesFormatter<SegmentFigure, SegmentSeries>;
                                }
                                /**
                                 * Interface for supplying readonly configurations to a {@link SegmentSeries}.
                                 * @public
                                 */
                                export declare interface SegmentSeriesOptions extends SeriesOptionsXY {
                                }
                                /**
                                 * Internal interface for any type of Series (2D, 3D, ...).
                                 *
                                 * Intended for sharing Axis logic which interfaces with all kinds of Axes.
                                 * @public
                                 */
                                export declare interface Series extends ChartComponent {
                                    /**
                                     * Set whether series is taken into account with automatic scrolling and fitting of attached axes.
                                     *
                                     * By default, this is true for all series.
                                     *
                                     * By setting this to `false`, any series can be removed from axis scrolling/fitting.
                                     *
                                     * ```ts
                                     *  // Example syntax, remove series from automatic scrolling / fitting.
                                     *  LineSeries.setAutoScrollingEnabled(false)
                                     * ```
                                     * @param enabled - `true` default, axes will take series into account in scrolling and fitting operations.
                                     *                      `false`, axes will ignore series boundaries.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAutoScrollingEnabled(enabled: boolean): this;
                                    /**
                                     * Get whether series is taken into account with automatic scrolling and fitting of attached axes.
                                     *
                                     * By default, this is true for all series.
                                     *
                                     * @returns `true` default, axes will take series into account in scrolling and fitting operations.
                                     *                      `false`, axes will ignore series boundaries.
                                     * @public
                                     */
                                    getAutoScrollingEnabled(): boolean;
                                }
                                /**
                                 * Base class for a major group of ChartComponents - Series.
                                 * Adds Cursor / solveNearest logic.
                                 * Base class for all Series. Series are chart components which support cursors, basically.
                                 * @public
                                 */
                                export declare abstract class Series2D<CursorPointInterface extends CursorPoint = CursorPoint> extends ChartComponent implements _InternalSeriesWithCursor<CursorPointInterface> {
                                    /**
                                     * Set whether series is taken into account with automatic scrolling and fitting of attached axes.
                                     *
                                     * By default, this is true for all series.
                                     *
                                     * By setting this to `false`, any series can be removed from axis scrolling/fitting.
                                     *
                                     * ```ts
                                     *  // Example syntax, remove series from automatic scrolling / fitting.
                                     *  LineSeries.setAutoScrollingEnabled(false)
                                     * ```
                                     * @param enabled - `true` default, axes will take series into account in scrolling and fitting operations.
                                     *                      `false`, axes will ignore series boundaries.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAutoScrollingEnabled(enabled: boolean): this;
                                    /**
                                     * Get whether series is taken into account with automatic scrolling and fitting of attached axes.
                                     *
                                     * By default, this is true for all series.
                                     *
                                     * @returns `true` default, axes will take series into account in scrolling and fitting operations.
                                     *                      `false`, axes will ignore series boundaries.
                                     * @public
                                     */
                                    getAutoScrollingEnabled(): boolean;
                                    /**
                                     * Method for solving the nearest data point from a given coordinate on screen.
                                     *
                                     * ```ts
                                     *  // Example usage, from mouse move event.
                                     *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                                     *      const result = LineSeries.solveNearestFromScreen(event)
                                     *  })
                                     * ```
                                     *
                                     * ```ts
                                     *  // Example usage, arbitrary coordinate on client coordinate system.
                                     *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                                     * ```
                                     *
                                     * Translating coordinates from other coordinate systems is also possible, see {@link ChartXY.translateCoordinate}.
                                     *
                                     * @param   location -  Location in HTML client coordinates.
                                     * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                                     * @public
                                     */
                                    abstract solveNearestFromScreen(location: CoordinateClient): undefined | CursorPointInterface;
                                    /**
                                     * Abstract method that solves the nearest datapoint to a given coordinate on screen.
                                     * @param location - Location on screen
                                     * @returns Undefined or data-structure for positioning of cursors
                                     * @public
                                     * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                                     */
                                    abstract solveNearestFromScreen(location: Point): undefined | CursorPointInterface;
                                    /**
                                     * Active state of Cursor
                                     */
                                    protected _isCursorEnabled: boolean;
                                    /**
                                     * Configure whether *cursors* should pick on this particular *series* or not.
                                     *
                                     * ```typescript
                                     *  // Example, prevent chart auto cursor from snapping to a series.
                                     *  LineSeries.setCursorEnabled(false)
                                     * ```
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     * @public
                                     */
                                    setCursorEnabled(state: boolean): this;
                                    /**
                                     * @returns Whether Cursor is enabled or not
                                     * @public
                                     */
                                    getCursorEnabled(): boolean;
                                }
                                /**
                                 * Abstract base class for all _3D series types_.
                                 *
                                 * 3D series are created with methods of {@link Chart3D}, for example {@link Chart3D.addPointSeries}.
                                 *
                                 * List of 3D series types:
                                 *
                                 * - {@link PointSeries3D}
                                 * - {@link LineSeries3D}
                                 * - {@link PointLineSeries3D}
                                 * - {@link BoxSeries3D}
                                 * - {@link SurfaceGridSeries3D}
                                 * - {@link SurfaceScrollingGridSeries3D}
                                 * @public
                                 */
                                export declare abstract class Series3D extends ChartComponent implements Series {
                                    protected _shadingStyle: ColorShadingStyle;
                                    /**
                                     * Set whether series is taken into account with automatic scrolling and fitting of attached axes.
                                     *
                                     * By default, this is true for all series.
                                     *
                                     * By setting this to `false`, any series can be removed from axis scrolling/fitting.
                                     *
                                     * ```ts
                                     *  // Example syntax, remove series from automatic scrolling / fitting.
                                     *  LineSeries.setAutoScrollingEnabled(false)
                                     * ```
                                     * @param enabled - `true` default, axes will take series into account in scrolling and fitting operations.
                                     *                      `false`, axes will ignore series boundaries.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAutoScrollingEnabled(enabled: boolean): this;
                                    /**
                                     * Get whether series is taken into account with automatic scrolling and fitting of attached axes.
                                     *
                                     * By default, this is true for all series.
                                     *
                                     * @returns `true` default, axes will take series into account in scrolling and fitting operations.
                                     *                      `false`, axes will ignore series boundaries.
                                     * @public
                                     */
                                    getAutoScrollingEnabled(): boolean;
                                    /**
                                     * Set Color Shading Style for series.
                                     *
                                     * Shading style changes the visual style of the rendering. See {@link ColorShadingStyles} for available shading styles.
                                     *
                                     * Use Simple color shading style:
                                     * ```js
                                     * series3D.setShadingStyle(new ColorShadingStyles.Simple())
                                     * ```
                                     *
                                     * Use Phong color shading style:
                                     * ```js
                                     * series3D.setShadingStyle(new ColorShadingStyles.Phong())
                                     * ```
                                     *
                                     * Configuring specular highlight for Phong shading style:
                                     * ```js
                                     * series3D.setShadingStyle(new ColorShadingStyles.Phong({
                                     *      specularReflection: 0.5,
                                     *      specularColor: ColorRGBA(255, 255, 255)
                                     * }))
                                     * ```
                                     *
                                     * @param shadingStyle - Color shading style to use for this series.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setColorShadingStyle(shadingStyle: ColorShadingStyle): this;
                                    /**
                                     * Get the currently used {@link ColorShadingStyle}.
                                     * @returns The Color Shading Style for the series.
                                     * @public
                                     */
                                    getColorShadingStyle(): ColorShadingStyle;
                                    /**
                                     * Set _3D depth test_ enabled for this series.
                                     *
                                     * By default this is enabled, meaning that any series that is rendered after this series and is behind this series will not be rendered.
                                     *
                                     * Can be disabled to alter 3D rendering behavior.
                                     *
                                     * ```js
                                     *  // Example syntax, disable depth test.
                                     *  pointSeries3D.setDepthTestEnabled(false)
                                     * ```
                                     *
                                     * @param enabled - Depth test enabled?
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setDepthTestEnabled(enabled: boolean): this;
                                    /**
                                     * Get _3D depth test_ enabled for this series.
                                     *
                                     * By default this is enabled, meaning that any series that is rendered after this series and is behind this series will not be rendered.
                                     *
                                     * Can be disabled to alter 3D rendering behavior.
                                     * @returns Depth test enabled?
                                     * @public
                                     */
                                    getDepthTestEnabled(): boolean;
                                    /**
                                     * @returns Max X value of the series
                                     * @public
                                     */
                                    getXMax(): number | undefined;
                                    /**
                                     * @returns Min X value of the series
                                     * @public
                                     */
                                    getXMin(): number | undefined;
                                    /**
                                     * @returns Max Y value of the series
                                     * @public
                                     */
                                    getYMax(): number | undefined;
                                    /**
                                     * @returns Min Y value of the series
                                     * @public
                                     */
                                    getYMin(): number | undefined;
                                    /**
                                     * @returns Max Z value of the series
                                     * @public
                                     */
                                    getZMax(): number | undefined;
                                    /**
                                     * @returns Min Z value of the series
                                     * @public
                                     */
                                    getZMin(): number | undefined;
                                }
                                /**
                                 * Marker that can be attached on a XY series.
                                 * Like CursorXYs its built of four parts:
                                 * PointMarker shows the location of the Marker,
                                 * ResultTable displays information of the point
                                 * and X&Y tickMarkers to show gridstroke on its axes.
                                 * @public
                                 */
                                export declare class SeriesMarkerXY<ResultTableBackgroundType extends UIBackground = UIBackground> extends ChartMarkerXY<ResultTableBackgroundType> {
                                    /**
                                     * @public
                                     */
                                    readonly owningSeries: SeriesXY;
                                    /**
                                     * Set position of SeriesMarker.
                                     * @param position - Location on SeriesMarkers scale. Marker will be attached to closest datapoint on its series.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setPosition(position: Point): this;
                                    /**
                                     * @returns True if object is attached or not attachable, false if it is not attached and attachable
                                     * @public
                                     */
                                    isAttached(): boolean;
                                }
                                /**
                                 * Interface describing options for all series that can be specified during creation time.
                                 * @public
                                 */
                                declare interface SeriesOptions {
                                    /**
                                     * Optional index to use for automatic coloring of series.
                                     *
                                     * Normally series are automatically colored differently when you create several series in the same chart.
                                     * However, in some cases you might want to alter this order of automatic coloring, or use the automatic color palettes on series that belong to different charts.
                                     *
                                     * In these scenarios you can use `automaticColorIndex` to tell each series individually what is its place in the default color palette.
                                     *
                                     * ```ts
                                     *  // Create series using the first color in default Theme palette.
                                     *  const series1 = chart.addLineSeries({ automaticColorIndex: 0 })
                                     *  // Create another series colored with the 3rd color.
                                     *  const series2 = chart.addLineSeries({ automaticColorIndex: 2 })
                                     * ```
                                     */
                                    automaticColorIndex?: number;
                                }
                                /**
                                 * Interface describing options for series that can be specified during creation time.
                                 * @public
                                 */
                                declare interface SeriesOptionsXY extends SeriesOptions {
                                    /**
                                     * Optional non-default X Axis to attach series to.
                                     *
                                     * By default, series are attached to the same X Axis, that is returned by {@link ChartXY.getDefaultAxisX}.
                                     */
                                    xAxis?: Axis;
                                    /**
                                     * Optional non-default Y Axis to attach series to.
                                     *
                                     * By default, series are attached to the same Y Axis, that is returned by {@link ChartXY.getDefaultAxisY}.
                                     */
                                    yAxis?: Axis;
                                }
                                /**
                                 * Interface that describes API for configuring data cleaning. There are a multitude of different basis' of configuring automatic data cleaning.
                                 *
                                 * Data cleaning by `minDataPointCount`:
                                 *
                                 * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
                                 *
                                 * ```js
                                 *  // Example syntax for specifying minDataPointCount
                                 *  series.setDataCleaning({ minDataPointCount: 10000 })
                                 * ```
                                 *
                                 * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
                                 * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
                                 *
                                 * **Partially supported data cleaning configurations:**
                                 *
                                 * These syntaxes are supported by only some select series types, refer to that particular series' API documentation to learn more.
                                 *
                                 * Data cleaning by `maxDataPointCount`:
                                 *
                                 * Specifying `maxDataPointCount` results in data cleaning always happening **exactly** when total data amount exceeds the supplied threshold.
                                 *
                                 * ```js
                                 *  // Example syntax for specifying maxDataPointCount
                                 *  series.setDataCleaning({ maxDataPointCount: 10000 })
                                 * ```
                                 *
                                 * `maxDataPointCount` is usually used in memory limited applications to prevent running out of memory.
                                 *
                                 * **`maxDataPointCount` is currently only supported by only select series:**
                                 * - {@link HeatmapScrollingGridSeries}.
                                 * - {@link OHLCSeries}.
                                 *
                                 * If the feature receives good support and usage from the user base, it might be expanded to all series types in a future release.
                                 * @public
                                 */
                                export declare interface SeriesWithDataCleaning {
                                    /**
                                     * Disable automatic data cleaning.
                                     *
                                     * ```js
                                     *  // Example syntax, disable data cleaning.
                                     *  series.setDataCleaning(undefined)
                                     * ```
                                     *
                                     * @param arg - Data cleaning configuration.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setDataCleaning(arg: undefined): this;
                                    /**
                                     * Enable automatic data cleaning by `minDataPointCount` configuration.
                                     *
                                     * Specifying `minDataPointCount` enables _lazy_ cleaning of data that is **outside view** as long as the remaining data amount doesn't go below the configured threshold.
                                     *
                                     * ```js
                                     *  // Example syntax for specifying minDataPointCount
                                     *  series.setDataCleaning({ minDataPointCount: 10000 })
                                     * ```
                                     *
                                     * Usage of `minDataPointCount` is recommended in most common applications that require automatic data cleaning.
                                     * The actual value is often not very particular, just setting it above `0` to enable it is usually enough (lazy data cleaning of out of view data).
                                     *
                                     * ```js
                                     *  // Example, enable lazy data cleaning of out of view data.
                                     *  series.setDataCleaning({ minDataPointCount: 1 })
                                     * ```
                                     *
                                     * @param arg - Data cleaning configuration.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setDataCleaning(arg: {
                                        minDataPointCount: number | undefined;
                                    }): this;
                                }
                                /**
                                 * Abstract super-class for 2D-series with X&Y axes
                                 * @public
                                 */
                                export declare abstract class SeriesXY<CursorPointInterface extends CursorPoint = CursorPoint, ScaleType extends ScaleXY = ScaleXY> extends Series2D<CursorPointInterface> {
                                    /**
                                     * Scale of the series
                                     * @public
                                     */
                                    readonly scale: ScaleType;
                                    /**
                                     * @public
                                     */
                                    readonly chart: ChartXY;
                                    /**
                                     * @public
                                     */
                                    readonly axisX: Axis;
                                    /**
                                     * @public
                                     */
                                    readonly axisY: Axis;
                                    /**
                                     * Configure draw order of the series.
                                     *
                                     * The drawing order of series inside same chart can be configured by configuring their `seriesDrawOrderIndex`.
                                     * This is a simple number that indicates which series is drawn first, and which last.
                                     *
                                     * The values can be any JS number, even a decimal. Higher number results in series being drawn closer to the top.
                                     *
                                     * By default, each series is assigned a running counter starting from `0` and increasing by `1` for each series.
                                     *
                                     * ```ts
                                     * 	// Example, create 2 series and configure them to be drawn in reverse order.
                                     * 	const series1 = ChartXY.addLineSeries()
                                     * 		.setDrawOrder({ seriesDrawOrderIndex: 1 })
                                     * 	const series2 = ChartXY.addLineSeries()
                                     * 		.setDrawOrder({ seriesDrawOrderIndex: 0 })
                                     * ```
                                     *
                                     * ```ts
                                     * 	// Example, ensure a series is drawn above other series.
                                     * 	SeriesXY.setDrawOrder({ seriesDrawOrderIndex: 1000 })
                                     * ```
                                     *
                                     * @param 	arg - Object with `seriesDrawOrderIndex` property.
                                     * @returns 		Object itself.
                                     * @public
                                     */
                                    setDrawOrder(arg: {
                                        seriesDrawOrderIndex: number;
                                    }): this;
                                    /**
                                     * Add Marker to the Series.
                                     * @param cursorBuilder -  Optional StaticCursorBuilderXY to customize the markers background shape (defaults to rectangle). See {@link MarkerBuilders} for example.
                                     * @returns SeriesMarkerXY
                                     * @public
                                     */
                                    addMarker: <ResultTableBackgroundType extends UIBackground>(cursorBuilder?: StaticCursorXYBuilder<ResultTableBackgroundType>) => SeriesMarkerXY<ResultTableBackgroundType>;
                                    /**
                                     * **Permanently** destroy the component.
                                     *
                                     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                     * **to the component and its children** in application code.
                                     * ```javascript
                                     * let chart = ...ChartXY()
                                     * let axisX = chart.getDefaultAxisX()
                                     * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                     * chart.dispose()
                                     * chart = undefined
                                     * axisX = undefined
                                     * ```
                                     * @returns  Object itself for fluent interface
                                     * @public
                                     */
                                    dispose(): this;
                                    /**
                                     * Remove the given marker from the collection of markers this Series has.
                                     * @param marker - Marker to remove.
                                     * @public
                                     */
                                    private removeMarker;
                                    /**
                                     * @returns Max X value of the series
                                     * @public
                                     */
                                    abstract getXMax(): number | undefined;
                                    /**
                                     * @returns Min X value of the series
                                     * @public
                                     */
                                    abstract getXMin(): number | undefined;
                                    /**
                                     * @returns Max Y value of the series
                                     * @public
                                     */
                                    abstract getYMax(): number | undefined;
                                    /**
                                     * @returns Min Y value of the series
                                     * @public
                                     */
                                    abstract getYMin(): number | undefined;
                                    getBoundaries(): Interval<Point>;
                                    /**
                                     * Configure whether *cursors* should pick on this particular *series* or not.
                                     *
                                     * ```typescript
                                     *  // Example, prevent chart auto cursor from snapping to a series.
                                     *  LineSeries.setCursorEnabled(false)
                                     * ```
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     * @public
                                     */
                                    setCursorEnabled(state: boolean): this;
                                }
                                /**
                                 * Interface for a function which builds ResultTable content when pointing at a SeriesXY.
                                 * @param tableContentBuilder - Builder that is used to build contents of ResultTable.
                                 *                                  Use addRow() method for adding content.
                                 * @param series - SeriesXY
                                 * @param x - X coordinate
                                 * @param y - Y coordinate
                                 * @param dataPoint - The pointed data point. Contains `x`, `y` as well as any additional information that user supplied.
                                 * @returns TableContentBuilder that was supplied
                                 * @public
                                 */
                                export declare type SeriesXYFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: SeriesXY, x: number, y: number, dataPoint: Point) => T;
                                /**
                                 * @public
                                 */
                                export declare interface SettableText {
                                    /**
                                     * Set the text of the entire shape.
                                     * @param text - Text string.
                                     * @public
                                     */
                                    setText(text: string): this;
                                }
                                /**
                                 * @public
                                 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                 */
                                declare type _ShapeCollectionProvider<UniqueProperties extends object, SharedProperties extends object> = {
                                    add: (instanceUniqueProperties: UniqueProperties, instanceSharedProperties: SharedProperties) => void;
                                    finishPlot: () => void;
                                };
                                /**
                                 * Simple color shading style.
                                 *
                                 * Colors each pixel exactly according to its material color.
                                 *
                                 * Colors are **not** affected by camera angle, lighting, etc.
                                 *
                                 * ```js
                                 *  // Example syntax, select simple color shading style.
                                 *  pointSeries3D.setColorShadingStyle(new ColorShadingStyles.Simple())
                                 * ```
                                 *
                                 * Color shading style is specified with {@link Series3D.setColorShadingStyle} method.
                                 *
                                 * _Simple color shading_ is really fast, which can be a crucial difference especially on low end devices, like laptops and mobile phones.
                                 * @public
                                 */
                                export declare class SimpleShadingStyle {
                                    readonly type = "simple";
                                }
                                /**
                                 * @public
                                 */
                                export declare interface SizePoint extends Point {
                                    size: number;
                                }
                                /**
                                 * Interface for a data point that contains an associated size property.
                                 *
                                 * Can be used for individual configuration of data points size.
                                 *
                                 * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                                 * Refer to series documentation for more detailed information.
                                 * @public
                                 */
                                export declare interface SizeValue {
                                    /**
                                     * Numeric size associated with the data point.
                                     *
                                     * Can be used for individual configuration of data points size.
                                     *
                                     * For some series types, individually sized data points might have to be explicitly enabled when the series is created.
                                     * Refer to series documentation for more detailed information.
                                     */
                                    readonly size?: number;
                                }
                                /**
                                 * Class that represents a single Slice of a Pie Chart.
                                 * @public
                                 */
                                export declare abstract class Slice extends ChartComponent {
                                    /**
                                     * Set value of Slice.
                                     * @param value - Numeric value
                                     * @returns Slice itself
                                     * @public
                                     */
                                    abstract setValue(value: number): this;
                                    /**
                                     * Get value of Slice.
                                     * @returns Numeric value
                                     * @public
                                     */
                                    abstract getValue(): number;
                                    /**
                                     * Get animated value of Slice.
                                     *
                                     * This always returns the currently **rendered value** of the Slice, which might be delayed by animations.
                                     * @returns Numeric value
                                     * @public
                                     */
                                    abstract getAnimatedValue(): number;
                                }
                                /**
                                 * Type of cursor result table formatter for pie charts, pyramid charts and funnel charts.
                                 *
                                 * Used with `setCursorResultTableFormatter` method.
                                 * @public
                                 */
                                declare type SlicedChartResultTableFormatter = <Chart extends SlicedCharts<any>, Slice extends SliceTypes = SliceTypes, T extends TableContentBuilder = TableContentBuilder>(tableContentBuilder: T, chart: Chart, slice: Slice, relativeValue: number) => T;
                                /**
                                 * Interface exists for enforcing shared APIs between Pie, Funnel and Pyramid Charts.
                                 * @public
                                 */
                                export declare interface SlicedCharts<T extends SliceTypes> {
                                    /**
                                     * Set lookup table
                                     * @param lookup - table
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setLUT(value: LUT): this;
                                    /**
                                     * Set fill style of Slices Labels.
                                     * @param value - FillStyle object or function which creates a new style based on previous
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Slice Labels.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getLabelFillStyle(): FillStyle;
                                    /**
                                     * Set font of Slice Labels.
                                     * @param value - FontSettings or mutator function for existing settings
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of Slice Labels.
                                     * @returns FontSettings
                                     * @public
                                     */
                                    getLabelFont(): FontSettings;
                                    /**
                                     * Set formatter of Slice Labels.
                                     *
                                     * See {@link SliceLabelFormatters} for a collection of default options.
                                     * @param labelFormatter - SliceLabelFormatter - function which generates text of Labels per Slice.
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setLabelFormatter(labelFormatter: SliceLabelFormatter<T>): this;
                                    /**
                                     * Get formatter of Slice Labels.
                                     * @returns SliceLabelFormatter - function which generates text of Labels per Slice.
                                     * @public
                                     */
                                    getLabelFormatter(): SliceLabelFormatter<T>;
                                    /**
                                     * Set style of Slices fill.
                                     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Chart will be assigned an incremental index,
                                     * which will be used to pick its fill style from this Palette.
                                     *
                                     * So, for example... We have a Sliced Chart with 5 Slices, and we give it a Palette with only 3 possible values
                                     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                                     * Note that this means, that the supplied Palette will have to work in a continuous manner!
                                     *
                                     * @param sliceFillStylePalette - Palette for FillStyle objects
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setSliceFillStyle(sliceFillStylePalette: Palette<FillStyle>): this;
                                    /**
                                     * Get style of Slices fill.
                                     * This style is managed as a continuous Palette of FillStyle objects. Each Slice of Chart will be assigned an incremental index,
                                     * which will be used to pick its fill style from this Palette.
                                     *
                                     * So, for example... We have a Sliced Chart with 5 Slices, and we give it a Palette with only 3 possible values
                                     * (0 = red, 1 = green, 2 = blue). The resulting Slice fill styles will be: red, green, blue, red, green.
                                     * Note that this means, that the supplied Palette will have to work in a continuous manner!
                                     *
                                     * @returns Palette<FillStyle>
                                     * @public
                                     */
                                    getSliceFillStyle(): Palette<FillStyle>;
                                    /**
                                     * Set style of Slices Stroke.
                                     * @param value - LineStyle object or function which creates a new style based on previous
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setSliceStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get style of Slices Stroke.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getSliceStrokeStyle(): LineStyle;
                                    /**
                                     * Set sorter of Slices as a comparator-function.
                                     *
                                     * For some commonly needed default implementations, can refer to {@link SliceSorters} collection.
                                     * @param sliceSorter - SliceSorter - function which sorts Slices of the Chart with JavaScript API: Array.sort.
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setSliceSorter(sliceSorter: SliceSorter<T>): this;
                                    /**
                                     * Get sorter of Slices as a comparator-function.
                                     * @returns SliceSorter - function which sorts Slices of the Chart with JavaScript API: Array.sort.
                                     * @public
                                     */
                                    getSliceSorter(): SliceSorter<T>;
                                    /**
                                     * This method is used for the adding slices in the Chart.
                                     * @param title - Slice title
                                     * @param value - Slice value
                                     * @public
                                     */
                                    addSlice(title: string, value: number): T;
                                    /**
                                     * This method is used for the adding multiple slices in the Chart.
                                     * @param multiSlice - Array of slices
                                     * @public
                                     */
                                    addSlices(multiSlice: {
                                        name: string;
                                        value: number;
                                    }[]): Array<T>;
                                    /**
                                     * Set if Slice should be highlighted when hovered over for all Slices.
                                     * @param state - True if Slice should highlight on hover, false if not.
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setSliceHighlightOnHover(state: boolean): this;
                                }
                                /**
                                 * Interval object defines the minimum and maximum slice interval.
                                 * @public
                                 */
                                export declare interface SliceInterval {
                                    min: number;
                                    max: number;
                                }
                                /**
                                 * Type of function which is used to format text of Slice Labels.
                                 * It is a function which generates a string based on a Slice along with some additional information.
                                 *
                                 * See {@link SliceLabelFormatters}-collection for quick access to some example implementations.
                                 *
                                 * Use with {@link SlicedCharts.setLabelFormatter}
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Use a default implementation
                                 * SlicedCharts.setLabelFormatter(SliceLabelFormatters.NamePlusRelativeValue)
                                 * // Use a custom implementation
                                 * SlicedCharts.setLabelFormatter((slice, relativeValue) => slice.getValue() + ' ')
                                 * ```
                                 * @param slice - Slice
                                 * @param relativeValue - Value of the Slice as a % of all Slice values
                                 * @returns String text for Label
                                 * @public
                                 */
                                export declare type SliceLabelFormatter<T extends SliceTypes> = (slice: T, relativeValue: number) => string;
                                /**
                                 * Collection of some example implementations of {@link SliceLabelFormatters}.
                                 *
                                 * Use with {@link SlicedCharts.setLabelFormatter}
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Use a default implementation
                                 * SlicedCharts.setLabelFormatter(SliceLabelFormatters.NamePlusRelativeValue)
                                 * // Use a custom implementation
                                 * SlicedCharts.setLabelFormatter((slice, relativeValue) => slice.getValue() + ' ')
                                 * ```
                                 * @public
                                 */
                                export declare const SliceLabelFormatters: {
                                    /**
                                     * Slice Label formatter for `${name}`.
                                     * @public
                                     */
                                    Name: SliceLabelFormatter<SliceTypes>;
                                    /**
                                     * Slice Label formatter for `${name}: ${Math.round(animatedValue)}`.
                                     * @public
                                     */
                                    NamePlusValue: SliceLabelFormatter<SliceTypes>;
                                    /**
                                     * Slice Label formatter for `${name}: ${(relativeValue * 100).toFixed(1)}%`.
                                     * @public
                                     */
                                    NamePlusRelativeValue: SliceLabelFormatter<SliceTypes>;
                                };
                                /**
                                 * SliceLabelIndices enum defines types of Slice labels.
                                 * @public
                                 */
                                export declare enum SliceLabelIndices {
                                    LabelsInsideSlices = 0,
                                    LabelsOnSides = 1
                                }
                                /**
                                 * Type of function which is used to sort Slices of a Chart with Slices.
                                 * It is a comparator function used with JavaScript API: Array.sort.
                                 *
                                 * See {@link SliceSorters} collection for quick access to some example implementations.
                                 *
                                 * Use with {@link SlicedCharts.setSliceSorter}
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Use a default implementation
                                 * SlicedCharts.setSliceSorter(SliceSorters.SortByValueDescending)
                                 * // Use a custom implementation
                                 * SlicedCharts.setSliceSorter((a, b) => a.getValue() - b.getValue())
                                 * ```
                                 * @param sliceA - Slice A
                                 * @param sliceB - Slice B
                                 * @returns Number which implies the sorted order between Slices A and B.
                                 *                  For more details, refer to Array documentation.
                                 * @public
                                 */
                                export declare type SliceSorter<T extends SliceTypes> = (sliceA: T, sliceB: T) => number;
                                /**
                                 * Collection of some example implementations of {@link SliceSorter}
                                 *
                                 * Use with {@link SlicedCharts.setSliceSorter}
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Use a default implementation
                                 * SlicedCharts.setSliceSorter(SliceSorters.SortByValueDescending)
                                 * // Use a custom implementation
                                 * SlicedCharts.setSliceSorter((a, b) => a.getValue() - b.getValue())
                                 * ```
                                 * @public
                                 */
                                export declare const SliceSorters: {
                                    /**
                                     * SliceSorter that sorts Slices based on their names using JS API: String.localeCompare.
                                     * @public
                                     */
                                    SortByName: SliceSorter<SliceTypes>;
                                    /**
                                     * SliceSorter that sorts Slices to ascending value order.
                                     * @public
                                     */
                                    SortByValueAscending: SliceSorter<SliceTypes>;
                                    /**
                                     * SliceSorter that sorts Slices to descending value order.
                                     * @public
                                     */
                                    SortByValueDescending: SliceSorter<SliceTypes>;
                                    /**
                                     * Disabled Slice sorting.
                                     * @public
                                     */
                                    None: SliceSorter<SliceTypes>;
                                };
                                /** @public */
                                export declare type SliceTypes = PieSlice | FunnelSlice;
                                /**
                                 * Style class for describing a *solid fill color*.
                                 *
                                 * Instances of SolidFill, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
                                 * but instead return a completely new modified object.
                                 *
                                 * **Properties of SolidFill:**
                                 * - `color`: fill color. Construct a *LCJS color* using one of the many available *factories*:
                                 *      * {@link ColorRGBA}
                                 *      * {@link ColorHEX}
                                 *      * {@link ColorCSS}
                                 *      * {@link ColorHSV}
                                 *
                                 * **SolidFill Usage:**
                                 *
                                 * Use SolidFill with:
                                 * - `setFillStyle` methods:
                                 *      * {@link PointSeries.setPointFillStyle}
                                 *      * {@link ChartXY.setTitleFillStyle}
                                 *
                                 * ```typescript
                                 *  // Example, style points fill with solid red color.
                                 *  PointSeries.setPointFillStyle(new SolidFill({
                                 *      color: ColorRGBA( 255, 0, 0 )
                                 *  }))
                                 * ```
                                 *
                                 * - Creating a {@link SolidLine}, or other *line style*, which can be used for styling a stroke, or border.
                                 *
                                 * *Watch out!* A common misuse is to attempt styling strokes or borders directly using *fill style* or *color*.
                                 * Remember, when calling a `setStrokeStyle` method, a *line style* is expected! Carefully observe the order of wrapped styles: *line style \<- fill style \<- color*
                                 *
                                 * ```typescript
                                 *  // Example, style line series stroke with solid red line.
                                 *  LineSeries.setStrokeStyle(new SolidLine({
                                 *      thickness: 1,
                                 *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
                                 *  }))
                                 * ```
                                 *
                                 * **Related information:**
                                 *
                                 * For more *fill styles*, see:
                                 * - {@link emptyFill}
                                 * - {@link IndividualPointFill}
                                 * - {@link PalettedFill}
                                 * - {@link RadialGradientFill}
                                 * - {@link LinearGradientFill}
                                 * - {@link ImageFill}
                                 * @public
                                 */
                                export declare class SolidFill extends VisibleFill {
                                    /**
                                     * Construct a SolidFill object, specifying any amount of its properties.
                                     *
                                     * ```typescript
                                     *  // Example using RGBA color factory.
                                     *  const solidRed = new SolidFill({
                                     *      color: ColorRGBA( 255, 0, 0 )
                                     *  })
                                     * ```
                                     *
                                     * ```typescript
                                     *  // Example using HEX color factory.
                                     *  const solidRed = new SolidFill({
                                     *      color: ColorHEX( '#ff0000' )
                                     *  })
                                     * ```
                                     * @param props - Object containing any amount of SolidFill properties.
                                     * @public
                                     */
                                    constructor(props?: Partial<VisibleFillStyleProperties>);
                                    /**
                                     * Construct a new SolidFill object based on this one, but with modified color.
                                     *
                                     * Example:
                                     * ```javascript
                                     * // specify new color
                                     * solidfill.setColor( ColorHEX('#F00') )
                                     *
                                     * // change individual color properties
                                     * solidfill.setColor( color => color.setA(80) )
                                     * ```
                                     * @param value - Either a Color object or a function, which will be used to create a new Color based on current value.
                                     * @returns New SolidFill object
                                     * @public
                                     */
                                    setColor(value: Color | ImmutableMutator<Color>): this;
                                    /**
                                     * Get color of SolidFill.
                                     * @returns Color object
                                     * @public
                                     */
                                    getColor(): Color;
                                    /**
                                     * Construct a new SolidFill object based on this one, but with a modified Alpha value.
                                     *
                                     * @param alpha - Value of Alpha channel [0-255]
                                     * @returns New SolidFill object
                                     * @public
                                     */
                                    setA(alpha: number): SolidFill;
                                    /**
                                     * Construct a new SolidFill object based on this one, but with a modified Red value.
                                     *
                                     * @param alpha - Value of Red channel [0-255]
                                     * @returns New SolidFill object
                                     * @public
                                     */
                                    setR(red: number): SolidFill;
                                    /**
                                     * Construct a new SolidFill object based on this one, but with a modified Green value.
                                     *
                                     * @param green - Value of Green channel [0-255]
                                     * @returns New SolidFill object
                                     * @public
                                     */
                                    setG(green: number): SolidFill;
                                    /**
                                     * Construct a new SolidFill object based on this one, but with a modified Blue value.
                                     *
                                     * @param blue - Value of Blue channel [0-255]
                                     * @returns New SolidFill object
                                     * @public
                                     */
                                    setB(blue: number): SolidFill;
                                }
                                /**
                                 * Factory for creating a SolidFill palette.
                                 * @param colorPalettes - Collection of default colors from PaletteFactory
                                 * @param amount - Amount of colors in the palette
                                 * @returns A new SolidFill palette
                                 * @public
                                 */
                                export declare const SolidFillPalette: (colorPalettes: PaletteFactory<Color>, amount: number, color?: Color) => Palette<FillStyle>;
                                /**
                                 * The Gauge Chart with a single solid colored slice.
                                 *
                                 * Solid Gauge extends Radial Gauge.
                                 * Use {@link GaugeChart}.setAngleInterval(start: number, end: number)** to set angular appearance of the Chart.
                                 *
                                 * Before setting the data, request the slice using *GaugeChart*.**getDefaultSlice()**
                                 * Set data range using *GaugeChart*.**setInterval(start: number, end: number)**
                                 * Set data using *GaugeChart*.**setValue(value: number)**
                                 * @public
                                 */
                                export declare class SolidGauge extends RadialGauge<SolidGaugeSlice, InternalSolidGaugeSlice> {
                                    /**
                                     * Get the slice of the gauge.
                                     * @returns Solid Gauge Slice object for further modification.
                                     * @public
                                     */
                                    getDefaultSlice(): SolidGaugeSlice;
                                    /**
                                     * Set the Auto Scaling mode enabled or disabled.
                                     * @param state - True - autofit is enabled, otherwise - False.
                                     * @returns Gauge itself for fluent interface.
                                     * @public
                                     */
                                    setAutoScaling(state: boolean): this;
                                    /**
                                     * Get the current state of the Auto Scaling mode.
                                     * @returns True - autofit is enabled, otherwise - False.
                                     * @public
                                     */
                                    getAutoScaling(): boolean;
                                    /**
                                     * Set a new number formatter for the Data label.
                                     * @param formatter - Number formatter
                                     * @returns Gauge itself for fluent interface.
                                     * @public
                                     */
                                    setDataLabelFormatter(formatter: Intl.NumberFormat | FormattingFunction): this;
                                    /**
                                     * Get the formatter for the Data label.
                                     * @returns Number formatter object.
                                     * @public
                                     */
                                    getDataLabelFormatter(): Intl.NumberFormat | FormattingFunction;
                                    /**
                                     * Set a new number formatter for the scale labels.
                                     * @param formatter - Number formatter
                                     * @returns Gauge itself for fluent interface.
                                     * @public
                                     */
                                    setIntervalLabelFormatter(formatter: Intl.NumberFormat | FormattingFunction): this;
                                    /**
                                     * Get the formatter for the scale labels.
                                     * @returns Number formatter object.
                                     * @public
                                     */
                                    getIntervalLabelFormatter(): Intl.NumberFormat | FormattingFunction;
                                    /**
                                     * Set padding between Gauge and interval labels in pixels.
                                     * @param padding - Number with pixel margin
                                     * @returns Gauge itself for fluent interface.
                                     * @public
                                     */
                                    setIntervalLabelPadding(padding: number): this;
                                    /**
                                     * Get padding around Chart in pixels.
                                     * @returns Padding datastructure
                                     * @public
                                     */
                                    getIntervalLabelPadding(): number;
                                    /**
                                     * Set thickness of the gauge.
                                     * @param thickness -
                                     * @returns Gauge itself for fluent interface.
                                     * @public
                                     */
                                    setThickness(thickness: number): this;
                                    /**
                                     * Set lookup table.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Gauge slice color depending on value
                                     * SolidGauge.setLUT(new LUT ( { steps: [ { value: 0, color: ColorRGBA( 0, 0, 0 ) },
                                     *  { value: 500, color: ColorRGBA( 12, 213, 87 ) } ],
                                     *  interpolate: true })
                                     * ```
                                     * @param lut - Lookup table |
                                     * @returns Gauge itself for fluent interface
                                     * @public
                                     */
                                    setLUT(lut?: LUT): this;
                                    /**
                                     * Set font of Gauge Data Label.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Specified FontSettings
                                     * SolidGauge.setDataLabelFont(new FontSettings({ size: 24, style: 'italic' }))
                                     * // Set to bold
                                     * SolidGauge.setDataLabelFont((fontSettings) => fontSettings.setWeight('bold'))
                                     * ```
                                     *
                                     * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
                                     * @returns Gauge itself for fluent interface.
                                     * @public
                                     */
                                    setDataLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of Gauge Data Label.
                                     * @returns FontSettings object for gauge data label.
                                     * @public
                                     */
                                    getDataLabelFont(): FontSettings;
                                    /**
                                     * Get the minimum size of the chart.
                                     * @returns Size \{x, y\} or undefined
                                     * @public
                                     */
                                    getMinimumSize(): Point | undefined;
                                    /**
                                     * Apply new fill style to Gauge Data label.
                                     * @param value - FillStyle or mutator to modify the existing one.
                                     * @returns Gauge itself for a fluent interface.
                                     * @public
                                     */
                                    setDataLabelFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get Fill Style of Gauge Data Label.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getDataLabelFillStyle(): FillStyle;
                                    /**
                                     * **Permanently** destroy the component.
                                     *
                                     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                     * **to the component and its children** in application code.
                                     * ```javascript
                                     * let chart = ...ChartXY()
                                     * let axisX = chart.getDefaultAxisX()
                                     * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                     * chart.dispose()
                                     * chart = undefined
                                     * axisX = undefined
                                     * ```
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    dispose(): this;
                                }
                                /**
                                 * Class of Solid colored slice Gauge slice.
                                 * The slice is represented as a single radial Arc shape.
                                 * @public
                                 */
                                export declare abstract class SolidGaugeSlice extends GaugeSlice {
                                    /**
                                     * Apply new fill style to a slice.
                                     * @param value - FillStyle for normal state.
                                     * @returns Slice itself for a fluent interface.
                                     * @public
                                     */
                                    abstract setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Subscribe to value change event.
                                     * @param listener - Event listener.
                                     * @returns Token that is used to unsubscribe from the event
                                     * @public
                                     */
                                    onValueChange(listener: ValueChangeEventListener<SolidGaugeSlice>): Token;
                                    /**
                                     * Subscribe to interval change event.
                                     * @param listener - Event listener.
                                     * @returns Token that is used to unsubscribe from the event
                                     * @public
                                     */
                                    onIntervalChange(listener: IntervalChangeEventListener<SolidGaugeSlice>): Token;
                                }
                                /**
                                 * Style class for describing a *solid line*.
                                 *
                                 * Instances of SolidLine, like all LCJS style classes, are *immutable*, meaning that its setters don't modify the actual object,
                                 * but instead return a completely new modified object.
                                 *
                                 * **Properties of SolidLine:**
                                 * - `thickness`: thickness of line as pixels.
                                 * - `fillStyle`: description of line fill color. The supported fillStyles vary per component.
                                 *
                                 * **SolidLine Usage:**
                                 *
                                 * Use SolidLine with:
                                 * - `setStrokeStyle` methods:
                                 *      * {@link LineSeries.setStrokeStyle}
                                 *      * {@link Axis.setStrokeStyle}
                                 *      * {@link CustomTick.setGridStrokeStyle}
                                 *      * etc.
                                 *
                                 * *Watch out!* A common misuse is to attempt styling strokes or borders directly using *fill style* or *color*.
                                 * Remember, when calling a `setStrokeStyle` method, a *line style* is expected! Carefully observe the order of wrapped styles: *line style \<- fill style \<- color*
                                 *
                                 * ```typescript
                                 *  // Example, set line series stroke style to 1px solid red.
                                 *  LineSeries.setStrokeStyle(new SolidLine({
                                 *      thickness: 1,
                                 *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
                                 *  }))
                                 * ```
                                 *
                                 * **Related information:**
                                 *
                                 * For more *line styles*, see:
                                 * - {@link emptyLine}
                                 * - {@link DashedLine}
                                 * @public
                                 */
                                export declare class SolidLine extends SolidLineStyleRecord implements LineStyle, StylePropFuncs<ThisType<SolidLine>, Omit<SolidLineStyleProperties, 'type' | 'lineType'>> {
                                    /**
                                     * Construct a SolidLine object, specifying any amount of its properties.
                                     *
                                     * ```typescript
                                     *  // Example, 1px solid red line.
                                     *  const solidRed = new SolidLine({
                                     *      thickness: 1,
                                     *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) })
                                     *  })
                                     *
                                     *  LineSeries.setStrokeStyle(solidRed)
                                     * ```
                                     * @param props - Object containing any amount of SolidLine properties.
                                     * @public
                                     */
                                    constructor(props?: Partial<Omit<SolidLineStyleProperties, 'type' | 'lineType'>>);
                                    /**
                                     * Construct a new Visible line object based on this one, but with modified fill style.
                                     *
                                     * Example (SolidFill):
                                     * ```javascript
                                     * // specify new fillstyle
                                     * solidLineStyle.setFillStyle( new SolidFill({
                                     *  color: ColorHex('#F00')
                                     * }) )
                                     * // change fillstyle properties
                                     * solidLineStyle.setFillStyle(
                                     *  solidfill => solidfill.setA( 80 )
                                     * )
                                     * ```
                                     * @param value - Either a SolidFill object or a function, which will be used to create a new VisibleFill based on current value.
                                     * @returns New SolidLine object
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): SolidLine;
                                    /**
                                     * Get fill style of SolidLine.
                                     * @returns SolidFill object
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Construct a new SolidLine object based on this one, but with modified thickness.
                                     *
                                     * -1 can be used to signify smallest available thickness.
                                     * With most features, this will result in slightly better GPU performance, but less detailed line.
                                     *
                                     * @param thickness - Thickness as pixels.
                                     * @public
                                     */
                                    setThickness(thickness: number | ImmutableMutator<number, number>): this;
                                    /**
                                     * Get thickness of SolidLine
                                     * @returns Thickness as pixels
                                     * @public
                                     */
                                    getThickness(): number;
                                }
                                /**
                                 * Interface for all properties of a LineStyle.
                                 * @public
                                 */
                                export declare interface SolidLineStyleProperties {
                                    type: 'linestyle';
                                    lineType: 'solid' | 'dashed';
                                    /**
                                     * Line fill style.
                                     */
                                    fillStyle: FillStyle;
                                    /**
                                     * Line thickness.
                                     *
                                     * -1 can be used to signify smallest available thickness.
                                     * With most features, this will result in slightly better GPU performance, but less detailed line.
                                     *
                                     * Default value: 1.
                                     */
                                    thickness: number;
                                }
                                /**
                                 * Record contractor for LineStyleProperties
                                 * @public
                                 */
                                declare const SolidLineStyleRecord: Record_2.Factory<SolidLineStyleProperties>;
                                /**
                                 * Internal enum for describing a basis of solving nearest coordinate from another.
                                 * @public
                                 */
                                declare enum SolveNearestBasis {
                                    /**
                                     * Nearest based on multi-dimensional distance between data points.
                                     */
                                    Nearest = 0,
                                    /**
                                     * Nearest based on only X distance.
                                     */
                                    NearestX = 1,
                                    /**
                                     * Nearest based on only Y distance.
                                     */
                                    NearestY = 2
                                }
                                /**
                                 * Description of a _Spark Area Chart_.
                                 *
                                 * Displays a miniature area chart.
                                 *
                                 * Can be used with {@link DataGrid}.
                                 *
                                 * ```ts
                                 *  // Example, spark area chart in a DataGrid
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-area',
                                 *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare type SparkAreaChart = {
                                    /**
                                     * Identifier that is used to select the spark chart type.
                                     */
                                    type: 'spark-area';
                                    /**
                                     * Data for spark area chart as a list of XY data points.
                                     *
                                     * ```ts
                                     *  // Example
                                     *  data: [{ x: 0, y: 100 }, { x: 1, y: 200 }, ...]
                                     * ```
                                     */
                                    data: Point[];
                                    /**
                                     * Optional fill style for area.
                                     */
                                    fillStyle?: FillStyle;
                                    /**
                                     * Optional style for area stroke.
                                     */
                                    strokeStyle?: LineStyle;
                                    /**
                                     * Optional list of XY markers for including extra data visualization components along the spark chart.
                                     *
                                     * ```ts
                                     *  // Example, display line at Y axis coordinate
                                     *  markers: [{ type: 'constant-line', axis: 'y', value: 20 }]
                                     * ```
                                     *
                                     * See {@link SparkChartXYMarker} for more information.
                                     */
                                    markers?: SparkChartXYMarker[];
                                };
                                /**
                                 * Description of a _Spark Bar Chart_.
                                 *
                                 * Displays a miniature bar chart.
                                 *
                                 * Can be used with {@link DataGrid}.
                                 *
                                 * ```ts
                                 *  // Example, spark bar chart in a DataGrid
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-bar',
                                 *      data: [0, 10, 6, 4, 9, 8, 3, 6]
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare type SparkBarChart = {
                                    /**
                                     * Identifier that is used to select the spark chart type.
                                     */
                                    type: 'spark-bar';
                                    /**
                                     * Data for bars.
                                     *
                                     * ```ts
                                     *  // Example,
                                     *  data: [ 10, 5, 8, 5, 2 ]
                                     * ```
                                     */
                                    data: number[];
                                    /**
                                     * Size of bar relative to gap.
                                     *
                                     * ```ts
                                     *  // Example, bar = 2 times as wide as gap between bars.
                                     *  barSize: 2,
                                     *  gap: 1
                                     * ```
                                     */
                                    barSize?: number;
                                    /**
                                     * Size of gap between bars relative to width of each bar.
                                     *
                                     * ```ts
                                     *  // Example, bar = 2 times as wide as gap between bars.
                                     *  barSize: 2,
                                     *  gap: 1
                                     * ```
                                     */
                                    gap?: number;
                                    /**
                                     * Optional fill style for Bars.
                                     */
                                    fillStyle?: FillStyle;
                                    /**
                                     * Optional stroke style for Bars.
                                     */
                                    strokeStyle?: LineStyle;
                                };
                                /**
                                 * Type definition for a description of a Spark Chart, a simple miniature chart.
                                 *
                                 * Can be used with {@link DataGrid}.
                                 *
                                 * ```ts
                                 *  // Example, spark line chart in a DataGrid
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-line',
                                 *      data: [0, 10, 6, 4, 9, 8, 3, 6]
                                 *  })
                                 * ```
                                 *
                                 * Supported types of Spark Charts:
                                 *
                                 * - {@link SparkLineChart}
                                 * - {@link SparkBarChart}
                                 * - {@link SparkWinLossChart}
                                 * - {@link SparkAreaChart}
                                 * - {@link SparkPieChart}
                                 *
                                 * @public
                                 */
                                export declare type SparkChart = SparkLineChart | SparkBarChart | SparkWinLossChart | SparkAreaChart | SparkPieChart;
                                /**
                                 * Type definition of a Spark Chart Axis Band Marker.
                                 * Can be included to show extra information alongside {@link SparkChart | Spark Charts}.
                                 * Highlights an interval along 1 Axis (either X or Y).
                                 *
                                 * ```ts
                                 *  // Example, spark line chart with a axis band.
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-line',
                                 *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                 *      markers: [{
                                 *          type: 'axis-band',
                                 *          axis: 'x',
                                 *          start: 10,
                                 *          end: 15,
                                 *      }]
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare type SparkChartAxisBand = {
                                    /**
                                     * Identifier used to select the type of Marker.
                                     */
                                    type: 'axis-band';
                                    /**
                                     * Selection of Axis (X or Y).
                                     */
                                    axis: 'x' | 'y';
                                    /**
                                     * Start location on Axis.
                                     */
                                    start: number;
                                    /**
                                     * End location on Axis.
                                     */
                                    end: number;
                                    /**
                                     * Optional fill style of Band.
                                     */
                                    fillStyle?: FillStyle;
                                    /**
                                     * Optional stroke style of Band.
                                     */
                                    strokeStyle?: LineStyle;
                                };
                                /**
                                 * Type definition of a Spark Chart Constant Line Marker.
                                 * Can be included to show extra information alongside {@link SparkChart | Spark Charts}.
                                 * Highlights an location along 1 Axis (either X or Y).
                                 *
                                 * ```ts
                                 *  // Example, spark line chart with a constant line marker.
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-line',
                                 *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                 *      markers: [{
                                 *          type: 'constant-line',
                                 *          axis: 'x',
                                 *          value: 10,
                                 *      }]
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare type SparkChartConstantLine = {
                                    /**
                                     * Identifier used to select the type of Marker.
                                     */
                                    type: 'constant-line';
                                    /**
                                     * Selection of Axis (X or Y).
                                     */
                                    axis: 'x' | 'y';
                                    /**
                                     * Location on Axis.
                                     */
                                    value?: number;
                                    /**
                                     * Optional stroke style of Constant line.
                                     */
                                    strokeStyle?: LineStyle;
                                };
                                /**
                                 * Type definition of a Spark Chart Point Marker.
                                 * Can be included to show extra information alongside {@link SparkChart | Spark Charts}.
                                 * Highlights a single XY coordinate with a marker.
                                 * Coordinate can be hard defined with data values or automatically assigned from peak value, start, end, etc.
                                 *
                                 * ```ts
                                 *  // Example, spark line chart with a point marker at max Y peak.
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-line',
                                 *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                 *      markers: [{
                                 *          type: 'point',
                                 *          value: 'max'
                                 *      }]
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare interface SparkChartPointMarker {
                                    /**
                                     * Identifier used to select the type of Marker.
                                     */
                                    type: 'point';
                                    /**
                                     * Location of the Point Marker. Following values are supported:
                                     *
                                     * - `'start'`: Position marker at the first XY coordinate of the Spark Chart.
                                     * - `'end'`: Position marker at the last XY coordinate of the Spark Chart.
                                     * - `'min'`: Position marker at the lowest XY coordinate of the Spark Chart (along Y axis).
                                     * - `'max'`: Position marker at the highest XY coordinate of the Spark Chart (along Y axis).
                                     * - `{ x: 5, y: 10 }`: Position marker at exactly X = 5, Y = 10.
                                     */
                                    value: Point | 'start' | 'end' | 'min' | 'max';
                                    /**
                                     * Optional shape of marker.
                                     */
                                    shape?: PointShape;
                                    /**
                                     * Optional size of marker.
                                     */
                                    size?: number;
                                    /**
                                     * Optional rotation of marker.
                                     */
                                    rotation?: number;
                                    /**
                                     * Optional fill style of marker.
                                     */
                                    fillStyle?: FillStyle;
                                }
                                /**
                                 * Type definition of a Spark Chart XY Marker.
                                 * These can be included to show extra information alongside {@link SparkChart | Spark Charts}.
                                 *
                                 * The following types of markers are supported:
                                 *
                                 * - {@link SparkChartPointMarker | Point Marker} Highlights a single XY coordinate with a marker. Coordinate can be hard defined with data values or automatically assigned from peak value, start, end, etc.
                                 * - {@link SparkChartAxisBand | Axis Band} Highlights an interval along a single Axis (either X or Y).
                                 * - {@link SparkChartConstantLine | Constant Line} Highlights a location along a single Axis (either X or Y).
                                 *
                                 * @public
                                 */
                                export declare type SparkChartXYMarker = SparkChartPointMarker | SparkChartAxisBand | SparkChartConstantLine;
                                /**
                                 * Description of a _Spark Line Chart_.
                                 *
                                 * Displays a miniature XY line chart.
                                 *
                                 * Can be used with {@link DataGrid}.
                                 *
                                 * ```ts
                                 *  // Example, spark line chart in a DataGrid
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-line',
                                 *      data: [0, 10, 6, 4, 9, 8, 3, 6]
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare interface SparkLineChart {
                                    /**
                                     * Identifier that is used to select the spark chart type.
                                     */
                                    type: 'spark-line';
                                    /**
                                     * Data for spark line chart as a list of XY data points.
                                     *
                                     * ```ts
                                     *  // Example
                                     *  data: [{ x: 0, y: 100 }, { x: 1, y: 200 }, ...]
                                     * ```
                                     */
                                    data: Point[];
                                    /**
                                     * Optional style for line.
                                     */
                                    strokeStyle?: LineStyle;
                                    /**
                                     * Optional list of XY markers for including extra data visualization components along the spark chart.
                                     *
                                     * ```ts
                                     *  // Example, display line at Y axis coordinate
                                     *  markers: [{ type: 'constant-line', axis: 'y', value: 20 }]
                                     * ```
                                     *
                                     * See {@link SparkChartXYMarker} for more information.
                                     */
                                    markers?: SparkChartXYMarker[];
                                }
                                /**
                                 * Description of a _Spark Pie Chart_.
                                 *
                                 * Displays a miniature pie chart.
                                 *
                                 * Can be used with {@link DataGrid}.
                                 *
                                 * ```ts
                                 *  // Example, spark pie chart in a DataGrid
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-pie',
                                 *      data: [0, 10, 6, 4, 9, 8, 3, 6]
                                 *  })
                                 * ```
                                 *
                                 * Alternatively, each slice can be assigned an individual fill style:
                                 *
                                 * ```ts
                                 *  // Example, spark pie chart in a DataGrid
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-pie',
                                 *      data: [
                                 *          { value: 5, fillStyle: new SolidFill({ color: ColorCSS('red') }) },
                                 *          { value: 8, fillStyle: new SolidFill({ color: ColorCSS('green') }) },
                                 *          { value: 3, fillStyle: new SolidFill({ color: ColorCSS('blue') }) },
                                 *      ]
                                 *  })
                                 * ```
                                 *
                                 * @public
                                 */
                                export declare type SparkPieChart = {
                                    /**
                                     * Identifier that is used to select the spark chart type.
                                     */
                                    type: 'spark-pie';
                                    /**
                                     * Data for pie slices as either list of numbers or list of numbers and fill styles.
                                     *
                                     * ```ts
                                     *  // Example, all slices same style
                                     *  data: [0, 10, 6, 4, 9, 8, 3, 6]
                                     * ```
                                     *
                                     * ```ts
                                     *  // Example, individual styles
                                     *  data: [
                                     *      { value: 5, fillStyle: new SolidFill({ color: ColorCSS('red') }) },
                                     *      { value: 8, fillStyle: new SolidFill({ color: ColorCSS('green') }) },
                                     *      { value: 3, fillStyle: new SolidFill({ color: ColorCSS('blue') }) },
                                     *  ]
                                     * ```
                                     */
                                    data: number[] | {
                                        value: number;
                                        fillStyle: FillStyle;
                                    }[];
                                    /**
                                     * Optional stroke style for slices.
                                     */
                                    strokeStyle?: LineStyle;
                                };
                                /**
                                 * Description of a _Spark Win-Loss Chart_.
                                 *
                                 * Displays a miniature win-loss chart.
                                 *
                                 * Can be used with {@link DataGrid}.
                                 *
                                 * ```ts
                                 *  // Example, win-loss chart in a DataGrid
                                 *  DataGrid.setCellContent(0, 0, {
                                 *      type: 'spark-win-loss',
                                 *      data: [0, 10, 6, 4, 9, 8, 3, 6],
                                 *      threshold: 5,
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare type SparkWinLossChart = {
                                    /**
                                     * Identifier that is used to select the spark chart type.
                                     */
                                    type: 'spark-win-loss';
                                    /**
                                     * Data as list of numbers.
                                     *
                                     * ```ts
                                     *  // Example,
                                     *  data: [ 10, 5, 8, 5, 2 ]
                                     * ```
                                     */
                                    data: number[];
                                    /**
                                     * Size of bar relative to gap.
                                     *
                                     * ```ts
                                     *  // Example, bar = 2 times as wide as gap between bars.
                                     *  barSize: 2,
                                     *  gap: 1
                                     * ```
                                     */
                                    barSize?: number;
                                    /**
                                     * Size of gap between bars relative to width of each bar.
                                     *
                                     * ```ts
                                     *  // Example, bar = 2 times as wide as gap between bars.
                                     *  barSize: 2,
                                     *  gap: 1
                                     * ```
                                     */
                                    gap?: number;
                                    /**
                                     * Win-loss threshold. Data values above this are considered as "win" and below "loss".
                                     */
                                    threshold?: number;
                                    /**
                                     * Optional fill style for "win" bars.
                                     */
                                    winFillStyle?: FillStyle;
                                    /**
                                     * Optional fill style for "loss" bars.
                                     */
                                    lossFillStyle?: FillStyle;
                                    /**
                                     * Optional stroke style bars.
                                     */
                                    strokeStyle?: LineStyle;
                                };
                                /**
                                 * Container for shapes of spider axes and drawing logic.
                                 * @public
                                 */
                                export declare class SpiderAxis {
                                    /**
                                     * @public
                                     */
                                    readonly scale: LinearScaleXY;
                                    /**
                                     * @public
                                     */
                                    readonly chart: SpiderChart;
                                    /**
                                     * @public
                                     */
                                    readonly tag: string;
                                    /**
                                     * @public
                                     */
                                    readonly axisScale: Scale1D;
                                    /**
                                     * Update axis label style and return its computed size.
                                     * Used for computation of chart margins before drawing.
                                     * @public
                                     */
                                    getLabelSize(): Point;
                                    /**
                                     * **Permanently** destroy the component.
                                     *
                                     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                     * **to the component and its children** in application code.
                                     * ```javascript
                                     * let chart = ...ChartXY()
                                     * let axisX = chart.getDefaultAxisX()
                                     * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                     * chart.dispose()
                                     * chart = undefined
                                     * axisX = undefined
                                     * ```
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    dispose(): void;
                                }
                                /**
                                 * Type of data-structure that defines how an axis label is positioned.
                                 * @public
                                 */
                                export declare interface SpiderAxisLabelPosition {
                                    /**
                                     * Alignment X [-1, 1], where -1 is left and 1 is right extreme
                                     */
                                    alignmentX: number;
                                    /**
                                     * Alignment Y [-1, 1], where -1 is bottom and 1 is top extreme
                                     */
                                    alignmentY: number;
                                    /**
                                     * Padding in X direction as pixels
                                     */
                                    paddingX: number;
                                    /**
                                     * Padding in Y direction as pixels
                                     */
                                    paddingY: number;
                                }
                                /**
                                 * Type of an axis label strategy function.
                                 * Defines how axis labels are aligned.
                                 * @param result - DataStructure that is used to pass result
                                 * @param axisIndex - Index of axis. 0 is always directly up
                                 * @param axisCount - Amount of axes in chart
                                 * @param axisTag - Name of axis
                                 * @param axisAngle - Angle of axis in radians
                                 * @param labelPadding - Label padding as set in chart
                                 * @returns SpiderAxisLabelPosition (modified first parameter of function)
                                 * @public
                                 */
                                export declare type SpiderAxisLabelStrategy = (result: SpiderAxisLabelPosition, axisIndex: number, axisCount: number, axisTag: string, axisAngle: number, labelPadding: number) => SpiderAxisLabelPosition;
                                /**
                                 * Chart for visualizing data in a radial form as dissected by named axes.
                                 *
                                 * *Charts* are created by methods of {@link LightningChart} interface or a {@link Dashboard}.
                                 *
                                 * A **SpiderChart** can have any number of {@link SpiderSeries} added to it using {@link SpiderChart.addSeries}.
                                 * Data can then be pushed in with {@link SpiderSeries.addPoints}
                                 *
                                 * By default, *SpiderChart* automatically creates *Axes* based on the data that are pushed to its *Series*.
                                 * @public
                                 */
                                export declare class SpiderChart<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends ChartWithSeries<SpiderSeries> implements ChartWithCursor<CursorResultTableBackgroundType> {
                                    /**
                                     * Get series of a chart
                                     * @returns Array of series
                                     * @public
                                     */
                                    getSeries(): SpiderSeries[];
                                    /**
                                     * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
                                     *
                                     * **Example usage:**
                                     *
                                     * ```typescript
                                     *  // Example 1, style AutoCursor ResultTable.
                                     *  SpiderChart.setAutoCursor((autoCursor) => autoCursor
                                     *      .setResultTable((resultTable) => resultTable
                                     *          .setOrigin(UIOrigins.LeftTop)
                                     *          .setTextFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                     *          .setTextFont((font) => font
                                     *              .setSize(12)
                                     *              .setFamily('sans-serif')
                                     *          )
                                     *          .setBackground((background) => background
                                     *              .setFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 0) }))
                                     *          )
                                     *      )
                                     *  )
                                     * ```
                                     *
                                     * ```typescript
                                     *  // Example 2, style AutoCursor PointMarker.
                                     *  SpiderChart.setAutoCursor((autoCursor) => autoCursor
                                     *      .setPointMarker((marker) => marker
                                     *          .setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                     *          .setSize({ x: 10, y: 10 })
                                     *          .setStrokeStyle(emptyLine),
                                     *      ),
                                     *  )
                                     * ```
                                     * @param mutator - Callback function that receives reference to the charts `AutoCursor`.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAutoCursor(mutator: Mutator<AutoCursor<CursorResultTableBackgroundType>>): this;
                                    /**
                                     * Get reference to charts `AutoCursor`.
                                     *
                                     * See {@link AutoCursor} for all available methods for configuring the `AutoCursor`.
                                     *
                                     * @returns `AutoCursor`.
                                     * @public
                                     */
                                    getAutoCursor(): AutoCursor<CursorResultTableBackgroundType>;
                                    /**
                                     * Set chart `AutoCursor` behavior, by selecting a preset option from {@link AutoCursorModes}.
                                     *
                                     * Possible values:
                                     * - `AutoCursorModes.snapToClosest` (default) | *AutoCursor* snaps to closest data point from mouse location.
                                     * - `AutoCursorModes.onHover` | *AutoCursor* is only shown when it is directly over a *series*. NOTE: Series mouse interactions must be enabled for this to work!
                                     * - `AutoCursorModes.disabled` | *AutoCursor* is disabled
                                     *
                                     * ```typescript
                                     *  // Example, disable AutoCursor
                                     *  SpiderChart.setAutoCursorMode(AutoCursorModes.disabled)
                                     * ```
                                     *
                                     * **Related information:**
                                     *
                                     * On *series* level, *AutoCursor* behavior can be configured individually for each *series*, and there are also more *series* specific options available.
                                     * Here is `LineSeries` for example:
                                     *
                                     * - {@link Series2D.setCursorEnabled} | configure whether cursor should pick on the series or not.
                                     * - {@link SeriesXY.setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                                     * - {@link LineSeries.setCursorInterpolationEnabled} | configure whether cursor should interpolate the displayed data point between the two closest data points, or snap to the nearest *real* data point.
                                     * - {@link SeriesXY.setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
                                     *
                                     * @param mode - Selection of *AutoCursor* behavior.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAutoCursorMode(mode: AutoCursorModes): this;
                                    /**
                                     * Get `AutoCursor` behavior, from a collection of preset options ({@link AutoCursorModes}).
                                     * @returns Active selection of *AutoCursor* behavior.
                                     * @public
                                     */
                                    getAutoCursorMode(): AutoCursorModes;
                                    /**
                                     * Add a new axis to Spider Chart
                                     * @param axis - Axis tag
                                     * @returns Object itself
                                     * @public
                                     */
                                    addAxis(tagOrAxis: string): this;
                                    /**
                                     * Check if Chart has an Axis with specified tag
                                     * @param tag - Name of desirable axis
                                     * @returns True if axis exists, false if not.
                                     * @public
                                     */
                                    hasAxis: (tag: string) => boolean;
                                    /**
                                     * Format value along an axis.
                                     * @param value - Value along an axis
                                     * @param formatter - Optional explicit formating function
                                     * @returns Value formated to string
                                     * @public
                                     */
                                    formatValue: (value: number) => string;
                                    /**
                                     * Adds a new SpiderSeries to the SpiderChart.
                                     * @param options -  Optional object with readonly configuration arguments for SpiderSeries.
                                     *
                                     * ```typescript
                                     *  // Example,
                                     *   SpiderChart.addSeries()
                                     *   SpiderChart.addSeries({ automaticColorIndex: 5 })
                                     *   SpiderChart.addSeries({ pointShape: PointShape.Triangle, automaticColorIndex: 10 })
                                     * ```
                                     *
                                     * @returns SpiderSeries instance
                                     * @public
                                     */
                                    addSeries(options?: SpiderSeriesOptions): SpiderSeries;
                                    /**
                                     * Adds a new SpiderSeries to the SpiderChart.
                                     * @param pointShape - Shape of points for SpiderSeries. Defaults to PointShape.Circle
                                     *
                                     * ```typescript
                                     *  // Example,
                                     *   SpiderChart.addSeries()
                                     *   SpiderChart.addSeries(PointShape.Triangle)
                                     * ```
                                     *
                                     * @returns SpiderSeries instance
                                     * @public
                                     * @deprecated  This method signature is deprecated since v4.2.0. Use other signature instead: `addSeries({ pointShape })`
                                     */
                                    addSeries(pointShape?: PointShape): SpiderSeries;
                                    /**
                                     * Get number of series inside chart.
                                     * @returns Amount of series inside chart
                                     * @public
                                     */
                                    getSeriesCount(): number;
                                    /**
                                     * Set mode of SpiderCharts web and background.
                                     * @param webMode - Enum SpiderWebMode
                                     * @returns Object itself
                                     * @public
                                     */
                                    setWebMode(webMode: SpiderWebMode): this;
                                    /**
                                     * Get mode of SpiderCharts web and background.
                                     * @returns Enum SpiderWebMode
                                     * @public
                                     */
                                    getWebMode(): SpiderWebMode;
                                    /**
                                     * Set count of 'webs' displayed.
                                     * @param webCount - Count of web lines
                                     * @returns Object itself
                                     * @public
                                     */
                                    setWebCount(webCount: number): this;
                                    /**
                                     * Get count of 'webs' displayed
                                     * @returns Count of web lines
                                     * @public
                                     */
                                    getWebCount(): number;
                                    /**
                                     * Set style of spider charts webs as LineStyle.
                                     * @param value - LineStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setWebStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get fill style of web lines.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getWebStyle(): LineStyle;
                                    /**
                                     * Set fill style of scale labels.
                                     * @param value - FillStyle object or mutator to modify existing one
                                     * @public
                                     */
                                    setScaleLabelStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of scale labels.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getScaleLabelStyle(): FillStyle;
                                    /**
                                     * Set font of scale labels.
                                     * @param value - FontSettings or mutator function for existing settings
                                     * @returns Object itself
                                     * @public
                                     */
                                    setScaleLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of scale labels.
                                     * @returns FontSettings
                                     * @public
                                     */
                                    getScaleLabelFont(): FontSettings;
                                    /**
                                     * Set padding of scale labels.
                                     * @param padding - Padding in pixels
                                     * @returns Object itself
                                     * @public
                                     */
                                    setScaleLabelPadding(padding: pixel): this;
                                    /**
                                     * Get padding of scale labels.
                                     * @returns Padding in pixels
                                     * @public
                                     */
                                    getScaleLabelPadding(): pixel;
                                    /**
                                     * Set strategy for drawing scale labels.
                                     * Defines on which positions labels are drawn and whether they are flipped or not.
                                     * @param scaleLabelStrategy - SpiderScaleLabelStrategy or undefined to never show scale labels
                                     * @returns Object itself
                                     * @public
                                     */
                                    setScaleLabelStrategy(scaleLabelStrategy?: SpiderScaleLabelStrategy): this;
                                    /**
                                     * Set strategy for formatting scale labels.
                                     *
                                     * ```javascript
                                     *  chart.setScaleLabelFormatter((value) => `${value} km`)
                                     * ```
                                     * @param formatter - cb function that formats the values of scale
                                     * @returns Object itself
                                     * @public
                                     */
                                    setScaleLabelFormatter(formatter: (value: number) => string): this;
                                    /**
                                     * Set fill style of axis labels.
                                     * @param value - FillStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setAxisLabelStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of axis labels.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getAxisLabelStyle(): FillStyle;
                                    /**
                                     * Set font of axis labels.
                                     * @param value - FontSettings or mutator function for existing settings
                                     * @returns Object itself
                                     * @public
                                     */
                                    setAxisLabelFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of axis labels.
                                     * @returns FontSettings object
                                     * @public
                                     */
                                    getAxisLabelFont(): FontSettings;
                                    /**
                                     * Set theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @param enabled - Theme effect enabled
                                     * @returns          Object itself.
                                     * @public
                                     */
                                    setAxisLabelEffect(enabled: boolean): this;
                                    /**
                                     * Get theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                     * @public
                                     */
                                    getAxisLabelEffect(): boolean;
                                    /**
                                     * Set padding of axis labels.
                                     * NOTE: The value of this padding is simply passed to the axis label strategy of chart,
                                     * so overriding the default strategy will naturally leave the handling of padding logic up to you.
                                     * @param padding - Padding in pixels
                                     * @returns Object itself
                                     * @public
                                     */
                                    setAxisLabelPadding(padding: pixel): this;
                                    /**
                                     * Get padding of axis labels.
                                     * NOTE: The value of this padding is simply passed to the axis label strategy of chart,
                                     * so overriding the default strategy will naturally leave the handling of padding logic up to you.
                                     * @returns Padding in pixels
                                     * @public
                                     */
                                    getAxisLabelPadding(): pixel;
                                    /**
                                     * Set strategy for drawing axis labels.
                                     * Defines how axis labels are aligned.
                                     * @param axisLabelStrategy - SpiderAxisLabelStrategy or undefined to never show axis labels
                                     * @returns Object itself
                                     * @public
                                     */
                                    setAxisLabelStrategy(axisLabelStrategy?: SpiderAxisLabelStrategy): this;
                                    /**
                                     * Set style of axes as LineStyle.
                                     * @param value - LineStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setAxisStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get style of axes as LineStyle.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getAxisStyle(): LineStyle;
                                    /**
                                     * Set style of axis nibs as LineStyle.
                                     * @param value - LineStyle object or mutator to modify existing one
                                     * @returns Object itself
                                     * @public
                                     */
                                    setNibStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get style of axis nibs as LineStyle.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getNibStyle(): LineStyle;
                                    /**
                                     * Set length of axis nibs in pixels.
                                     * @param length - Sum length of nibs in pixels (both directions)
                                     * @public
                                     */
                                    setNibLength(length: number): this;
                                    /**
                                     * Get length of axis nibs in pixels.
                                     * @returns Length of nibs in pixels
                                     * @public
                                     */
                                    getNibLength(): number;
                                    /**
                                     * Specifies if auto creation of axis is turned on or not
                                     * @param createAxesAutomatically - State of automatic axis creation
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setAutoAxis(createAxesAutomatically: boolean): this;
                                    /**
                                     * @returns Automatic axis creation state
                                     * @public
                                     */
                                    getAutoAxis(): boolean;
                                    /**
                                     * Set if mouse-interactions on chart are enabled or not
                                     * @param enabled - Boolean flag
                                     * @returns Object itself
                                     * @public
                                     */
                                    setMouseInteractions(enabled: boolean): this;
                                    /**
                                     * Get are mouse-interactions on chart enabled or not
                                     * @returns Boolean flag
                                     * @public
                                     */
                                    getMouseInteractions(): boolean;
                                    /**
                                     * Sets the AxisScrollStrategy of Charts Axes
                                     * @param scrollStrategy - AxisScrollStrategy or undefined to disable automatic scrolling.
                                     *                          See {@link AxisScrollStrategies} for a collection of options.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setAxisScrollStrategy(scrollStrategy?: AxisScrollStrategy): this;
                                    /**
                                     * Gets the AxisScrollStrategy of Charts Axes
                                     * @public
                                     */
                                    getAxisScrollStrategy(): AxisScrollStrategy | undefined;
                                    /**
                                     * Set interval of Charts Axes
                                     * @param edge - Value at edges of chart
                                     * @param center - Value at center of chart. Defaults to zero
                                     * @returns Object itself
                                     * @public
                                     */
                                    setAxisInterval(edge: number, center?: number): this;
                                    /**
                                     * Get axis value at center of chart
                                     * @returns Value at center of chart
                                     * @public
                                     */
                                    getOriginValue(): number;
                                    /**
                                     * Get axis value at edges of chart
                                     * @returns Value at edges of chart
                                     * @public
                                     */
                                    getEdgeValue(): number;
                                    /**
                                     * **Permanently** destroy the component.
                                     *
                                     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                     * **to the component and its children** in application code.
                                     * ```javascript
                                     * let chart = ...ChartXY()
                                     * let axisX = chart.getDefaultAxisX()
                                     * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                     * chart.dispose()
                                     * chart = undefined
                                     * axisX = undefined
                                     * ```
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    dispose(): this;
                                    /**
                                     * Get minimum size of Panel.
                                     * Depending on the type of class this value might be automatically computed to fit different elements.
                                     * @returns Vec2 minimum size or undefined if unimplemented
                                     * @public
                                     */
                                    getMinimumSize(): Point | undefined;
                                }
                                /**
                                 * Interface for readonly configuration of {@link SpiderChart}.
                                 *
                                 * Some properties of `SpiderChart` can only be configured when it is created. These arguments are all optional, and are wrapped in a single object parameter:
                                 *
                                 * ```typescript
                                 *  // Example, create chart with specified color theme.
                                 *  const chart = LightningChart.Spider({
                                 *      theme: Themes.light,
                                 *  })
                                 * ```
                                 *
                                 * *Watch out!* The full set of available readonly configuration parameters depends on if the chart is *standalone*, or inside a *dashboard*:
                                 *
                                 * For *standalone* `SpiderChart`, more parameters are documented in {@link LightningChart.Spider}.
                                 *
                                 * For *dashboard* `SpiderChart`, more parameters are documented in {@link Dashboard.createSpiderChart}.
                                 *
                                 *
                                 * **Commonly used properties:**
                                 *
                                 * - {@link SpiderChartOptions.theme}: Specify chart color *theme*.
                                 * - {@link SpiderChartOptions.animationsEnabled}: Convenience flag to disable all animations from chart.
                                 *
                                 * **Example usage:**
                                 *
                                 * ```typescript
                                 *  // Example 1, create chart with default configuration.
                                 *  const chart = LightningChart.Spider({})
                                 * ```
                                 *
                                 * ```typescript
                                 *  // Example 2, create chart with specified color theme.
                                 *  const chart = LightningChart.Spider({
                                 *      theme: Themes.light,
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare interface SpiderChartOptions<CursorResultTableBackgroundType extends UIBackground = UIBackground> extends CommonChartOptions {
                                    /**
                                     * Builder for the charts' *auto cursor*. Use {@link AutoCursorBuilders | AutoCursorBuilders.Spider} to modify the default builder, using methods of {@link AutoCursor2DBuilder}.
                                     *
                                     * ```typescript
                                     *  // Example, change cursor ResultTable background shape.
                                     *  const chart = LightningChart.Spider({
                                     *      autoCursorBuilder: AutoCursorBuilders.Spider
                                     *          .setResultTableBackground(UIBackgrounds.Circle)
                                     *  })
                                     * ```
                                     * @public
                                     */
                                    autoCursorBuilder?: AutoCursor2DBuilder<CursorResultTableBackgroundType>;
                                }
                                /**
                                 * Interface that can be used to define {@link SpiderChart} configurations, when inside a  {@link Dashboard},
                                 * that can't be changed after creation.
                                 *
                                 *  Example usage:
                                 *```javascript
                                 * // Specified AutoCursor ResultTable Background
                                 * { spiderChartOptions: { autoCursorBuilder: AutoCursorBuilders.Spider.setResultTableBackground(UIBackgrounds.Circle) } }
                                 * ```
                                 * @public
                                 */
                                export declare interface SpiderOptions<CursorResultTableBackgroundType extends UIBackground> extends DashboardCellOptions, SpiderChartOptions<CursorResultTableBackgroundType> {
                                }
                                /**
                                 * Interface for data-structure that is used to pass data-points to SpiderSeries.
                                 * @public
                                 */
                                export declare interface SpiderPoint {
                                    /**
                                     * Name of Axis in SpiderChart.
                                     */
                                    axis: string;
                                    /**
                                     * Numeric data value.
                                     */
                                    value: number;
                                }
                                /**
                                 * Type of data-structure that defines how an axis label is positioned on a Spider Chart.
                                 * @public
                                 */
                                export declare interface SpiderScaleLabelPosition {
                                    /**
                                     * Alignment X [-1, 1], where -1 is left and 1 is right extreme
                                     */
                                    alignmentX: number;
                                    /**
                                     * Alignment Y [-1, 1], where -1 is bottom and 1 is top extreme
                                     */
                                    alignmentY: number;
                                    /**
                                     * Padding in X direction as pixels
                                     */
                                    paddingX: number;
                                    /**
                                     * Padding in Y direction as pixels
                                     */
                                    paddingY: number;
                                }
                                /**
                                 * Type of a scale label strategy function.
                                 * Defines how scale labels are aligned.
                                 * @param result - DataStructure that is used to pass result
                                 * @param axisIndex - Index of axis. 0 is always directly up
                                 * @param axisCount - Amount of axes in chart
                                 * @param axisTag - Name of axis
                                 * @param axisAngle - Angle of axis in radians
                                 * @param webIndex - Index of web. 0 is always the outer-edge of spider
                                 * @param webCount - Amount of webs in chart
                                 * @param labelPadding - Label padding as set in chart
                                 * @returns SpiderScaleLabelPosition (modified first parameter of function) or undefined to not display label
                                 * @public
                                 */
                                export declare type SpiderScaleLabelStrategy = (result: SpiderScaleLabelPosition, axisIndex: number, axisCount: number, axisTag: string, axisAngle: number, webIndex: number, webCount: number, labelPadding: number) => SpiderScaleLabelPosition | undefined;
                                /**
                                 * Class that represents a collection of linked data-points inside a {@link SpiderChart}.
                                 *
                                 * Given data is visualized in the form of a *polygon*, where each {@link SpiderPoint} is an edge
                                 * along an *Axis*. This *polygon* can be styled with 3 independent areas:
                                 * - fill
                                 * - border
                                 * - points
                                 *
                                 * Data is pushed with {@link SpiderSeries.addPoints} in form: **\{ axis: string, value: number \}**
                                 * @public
                                 */
                                export declare class SpiderSeries extends Series2D implements Pointed {
                                    /**
                                     * @public
                                     */
                                    readonly scale: LinearScaleXY;
                                    /**
                                     * Adds an arbitrary amount of SpiderPoints to the Series.
                                     *
                                     * Animates transition if its enabled on owning chart.
                                     * @param points - List of SpiderPoints as \{'axis': string, 'value': number\}
                                     * @returns Object itself
                                     * @public
                                     */
                                    addPoints(...points: SpiderPoint[]): this;
                                    /**
                                     * Returns the respective value of a data-point with the given tag (if any)
                                     * @param animated - If set to true, will take series animating into account for result
                                     * @public
                                     */
                                    getValue(tag: string, animated?: boolean): number | undefined;
                                    /**
                                     * Set animation for adding points.
                                     * @param easing - Type of easing for animation or undefined to disable animations
                                     * @param duration - Custom duration for animation in milliseconds.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setAnimationAddPoints(easing?: AnimationEasing, duration?: number): this;
                                    /**
                                     * Set animation for when series visibility changes.
                                     *
                                     * This refers to default interaction when attached LegendBoxEntry is toggled, or alternatively when `setVisible()` method is used.
                                     *
                                     * ```ts
                                     *  // Example, disable animation when visibility changes
                                     *  SpiderSeries.setVisibleStateChangedAnimation(undefined)
                                     * ```
                                     *
                                     * ```ts
                                     *  // Example, specify animation easing and duration
                                     *  SpiderSeries.setVisibleStateChangedAnimation(AnimationEasings.linear, 2000)
                                     * ```
                                     *
                                     * @param easing - Type of easing for animation or undefined to disable animations
                                     * @param duration - Custom duration for animation in milliseconds.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setVisibleStateChangedAnimation(easing?: AnimationEasing, duration?: number): this;
                                    /**
                                     * Configure formatting of *Cursor ResultTable* when pointing at this *series*.
                                     *
                                     * ```typescript
                                     *  // Example usage
                                     *  SpiderSeries.setCursorResultTableFormatter((tableBuilder, series, value, axis) => {
                                     *      return tableBuilder
                                     *          .addRow(`Pointing at`, '', series.getName())
                                     *          .addRow(`Category:`, '', axis)
                                     *          .addRow(`Value:`, '', value.toFixed(1))
                                     *  })
                                     * ```
                                     *
                                     * The general syntax of configuring *ResultTable* formatting is shared between all *series* types;
                                     * You specify a callback function, which receives a {@link TableContentBuilder}. The contents of the table are then set using methods of the *table builder*:
                                     *
                                     * ```typescript
                                     *  // Using TableContentBuilder.
                                     *  SpiderSeries.setCursorResultTableFormatter((tableBuilder, series, value, axis) => {
                                     *      // addRow adds a list of strings to a new row in the table. Empty strings ('') will allocate any extra horizontal space within the row.
                                     *      tableBuilder
                                     *          .addRow('Item 0:', '', 'Value 0')
                                     *          .addRow('Item 1:', '', 'Value 1')
                                     *          .addRow('Long row that highlights the idea of empty strings')
                                     *
                                     *      // After configuration, the table builder must be returned!
                                     *      return tableBuilder
                                     *  })
                                     * ```
                                     *
                                     * The additional values that are supplied to the callback function vary between different chart types,
                                     * refer to the *series* documentation of `setCursorResultTableFormatter` to learn the exact available information.
                                     * All `Spider Series` receive three extra parameters:
                                     * 1. `series` | reference to the series itself.
                                     * 2. `value` | pointed data point value.
                                     * 3. `axis` | pointed data point category (name of spider axis).
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                     * - {@link SpiderChart.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     *
                                     * @param formatter - Function which builds *ResultTable* content.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setCursorResultTableFormatter(formatter: SpiderSeriesFormatter): this;
                                    /**
                                     * Get ResultTable Formatter.
                                     * @returns Function which builds ResultTable content for SpiderSeries.
                                     * @public
                                     */
                                    getCursorResultTableFormatter(): SpiderSeriesFormatter;
                                    /**
                                     * Configure whether *cursors* should pick on this particular *series* or not.
                                     *
                                     * ```typescript
                                     *  // Example, prevent chart auto cursor from snapping to a series.
                                     *  LineSeries.setCursorEnabled(false)
                                     * ```
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     * @public
                                     */
                                    setCursorEnabled(state: boolean): this;
                                    /**
                                     * Set fill style of the Polygon that represents the shape of the Series.
                                     *
                                     * Example use:
                                     *```javascript
                                     * // Create a new style
                                     * SpiderSeries.setFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                     * // Change transparency
                                     * SpiderSeries.setFillStyle((solidFill) => solidFill.setA(80))
                                     * // Set hidden
                                     * SpiderSeries.setFillStyle(emptyFill)
                                     * ```
                                     *
                                     * @param value - FillStyle which has to be used for recoloring or mutator to modify existing one.
                                     * @returns Series itself for fluent interface.
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * @returns Current series fill style
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stroke style of the Polygon that represents the shape of the Series.
                                     *
                                     * Supported line styles:
                                     * - {@link SolidLine}
                                     * - {@link emptyLine}
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Specified LineStyle
                                     * SpiderSeries.setStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                     * // Changed thickness
                                     * SpiderSeries.setStrokeStyle((solidLine) => solidLine.setThickness(5))
                                     * // Hidden
                                     * SpiderSeries.setStrokeStyle(emptyLine)
                                     * ```
                                     * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Gets the stroke style of the Polygon that represents the shape of this Series
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Set point fill style of Series.
                                     * Use {@link IndividualPointFill} object to enable individual coloring of points.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Create a new style
                                     * SpiderSeries.setPointFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                     * // Change transparency
                                     * SpiderSeries.setPointFillStyle((solidFill) => solidFill.setA(80))
                                     * // Set hidden
                                     * SpiderSeries.setPointFillStyle(emptyFill)
                                     * ```
                                     *
                                     * @param fillStyle - FillStyle which has to be used for recoloring or mutator to modify existing one.
                                     * @returns Series itself for fluent interface.
                                     * @public
                                     */
                                    setPointFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * @returns Current point fill style
                                     * @public
                                     */
                                    getPointFillStyle(): FillStyle;
                                    /**
                                     * Set size of point in pixels
                                     * @param size - Size of point in pixels
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setPointSize(size: number): this;
                                    /**
                                     * @returns Size of point in pixels
                                     * @public
                                     */
                                    getPointSize(): number;
                                    /**
                                     * Get shape of points.
                                     *
                                     * This is defined upon creation of series, and cannot be changed afterwards.
                                     * @returns PointShape
                                     * @public
                                     */
                                    getPointShape(): PointShape;
                                    /**
                                     * Set the rotation of points in degrees.
                                     * @param angle - Rotation angle in degrees
                                     * @public
                                     */
                                    setPointRotation(angle: number): this;
                                    /**
                                     * Get the current rotation of points.
                                     * @public
                                     */
                                    getPointRotation(): number;
                                    /**
                                     * Attach object to an legendBox entry
                                     * @param entry - Object which has to be attached
                                     * @param toggleVisibilityOnClick -    Flag that indicates whether the Attachable should be hidden or not,
                                     *                          when its respective Entry is clicked.
                                     * @param matchStyleExactly - By default, entries are assigned a smooth looking gradient based on the component color. If this flag is `true`, then this is skipped, and exact component solid fill is used instead.
                                     * @returns Series itself for fluent interface
                                     * @public
                                     */
                                    attach(entry: LegendBoxEntry, toggleVisibilityOnClick?: boolean, matchStyleExactly?: boolean): this;
                                    /**
                                     * Method for solving the nearest data point from a given coordinate on screen.
                                     *
                                     * ```ts
                                     *  // Example usage, from mouse move event.
                                     *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                                     *      const result = LineSeries.solveNearestFromScreen(event)
                                     *  })
                                     * ```
                                     *
                                     * ```ts
                                     *  // Example usage, arbitrary coordinate on client coordinate system.
                                     *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                                     * ```
                                     *
                                     * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                                     *
                                     * @param   location -  Location in HTML client coordinates.
                                     * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                                     * @public
                                     */
                                    solveNearestFromScreen(location: CoordinateClient): undefined | CursorPoint;
                                    /**
                                     * Solves the nearest datapoint to a given coordinate on screen.
                                     * @param location - Location on screen
                                     * @returns Undefined or data-structure for positioning of cursors
                                     * @public
                                     * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                                     */
                                    solveNearestFromScreen(location: Point): undefined | CursorPoint;
                                    /**
                                     * Set element visibility.
                                     *
                                     * @param state - `true` when element should be visible and `false` when element should be hidden.
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setVisible(state: boolean): this;
                                }
                                /**
                                 * Interface for a function which builds ResultTable content when pointing at a SpiderSeries.
                                 * @param tableContentBuilder - Builder that is used to build contents of ResultTable.
                                 *                                  Use addRow() method for adding content.
                                 * @param series - SpiderSeries
                                 * @param value - Value along axis
                                 * @param axis - Name of axis
                                 * @param formatValue - Formating function for values along axis
                                 * @returns TableContentBuilder that was supplied
                                 * @public
                                 */
                                export declare type SpiderSeriesFormatter = <T extends TableContentBuilder>(tableContentBuilder: T, series: SpiderSeries, value: number, axis: string, formatValue: (value: number) => string) => T;
                                /**
                                 * Interface describing options for Spider series that can be specified during creation time.
                                 *
                                 * Used with {@link SpiderChart.addSeries} method.
                                 *
                                 * @returns          Object itself.
                                 * @public
                                 */
                                declare interface SpiderSeriesOptions extends SeriesOptions {
                                    /**
                                     * Points shape of the spider series.
                                     *
                                     * ```ts
                                     *  // Example
                                     *  pointShape: PointShape.Circle
                                     * ```
                                     */
                                    pointShape?: PointShape;
                                }
                                /**
                                 * Enum for selecting shape of {@link SpiderChart} "webs" - background, GridStrokes and nibs.
                                 *
                                 * Use with {@link SpiderChart.setWebMode}
                                 * @public
                                 */
                                export declare enum SpiderWebMode {
                                    /**
                                     * Traditional Spider Chart with non-curved edges.
                                     */
                                    Normal = 0,
                                    /**
                                     * Background, GridStrokes and nibs will be drawn circular.
                                     */
                                    Circle = 1
                                }
                                /**
                                 * Class for visualization of polynom function.
                                 * @public
                                 */
                                export declare class SplineSeries extends PointLineSeries {
                                    /**
                                     * Set if cursor interpolates solved data-points along series by default.
                                     *
                                     * ```typescript
                                     *  // Example, disable default interpolation of spline series.
                                     *  const series = ChartXY.addSplineSeries()
                                     *      .setCursorInterpolationEnabled(false)
                                     * ```
                                     *
                                     * **Related API:**
                                     *
                                     * - {@link setCursorEnabled} | configure whether *cursors* should pick on this particular *series* or not.
                                     * - {@link setCursorResultTableFormatter} | configure formatting of *result table* contents, when this series is pointed.
                                     * - {@link setCursorSolveBasis} | configure basis of finding nearest data point for the series (`'nearest-x'`, `'nearest'`, etc.).
                                     * - {@link ChartXY.setAutoCursorMode} | configure behavior when auto cursor is visible.
                                     *
                                     * @param state - Boolean flag
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setCursorInterpolationEnabled(state: boolean): this;
                                    /**
                                     * Maximum allowed length for segments. Longer segments have risk of causing buffer size overflow (in GlShapes at least).
                                     * For efficiency segments should also not be much shorter because having lots of small segments is heavy.
                                     */
                                    protected readonly _maximumSegmentLength = 8000;
                                    /**
                                     * Method for solving the nearest data point from a given coordinate on screen.
                                     *
                                     * ```ts
                                     *  // Example usage, from mouse move event.
                                     *  ChartXY.onSeriesBackgroundMouseMove((_, event) => {
                                     *      const result = LineSeries.solveNearestFromScreen(event)
                                     *  })
                                     * ```
                                     *
                                     * ```ts
                                     *  // Example usage, arbitrary coordinate on client coordinate system.
                                     *  const result = LineSeries.solveNearestFromScreen({ clientX: 100, clientY: 200 })
                                     * ```
                                     *
                                     * Translating coordinates from other coordinate systems is also possible, see {@link Control.translateCoordinate}.
                                     *
                                     * @param   location -  Location in HTML client coordinates.
                                     * @returns     `undefined` or data structure with solve result information that can also be used for positioning custom cursors.
                                     * @public
                                     */
                                    solveNearestFromScreen(location: CoordinateClient, interpolate?: boolean): undefined | CursorPoint;
                                    /**
                                     * Solves the nearest datapoint of a given coordinate on screen
                                     * @param location - Location on screen
                                     * @param interpolate - Should interpolate? If omitted, defaults to setting of series
                                     * @returns Undefined or data-structure for positioning of cursors
                                     * @public
                                     * @deprecated  This method signature is deprecated since v4.2.0. Supply {@link CoordinateClient} instead.
                                     */
                                    solveNearestFromScreen(location: Point, interpolate?: boolean): undefined | CursorPoint;
                                }
                                /**
                                 * Interface for readonly configuration of {@link SplineSeries}.
                                 *
                                 * **Commonly used properties:**
                                 * - {@link SplineSeriesOptions.pointShape}: Specify shape of *point markers*.
                                 * - {@link SplineSeriesOptions.xAxis}: Attach series on non-default X Axis.
                                 * - {@link SplineSeriesOptions.yAxis}: Attach series on non-default Y Axis.
                                 *
                                 * **Example usage:**
                                 *
                                 * ```typescript
                                 *  // Example 1, create series with default configuration.
                                 *  const series = ChartXY.addSplineSeries({})
                                 * ```
                                 *
                                 * ```typescript
                                 *  // Example 2, select shape of point markers.
                                 *  const series = ChartXY.addSplineSeries({
                                 *      pointShape: PointShape.Circle
                                 *  })
                                 * ```
                                 * @public
                                 */
                                export declare interface SplineSeriesOptions extends PointLineSeriesOptions {
                                }
                                /**
                                 * Type to describe the icon position on sprite image.
                                 * @public
                                 */
                                export declare type SpriteImagePosition = {
                                    x: number;
                                    y: number;
                                };
                                /**
                                 * Data structure of a **state**.
                                 * @public
                                 */
                                export declare interface State {
                                    /**
                                     * Name of the state. Eq. 'Florida'. This is case insensitive.
                                     */
                                    name: string;
                                }
                                /**
                                 * StaticCursors are always positioned on the same scale.
                                 * @public
                                 */
                                export declare interface StaticCursor<ResultTableBackgroundType extends UIBackground> extends Cursor<ResultTableBackgroundType> {
                                    /**
                                     * Set the position of the Cursor,
                                     * moving it without modifying displayed data.
                                     * @public
                                     */
                                    setPosition: (position: Point) => this;
                                }
                                /**
                                 * Builder for static cursors without axes.
                                 * @public
                                 */
                                export declare class StaticCursor2DBuilder<ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorBuilder<ResultTableBackgroundType, StaticCursor<ResultTableBackgroundType>> {
                                    /**
                                     * Create new CursorBuilder with an additional styler.
                                     * @param cursorStyler - Cursor styler function
                                     * @returns CursorBuilder of same type
                                     * @public
                                     */
                                    addStyler: (cursorStyler: CursorStyler<StaticCursor<ResultTableBackgroundType>>) => StaticCursor2DBuilder<ResultTableBackgroundType>;
                                    /**
                                     * Create new CursorBuilder with a different ResultTable Background.
                                     * @param resultTableBackgroundConstructor - Constructor for Background
                                     * @returns CursorBuilder of same type
                                     * @public
                                     */
                                    setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => StaticCursor2DBuilder<T>;
                                }
                                /**
                                 * Static XY cursor interface
                                 * @public
                                 */
                                export declare interface StaticCursorXY<ResultTableBackgroundType extends UIBackground> extends StaticCursor<ResultTableBackgroundType>, CursorXY<ResultTableBackgroundType> {
                                    /**
                                     * Get x tick marker
                                     * @returns X customTick of cursor
                                     * @public
                                     */
                                    getTickMarkerX: () => TickMarker;
                                    /**
                                     * Get y tick marker
                                     * @returns Y customTick of cursor
                                     * @public
                                     */
                                    getTickMarkerY: () => TickMarker;
                                }
                                /**
                                 * Builder for static xy-cursors
                                 * @public
                                 */
                                export declare class StaticCursorXYBuilder<ResultTableBackgroundType extends UIBackground = UIBackground> extends CursorBuilderXY<ResultTableBackgroundType, StaticCursorXY<ResultTableBackgroundType>> {
                                    /**
                                     * Create new CursorBuilder with an additional styler.
                                     * @param cursorStyler - Cursor styler function
                                     * @returns New builder with extended style
                                     * @public
                                     */
                                    addStyler: (cursorStyler: CursorStyler<StaticCursorXY<ResultTableBackgroundType>>) => StaticCursorXYBuilder<ResultTableBackgroundType>;
                                    /**
                                     * Create new CursorBuilder with a different ResultTable Background.
                                     * @param resultTableBackgroundConstructor - Constructor for Background
                                     * @returns New builder with different resultTable background
                                     * @public
                                     */
                                    setResultTableBackground: <T extends InternalBackground & ResultTableBackgroundType>(resultTableBackgroundConstructor: BackgroundConstructor<T>) => StaticCursorXYBuilder<T>;
                                }
                                /**
                                 * Enum for selecting step behavior for {@link StepSeries}.
                                 *
                                 * This must be specified when the {@link StepSeries} is created, and can't be changed afterwards.
                                 * @public
                                 */
                                export declare enum StepOptions {
                                    /**
                                     * The y-value changes before the x-value.
                                     */
                                    before = 0,
                                    /**
                                     * The y-value changes at the midpoint of each pair of adjacent x-values.
                                     */
                                    middle = 0.5,
                                    /**
                                     * The y-value changes after the x-value.
                                     */
                                    after = 1
                                }
                                /**
                                 * Step Series that plots incoming data-points using Step preprocessing function.
                                 * @public
                                 */
                                export declare class StepSeries extends PointLineSeries {
                                }
                                /**
                                 * Interface for readonly configuration of {@link StepSeries}.
                                 *
                                 * **Commonly used properties:**
                                 * - {@link StepSeriesOptions.mode | mode}: Select stroke edge step behavior.
                                 * - {@link StepSeriesOptions.pointShape | pointShape}: Specify shape of *point markers*.
                                 * - {@link StepSeriesOptions.xAxis | xAxis}: Attach series on non-default X Axis.
                                 * - {@link StepSeriesOptions.yAxis | yAxis}: Attach series on non-default Y Axis.
                                 *
                                 * **Example usage:**
                                 *
                                 * ```typescript
                                 *  // Example 1, create series with default configuration.
                                 *  const series = ChartXY.addStepSeries({})
                                 * ```
                                 *
                                 * ```typescript
                                 *  // Example 2, select shape of point markers.
                                 *  const series = ChartXY.addStepSeries({
                                 *      pointShape: PointShape.Circle
                                 *  })
                                 * ```
                                 *
                                 * Note, currently `StepSeries` only supports `'ProgressiveX'` data.
                                 * @public
                                 */
                                export declare interface StepSeriesOptions extends PointLineSeriesOptions {
                                    /**
                                     * Step behavior for {@link StepSeries}.
                                     *
                                     * Select value from {@link StepOptions}.
                                     *
                                     * ```typescript
                                     *  // Example, step Y edge before X.
                                     *  const series = ChartXY.addPointLineSeries({
                                     *      mode: StepOptions.before,
                                     *  })
                                     * ```
                                     */
                                    mode?: StepOptions;
                                }
                                /**
                                 * Description of a _stipple pattern_. This is used with {@link DashedLine} to describe a repeating pattern of ON and OFF sections.
                                 *
                                 * For majority of use cases, utilizing preset options is heavily recommended: {@link StipplePatterns}.
                                 *
                                 * For example, a traditional _Dashed_ pattern could be described like ON - OFF - repeat.
                                 *
                                 * The stipple pattern is defined as an list of numbers. Each number should be an integer that describes a relative length of that ON or OFF section.
                                 * The first number of the pattern describes the first ON section, and after that it is alternated.
                                 *
                                 * ```ts
                                 *  // Example stipple pattern
                                 *  const stipplePattern = [
                                 *      // ON for 1 length
                                 *      1,
                                 *      // OFF for 2 length
                                 *      2,
                                 *      // ...
                                 *  ]
                                 * ```
                                 * @public
                                 */
                                export declare type StipplePattern = Array<number>;
                                /**
                                 * Collection of default {@link StipplePattern}s. These are used with {@link DashedLine} to style a line that repeats a pattern of ON and OFF sections.
                                 *
                                 * Use `StipplePatterns` when creating a new {@link DashedLine}.
                                 *
                                 * ```typescript
                                 *  // Example, set line series stroke style to 1px dashed red.
                                 *  LineSeries.setStrokeStyle(new DashedLine({
                                 *      thickness: 1,
                                 *      fillStyle: new SolidFill({ color: ColorRGBA( 255, 0, 0 ) }),
                                 *      patternScale: StipplePatterns.DashedEqual,
                                 *      patternScale: 1,
                                 *  }))
                                 * ```
                                 *
                                 * ```ts
                                 *  // Example, change stroke style to DashedLine without changing color / thickness
                                 *  LineSeries.setStrokeStyle((stroke) => new DashedLine({
                                 *      thickness: stroke.getThickness(),
                                 *      fillStyle: stroke.getFillStyle(),
                                 *      pattern: StipplePatterns.Dashed,
                                 *      patternScale: 2,
                                 *  }))
                                 * ```
                                 * @public
                                 */
                                export declare const StipplePatterns: {
                                    Dotted: number[];
                                    DottedDense: number[];
                                    Dashed: number[];
                                    DashedEqual: number[];
                                    DashedLoose: number[];
                                    DashDotted: number[];
                                };
                                /**
                                 * @public
                                 */
                                export declare interface StylableAxisLine {
                                    /**
                                     * Specifies axis stroke
                                     * @param value - Axis stroke style
                                     * @returns Axis itself for fluent interface
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * @returns Axis stroke as a LineStyle object
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                }
                                /**
                                 * @public
                                 */
                                export declare interface StylableAxisTitle {
                                    /**
                                     * @returns Axis title string
                                     * @public
                                     */
                                    getTitle(): string;
                                    /**
                                     * Specifies an Axis title string
                                     * @param title - Axis title as a string
                                     * @returns Axis itself for fluent interface
                                     * @public
                                     */
                                    setTitle(title: string): this;
                                    /**
                                     * @returns Axis title fillstyle
                                     * @public
                                     */
                                    getTitleFillStyle(): FillStyle;
                                    /**
                                     * Specifies Axis title FillStyle
                                     * @param fillStyle - FillStyle of Axis title or mutator to modify existing one
                                     * @returns Axis itself for fluent interface
                                     * @public
                                     */
                                    setTitleFillStyle(fillStyle: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get font of axis labels.
                                     * @returns FontSettings
                                     * @public
                                     */
                                    getTitleFont(): FontSettings;
                                    /**
                                     * Set font of Axis title.
                                     * @param value - FontSettings or mutator function for existing settings
                                     * @returns Object itself
                                     * @public
                                     */
                                    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Set theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @param enabled - Theme effect enabled
                                     * @returns          Object itself.
                                     * @public
                                     */
                                    setTitleEffect(enabled: boolean): this;
                                    /**
                                     * Get theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                     * @public
                                     */
                                    getTitleEffect(): boolean;
                                }
                                /**
                                 * Interface for an object that has stylable background.
                                 * @public
                                 */
                                export declare interface StylableBackground<BackgroundType extends UIBackground = UIBackground> extends Highlightable {
                                    /**
                                     * Method for mutating Background of object.
                                     *
                                     * Type of Background is generic, see {@link UIBackground} for minimum interface.
                                     * @param mutator - Mutator function for Background
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setBackground(mutator: Mutator<BackgroundType>): this;
                                    /**
                                     * Get elements Background object
                                     *
                                     * Type of Background is generic, see {@link UIBackground} for minimum interface.
                                     * @returns Background object
                                     * @public
                                     */
                                    getBackground(): BackgroundType;
                                    /**
                                     * Set padding around object in pixels.
                                     * Padding is empty space between the UiElements content and Background
                                     * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
                                     *                      for each side. Any side can be omitted, only passed values will be overridden.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setPadding(padding: Partial<Margin> | number): this;
                                    /**
                                     * Get padding around object in pixels.
                                     * Padding is empty space between the UiElements content and Background
                                     * @returns Margin datastructure
                                     * @public
                                     */
                                    getPadding(): Margin;
                                }
                                /**
                                 * Interface for object that has configurations for style of button.
                                 * @public
                                 */
                                export declare interface StylableButton {
                                    /**
                                     * Set fill style of Button when state is OFF
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setButtonOffFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Button when state is OFF
                                     * @returns Fill style object
                                     * @public
                                     */
                                    getButtonOffFillStyle(): FillStyle;
                                    /**
                                     * Set fill style of Button when state is ON
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setButtonOnFillStyle(value: FillStyle | Mutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Button when state is ON
                                     * @returns Fill style object
                                     * @public
                                     */
                                    getButtonOnFillStyle(): FillStyle;
                                    /**
                                     * Set size of Button
                                     * @param size - Point or pixel for squared button size
                                     * @returns Object itself
                                     * @public
                                     */
                                    setButtonSize(size: Point | pixel): this;
                                    /**
                                     * Get size of Button
                                     * @returns Size of button as Point
                                     * @public
                                     */
                                    getButtonSize(): Point;
                                }
                                /**
                                 * Interface that provides styling methods for some component.
                                 * @public
                                 */
                                export declare interface StylableComponent {
                                    /**
                                     * Set fill style
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * @returns Current fill style
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                }
                                /**
                                 * Interface that provides styling methods for some text component.
                                 * @public
                                 */
                                export declare interface StylableTextComponent extends StylableComponent {
                                    /**
                                     * Set font of text.
                                     * @param value - FontSettings or mutator function for existing settings
                                     * @returns Object itself
                                     * @public
                                     */
                                    setFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of text.
                                     * @returns FontSettings
                                     * @public
                                     */
                                    getFont(): FontSettings;
                                    /**
                                     * Set rotation of text.
                                     * @param value - Rotation in degrees
                                     * @returns Object itself
                                     * @public
                                     */
                                    setTextRotation(value: number): this;
                                    /**
                                     * Get rotation of text.
                                     * @returns Rotation in degrees
                                     * @public
                                     */
                                    getTextRotation(): number;
                                }
                                /**
                                 * Helper type for any `get<Thing>` getter functions
                                 * @public
                                 */
                                export declare type StyleGetter<T extends string> = `get${Capitalize<T>}`;
                                /**
                                 * Helper type to create getter function type definitions for all keys in given type.
                                 *
                                 * Used to create getter functions for all properties form a property interface definition.
                                 * @public
                                 */
                                export declare type StyleGetterPropFuncs<Type> = {
                                    [Key in keyof Type as StyleGetter<Key extends string ? Key : never>]: () => Type[Key];
                                };
                                /**
                                 * Enforce consistent style property function generation, naming and types.
                                 *
                                 * Creates type definitions for setters and getters based on a given property interface.
                                 * @public
                                 */
                                export declare type StylePropFuncs<Self, Type> = StyleSetterPropFuncs<Self, Type> & StyleGetterPropFuncs<Type>;
                                /**
                                 * Helper type for any `set<Thing>` setter functions
                                 * @public
                                 */
                                export declare type StyleSetter<T extends string> = `set${Capitalize<T>}`;
                                /**
                                 * Helper type to create setter function type definitions for all keys in given type.
                                 *
                                 * Used to create setter functions for all properties form a property interface definition.
                                 * @public
                                 */
                                export declare type StyleSetterPropFuncs<Self, Type> = {
                                    [Key in keyof Type as StyleSetter<Key extends string ? Key : never>]: (v: Type[Key] | ImmutableMutator<Type[Key]>) => Self;
                                };
                                /**
                                 * Styling API for "Text" component.
                                 * @public
                                 */
                                export declare interface StyleTextAPI {
                                    /**
                                     * Set text fill style object
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * @returns Current text fill style object
                                     * @public
                                     */
                                    getTextFillStyle(): FillStyle;
                                    /**
                                     * Set font of Label.
                                     * @param value - FontSettings or mutator function for existing settings
                                     * @returns Object itself
                                     * @public
                                     */
                                    setTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of Label.
                                     * @returns FontSettings
                                     * @public
                                     */
                                    getTextFont(): FontSettings;
                                    /**
                                     * Set rotation of Label.
                                     * @param value - Rotation in degrees
                                     * @returns Object itself
                                     * @public
                                     */
                                    setTextRotation(rotation: number): this;
                                    /**
                                     * Get rotation of Label.
                                     * @returns Rotation in degrees
                                     * @public
                                     */
                                    getTextRotation(): number;
                                }
                                /**
                                 * Interface to a single subrange between two LUT steps.
                                 * This internal data-structure is used to optimize lookup.
                                 * @public
                                 */
                                export declare interface SubRange {
                                    /**
                                     * The lowest border of the range.
                                     */
                                    min: LUTStep;
                                    /**
                                     * The highest border of the range.
                                     */
                                    max: LUTStep;
                                }
                                /**
                                 * Series for visualizing a 3D Surface Grid inside {@link Chart3D}.
                                 *
                                 * The grid is defined by imagining a plane along X and Z axis, split to \< COLUMNS \> (cells along X axis) and \< ROWS \> (cells along Z axis)
                                 *
                                 * The total amount of \< CELLS \> in a surface grid is calculated as `columns * rows`. Each \< CELL \> can be associated with DATA from an user data set.
                                 *
                                 * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
                                 *
                                 * - A static data set in tens of millions range is rendered in a matter of seconds.
                                 * - A data set in tens of millions range can be updated in less than a second.
                                 * - Maximum data set size is entirely limited by available memory (RAM). Even billion (1 000 000 000) data points have been visualized on a personal computer.
                                 *
                                 * **Creating Surface Grid Series:**
                                 *
                                 * `SurfaceGridSeries3D` are created with {@link Chart3D.addSurfaceGridSeries} method.
                                 *
                                 * Some properties of `SurfaceGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
                                 * They are all wrapped in a single object parameter:
                                 *
                                 * ```typescript
                                 *  // Example,
                                 *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                 *      columns: 100,
                                 *      rows: 200,
                                 *  })
                                 * ```
                                 *
                                 * To learn about these properties, refer to {@link SurfaceGridSeries3DOptions}.
                                 *
                                 * **Frequently used methods:**
                                 *
                                 * - Specify cell height data | {@link invalidateHeightMap}
                                 * - Specify cell intensity data {@link invalidateIntensityValues}
                                 * - Configure fill style | {@link setFillStyle}
                                 * - Configure wireframe style | {@link setWireframeStyle}
                                 * - Configure intensity interpolation | {@link setIntensityInterpolation}
                                 * - Configure cull mode | {@link setCullMode}
                                 * - Destroy series permanently | {@link dispose}
                                 *
                                 * `SurfaceGridSeries3D` is suitable for visualizing a surface with unchanging locations along X and Z axes.
                                 *
                                 * For visualizing continuous sampling in 3D surface, refer to {@link SurfaceScrollingGridSeries3D}.
                                 * @public
                                 */
                                export declare class SurfaceGridSeries3D extends Series3D implements AttachableWithLUT {
                                    /**
                                     * Set fill style of Surface Grid.
                                     *
                                     * **Supported fill styles:**
                                     *
                                     * {@link PalettedFill}:
                                     *
                                     * Look-up dynamic per-CELL color based on a _look up property_ and a color look up table ({@link LUT}).
                                     *
                                     * `SurfaceGridSeries3D` supports several different look-up modes:
                                     *
                                     * `lookUpProperty: 'value'`:
                                     *
                                     * Color each CELL based on its INTENSITY value. Cell intensity values can be specified with {@link invalidateIntensityValues}.
                                     *
                                     * ```ts
                                     *  // Example, enable dynamic coloring based on cell intensity data.
                                     *  surfaceGridSeries
                                     *      .setFillStyle(new PalettedFill({
                                     *          lookUpProperty: 'value',
                                     *          lut: new LUT({
                                     *              interpolate: true,
                                     *              steps: [
                                     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                                     *                  { value: 100, color: ColorRGBA(255, 0, 0) }
                                     *              ]
                                     *          })
                                     *      }))
                                     * ```
                                     *
                                     * Note, Surface grid series doesn't currently support {@link LUT.color} (fallback color).
                                     *
                                     * `lookUpProperty: 'x' | 'y' | 'z'`:
                                     *
                                     * Color each CELL based on one of its axis coordinates.
                                     *
                                     * ```ts
                                     *  // Example, enable dynamic coloring based on cell Y coordinate.
                                     *  surfaceGridSeries
                                     *      .setFillStyle(new PalettedFill({
                                     *          lookUpProperty: 'y',
                                     *          lut: new LUT({
                                     *              interpolate: true,
                                     *              steps: [
                                     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                                     *                  { value: 100, color: ColorRGBA(255, 0, 0) }
                                     *              ]
                                     *          })
                                     *      }))
                                     * ```
                                     *
                                     * Intensity based dynamic coloring can further be configured with {@link setIntensityInterpolation} to enable or disable automatic interpolation of Intensity values.
                                     * This is enabled by default.
                                     *
                                     * {@link SolidFill}:
                                     *
                                     * Solid color for entire Surface Grid fill.
                                     *
                                     * ```ts
                                     *  // Example, solid surface grid fill.
                                     *  heatmapSeries.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                     * ```
                                     *
                                     * If only wireframe rendering is desired, using `emptyFill` is recommended for better performance.
                                     *
                                     * {@link emptyFill}:
                                     *
                                     * Disables Surface Grid fill.
                                     *
                                     * ```js
                                     *  // Example, hide heatmap fill and show wireframe.
                                     *  heatmapSeries
                                     *      .setFillStyle(emptyFill)
                                     *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                     * ```
                                     *
                                     * **Related functionality:**
                                     *
                                     * - Color shading style can affect the general coloring of 3D shapes | {@link setColorShadingStyle}.
                                     *
                                     * @param value - FillStyle object or function which modifies current value.
                                     *                  Supported FillStyle types: {@link SolidFill}, {@link PalettedFill}, {@link emptyFill}
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of series.
                                     * @returns FillStyle.
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set wireframe style of Surface Grid.
                                     *
                                     * Wireframe consists of thin lines drawn around the borders of each surface CELL.
                                     * They are generally enabled to improve the perception of surface shape.
                                     *
                                     * Wireframe style is defined as {@link LineStyle}.
                                     *
                                     * ```ts
                                     *  // Example 1, enable wireframe.
                                     *  heatmapSeries.setWireframeStyle(new SolidLine({
                                     *      thickness: 1,
                                     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                                     *  }))
                                     * ```
                                     *
                                     * ```ts
                                     *  // Example 2, disable wireframe.
                                     *  heatmapSeries.setWireframeStyle(emptyLine)
                                     * ```
                                     *
                                     * At this time, only solid wireframe rendering is supported.
                                     * In future, this could be extended to coloring wireframe based on some dynamic properties (X, Y, Z, Intensity) similarly as surface fill.
                                     *
                                     * **Related functionality:**
                                     *
                                     * - Color shading style can affect the general coloring of 3D shapes | {@link setColorShadingStyle}.
                                     *
                                     * @param value - LineStyle object or function which modifies current value.
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get surface grid wireframe style.
                                     * @returns LineStyle object.
                                     * @public
                                     */
                                    getWireframeStyle(): LineStyle;
                                    /**
                                     * Set surface intensity interpolation mode.
                                     *
                                     * **This only affects surface grid with INTENSITY based dynamic coloring**, see {@link setFillStyle} for more information.
                                     *
                                     * This feature is enabled by default (`'bilinear'`).
                                     *
                                     * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
                                     *
                                     * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
                                     *
                                     * @param interpolationMode - Surface intensity interpolation mode selection.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
                                    /**
                                     * Get surface intensity interpolation mode.
                                     * @public
                                     */
                                    getIntensityInterpolation(): IntensityInterpolationMode;
                                    /**
                                     * Invalidate range of surface INTENSITY values starting from first column and row,
                                     * updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link SurfaceGridSeries3D.setFillStyle}).
                                     *
                                     * See the other overload of this method for invalidating a surface grid section which doesn't start from the first column and row.
                                     *
                                     * ```js
                                     *  // Example, 3x3 surface full invalidation.
                                     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                     *      dataOrder: 'columns',
                                     *      columns: 3,
                                     *      rows: 3
                                     *  })
                                     *
                                     *  surfaceGridSeries.invalidateIntensityValues([
                                     *      // Column 1 intensity values.
                                     *      [0, 0, 0],
                                     *      // Column 2 intensity values.
                                     *      [1, 1, 1],
                                     *      // Column 3 intensity values.
                                     *      [0, 2, 0],
                                     *  ])
                                     * ```
                                     *
                                     * Data interpretation basis is defined by {@link SurfaceGridSeries3DOptions.dataOrder} property from when the series was created.
                                     * Can be either list of *columns*, or list of *rows*.
                                     *
                                     * `invalidateIntensityValues` can trigger warnings when used controversially.
                                     * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                     *
                                     * @param value - Matrix (array of arrays) of intensity values.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    invalidateIntensityValues(value: number[][]): this;
                                    /**
                                     * Invalidate a partial range of surface INTENSITY values, updating coloring if a Color look up table ({@link LUT}) has been attached to the series (see {@link SurfaceGridSeries3D.setFillStyle}).
                                     *
                                     * ```js
                                     *  // Example, 100x10 surface invalidate partial section of surface.
                                     *
                                     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                     *      dataOrder: 'columns',
                                     *      columns: 100,
                                     *      rows: 10
                                     *  })
                                     *
                                     *  surfaceGridSeries.invalidateIntensityValues({
                                     *      // Index of first invalidated column.
                                     *      iColumn: 50,
                                     *      // Index of first invalidated row.
                                     *      iRow: 2,
                                     *      // Intensity values matrix. It's dimensions imply the amount of invalidated columns & rows.
                                     *      values: [
                                     *          // 1st invalidated column intensity values.
                                     *          [1, 1, 1, 1, 1],
                                     *          // 2nd invalidated column intensity values.
                                     *          [2, 2, 2, 2, 2],
                                     *          // 3rd invalidated column intensity values.
                                     *          [1, 0, 0, 0, 1],
                                     *          // 4th invalidated column intensity values.
                                     *          [0, 1, 0, 1, 0],
                                     *          // 5th invalidated column intensity values.
                                     *          [0, 0, 1, 0, 0],
                                     *      ],
                                     *  })
                                     * ```
                                     *
                                     * `invalidateIntensityValues` can trigger warnings when used controversially.
                                     * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                     *
                                     * @param value - Partial invalidation information, where `values` is an intensity value matrix, `iColumn` the first affected column and `iRow` the first affected row.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    invalidateIntensityValues(value: {
                                        iColumn: number;
                                        iRow: number;
                                        values: number[][];
                                    }): this;
                                    /**
                                     * Invalidate range of surface HEIGHT values starting from first column and row.
                                     * These values correspond to coordinates along the Y axis.
                                     *
                                     * See the other overload of this method for invalidating a surface grid section which doesn't start from the first column and row.
                                     *
                                     * ```js
                                     *  // Example, 3x3 surface full invalidation.
                                     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                     *      dataOrder: 'columns',
                                     *      columns: 3,
                                     *      rows: 3
                                     *  })
                                     *
                                     *  surfaceGridSeries.invalidateHeightMap([
                                     *      // Column 1 height (Y) values.
                                     *      [0, 0, 0],
                                     *      // Column 2 height (Y) values.
                                     *      [1, 1, 1],
                                     *      // Column 3 height (Y) values.
                                     *      [0, 2, 0],
                                     *  ])
                                     * ```
                                     *
                                     * Data interpretation basis is defined by {@link SurfaceGridSeries3DOptions.dataOrder} property from when the series was created.
                                     * Can be either list of *columns*, or list of *rows*.
                                     *
                                     * `invalidateHeightMap` can trigger warnings when used controversially.
                                     * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                     *
                                     * @param value - Matrix (array of arrays) of height values.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    invalidateHeightMap(value: number[][]): this;
                                    /**
                                     * Invalidate a partial range of surface HEIGHT values.
                                     * These values correspond to coordinates along the Y axis.
                                     *
                                     * ```js
                                     *  // Example, 100x10 surface invalidate partial section of surface.
                                     *
                                     *  const surfaceGridSeries = Chart3D.addSurfaceGridSeries({
                                     *      dataOrder: 'columns',
                                     *      columns: 100,
                                     *      rows: 10
                                     *  })
                                     *
                                     *  surfaceGridSeries.invalidateHeightMap({
                                     *      // Index of first invalidated column.
                                     *      iColumn: 50,
                                     *      // Index of first invalidated row.
                                     *      iRow: 2,
                                     *      // Height (Y) values matrix. It's dimensions imply the amount of invalidated columns & rows.
                                     *      values: [
                                     *          // 1st invalidated column height (Y) values.
                                     *          [1, 1, 1, 1, 1],
                                     *          // 2nd invalidated column height (Y) values.
                                     *          [2, 2, 2, 2, 2],
                                     *          // 3rd invalidated column height (Y) values.
                                     *          [1, 0, 0, 0, 1],
                                     *          // 4th invalidated column height (Y) values.
                                     *          [0, 1, 0, 1, 0],
                                     *          // 5th invalidated column height (Y) values.
                                     *          [0, 0, 1, 0, 0],
                                     *      ],
                                     *  })
                                     * ```
                                     *
                                     * `invalidateIntensityValues` can trigger warnings when used controversially.
                                     * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                     *
                                     * @param value - Partial invalidation information, where `values` is an height (Y) value matrix, `iColumn` the first affected column and `iRow` the first affected row.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    invalidateHeightMap(value: {
                                        iColumn: number;
                                        iRow: number;
                                        values: number[][];
                                    }): this;
                                    /**
                                     * Set culling of this Surface grid series.
                                     *
                                     * Culling means skipping drawing of specific geometry parts, based on its orientation.
                                     *
                                     * `'disabled'` -\> full geometry is drawn.
                                     *
                                     * `'cull-back'` -\> the behind of geometry is **not** drawn.
                                     *
                                     * `'cull-front'` -\> the front of geometry is **not** drawn.
                                     *
                                     * Surface series default cull mode is `'disabled'` to show both sides of the surface.
                                     *
                                     * @param mode - `CullMode3D` or `false` | `true` to disable/enable culling respectively.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setCullMode(mode: CullMode3D | boolean): this;
                                    /**
                                     * Get cull mode for this Surface grid series.
                                     *
                                     * Culling means skipping drawing of specific geometry parts, based on its orientation.
                                     *
                                     * `'disabled'` -\> full geometry is drawn.
                                     *
                                     * `'cull-back'` -\> the behind of geometry is **not** drawn.
                                     *
                                     * `'cull-front'` -\> the front of geometry is **not** drawn.
                                     *
                                     * Surface series default cull mode is `'disabled'` to show both sides of the surface.
                                     * @returns Active cull mode.
                                     * @public
                                     */
                                    getCullMode(): CullMode3D;
                                }
                                /**
                                 * Interface for readonly configuration of {@link SurfaceGridSeries3D}.
                                 *
                                 * **Required properties:**
                                 * - {@link SurfaceGridSeries3DOptions.columns}: Amount of cells along X axis.
                                 * - {@link SurfaceGridSeries3DOptions.rows}: Amount of cells along Z axis.
                                 *
                                 * **Optional properties:**
                                 *
                                 * All or any of these can be omitted or set to `undefined`, in which case a default value is used.
                                 *
                                 * - {@link SurfaceGridSeries3DOptions.dataOrder}: Specifies interpretation order for Height and Intensity data.
                                 * - {@link SurfaceGridSeries3DOptions.start}: Specifies location of first cell on X and Z axes.
                                 * - {@link SurfaceGridSeries3DOptions.step}: Specifies step between cells on X and Z axes.
                                 * - {@link SurfaceGridSeries3DOptions.end}: Specifies location of last cell on X and Z axes.
                                 *
                                 * **Example usage:**
                                 *
                                 * ```typescript
                                 *  // Example 1, create surface grid series with minimum configuration.
                                 *  const surfaceGrid = Chart3D.addSurfaceGridSeries({
                                 *      columns: 100,
                                 *      rows: 50,
                                 *  })
                                 * ```
                                 *
                                 * See also {@link Chart3D.addSurfaceScrollingGridSeries}.
                                 * @public
                                 */
                                export declare interface SurfaceGridSeries3DOptions extends SeriesOptions {
                                    /**
                                     * Amount of cells along X axis.
                                     *
                                     * **Required!**
                                     *
                                     * Surface grid data amount is specified as `columns * rows`.
                                     *
                                     * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
                                     * billion (1 000 000 000) data points have been properly visualized.
                                     */
                                    columns: number;
                                    /**
                                     * Amount of cells along Z axis.
                                     *
                                     * **Required!**
                                     *
                                     * Surface grid data amount is specified as `columns * rows`.
                                     *
                                     * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
                                     * billion (1 000 000 000) data points have been properly visualized.
                                     */
                                    rows: number;
                                    /**
                                     * Specifies interpretation order for Height and Intensity data when using {@link SurfaceGridSeries3D.invalidateHeightMap} or {@link SurfaceGridSeries3D.invalidateIntensityValues}.
                                     *
                                     * `'columns'` -\> Supply lists of "columns"
                                     *
                                     * ```typescript
                                     *  const intensityValues = [
                                     *      [
                                     *          0, // Intensity value column = 0, row = 0
                                     *          0, // Intensity value column = 0, row = 1
                                     *          0, // Intensity value column = 0, row = n
                                     *      ],
                                     *      [
                                     *          0, // Intensity value column = 1, row = 0
                                     *          0, // Intensity value column = 1, row = 1
                                     *          0, // Intensity value column = 1, row = n
                                     *      ],
                                     *  ]
                                     * ```
                                     *
                                     * `'rows'` -\> Supply lists of "rows"
                                     *
                                     * ```typescript
                                     *  const intensityValues = [
                                     *      [
                                     *          0, // Intensity value row = 0, column = 0
                                     *          0, // Intensity value row = 0, column = 1
                                     *          0, // Intensity value row = 0, column = n
                                     *      ],
                                     *      [
                                     *          0, // Intensity value row = 1, column = 0
                                     *          0, // Intensity value row = 1, column = 1
                                     *          0, // Intensity value row = 1, column = n
                                     *      ],
                                     *  ]
                                     * ```
                                     *
                                     * Optional, defaults to `'columns'`.
                                     */
                                    dataOrder?: 'columns' | 'rows';
                                    /**
                                     * Specifies location of first cell on X and Z axes.
                                     *
                                     * Optional, defaults to `{ x: 0, z: 0 }`
                                     */
                                    start?: PointXZ;
                                    /**
                                     * Specifies step between cells on X and Z axes.
                                     *
                                     * Optional, defaults to `{ x: 1, y: 1 }`, unless {@link SurfaceGridSeries3DOptions.end} is specified.
                                     */
                                    step?: PointXZ;
                                    /**
                                     * Specifies location of last cell on X and Z axes.
                                     *
                                     * Optional.
                                     *
                                     * `end` has priority over {@link SurfaceGridSeries3DOptions.step}.
                                     */
                                    end?: PointXZ;
                                }
                                /**
                                 * Series for visualizing a 3D Surface Grid inside {@link Chart3D}, with API for pushing data in a scrolling manner (append new data on top of existing data).
                                 *
                                 * The grid is defined by imagining a plane along X and Z axis, split to \< COLUMNS \> (cells along X axis) and \< ROWS \> (cells along Z axis)
                                 *
                                 * The total amount of \< CELLS \> in a surface grid is calculated as `columns * rows`. Each \< CELL \> can be associated with DATA from an user data set.
                                 *
                                 * This series is optimized for *massive* amounts of data - here are some reference specs to give an idea:
                                 *
                                 * - A data set of tens of millions data points is rendered in a matter of seconds.
                                 * - Maximum data set size is entirely limited by available memory (RAM).
                                 *   Even billion (1 000 000 000) data points have been visualized on a personal computer.
                                 *   Interacting with massive surface charts (more than tens of millions data points) requires a powerful GPU !
                                 * - Scrolling Surface Grid input stream rate is virtually unlimited - even 10 million incoming data points **per second** can easily be processed.
                                 *   Application limitations usually come from previously mentioned RAM and/or GPU bottlenecks.
                                 *
                                 * **Creating Surface Scrolling Grid Series:**
                                 *
                                 * `SurfaceScrollingGridSeries3D` are created with {@link Chart3D.addSurfaceScrollingGridSeries} method.
                                 *
                                 * Some properties of `SurfaceScrollingGridSeries3D` can only be configured when it is created. Some of these arguments are optional, while some are required.
                                 * They are all wrapped in a single object parameter:
                                 *
                                 * ```typescript
                                 *  // Example,
                                 *  const surfaceScrollingGridSeries = Chart3D.addSurfaceScrollingGridSeries({
                                 *      columns: 100,
                                 *      rows: 200,
                                 *  })
                                 * ```
                                 *
                                 * To learn about these properties, refer to {@link SurfaceScrollingGridSeries3DOptions}.
                                 *
                                 * **Frequently used methods:**
                                 *
                                 * - Append data | {@link addValues}
                                 * - Configure fill style | {@link setFillStyle}
                                 * - Configure wireframe style | {@link setWireframeStyle}
                                 * - Configure intensity interpolation | {@link setIntensityInterpolation}
                                 * - Configure cull mode | {@link setCullMode}
                                 * - Destroy series permanently | {@link dispose}
                                 *
                                 * `SurfaceScrollingGridSeries3D` is designed for visualizing real-time data sources, where either new columns or rows are pushed in periodically.
                                 *
                                 * For visualizing 3D surface grid with static columns and rows amount, refer to {@link SurfaceGridSeries3D}.
                                 * @public
                                 */
                                export declare class SurfaceScrollingGridSeries3D extends Series3D implements AttachableWithLUT {
                                    /**
                                     * Set fill style of Surface Grid.
                                     *
                                     * **Supported fill styles:**
                                     *
                                     * {@link PalettedFill}:
                                     *
                                     * Look-up dynamic per-CELL color based on a _look up property_ and a color look up table ({@link LUT}).
                                     *
                                     * `SurfaceScrollingGridSeries3D` supports several different look-up modes:
                                     *
                                     * `lookUpProperty: 'value'`:
                                     *
                                     * Color each CELL based on its INTENSITY value. Cell intensity values can be specified with {@link SurfaceScrollingGridSeries3D.addValues}.
                                     *
                                     * ```ts
                                     *  // Example, enable dynamic coloring based on cell intensity data.
                                     *  surfaceGridSeries
                                     *      .setFillStyle(new PalettedFill({
                                     *          lookUpProperty: 'value',
                                     *          lut: new LUT({
                                     *              interpolate: true,
                                     *              steps: [
                                     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                                     *                  { value: 100, color: ColorRGBA(255, 0, 0) }
                                     *              ]
                                     *          })
                                     *      }))
                                     * ```
                                     *
                                     * Note, Surface grid series doesn't currently support {@link LUT.color} (fallback color).
                                     *
                                     * `lookUpProperty: 'x' | 'y' | 'z'`:
                                     *
                                     * Color each CELL based on one of its axis coordinates.
                                     *
                                     * ```ts
                                     *  // Example, enable dynamic coloring based on cell Y coordinate.
                                     *  surfaceGridSeries
                                     *      .setFillStyle(new PalettedFill({
                                     *          lookUpProperty: 'y',
                                     *          lut: new LUT({
                                     *              interpolate: true,
                                     *              steps: [
                                     *                  { value: 0, color: ColorRGBA(0, 0, 0) },
                                     *                  { value: 100, color: ColorRGBA(255, 0, 0) }
                                     *              ]
                                     *          })
                                     *      }))
                                     * ```
                                     *
                                     * Intensity based dynamic coloring can further be configured with {@link setIntensityInterpolation} to enable or disable automatic interpolation of Intensity values.
                                     * This is enabled by default.
                                     *
                                     * {@link SolidFill}:
                                     *
                                     * Solid color for entire Surface Grid fill.
                                     *
                                     * ```ts
                                     *  // Example, solid surface grid fill.
                                     *  heatmapSeries.setFillStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                     * ```
                                     *
                                     * If only wireframe rendering is desired, using `emptyFill` is recommended for better performance.
                                     *
                                     * {@link emptyFill}:
                                     *
                                     * Disables Surface Grid fill.
                                     *
                                     * ```js
                                     *  // Example, hide heatmap fill and show wireframe.
                                     *  heatmapSeries
                                     *      .setFillStyle(emptyFill)
                                     *      .setWireframeStyle(new SolidFill({ color: ColorRGBA(255, 0, 0) }))
                                     * ```
                                     *
                                     * **Related functionality:**
                                     *
                                     * - Color shading style can affect the general coloring of 3D shapes | {@link setColorShadingStyle}.
                                     *
                                     * @param value - FillStyle object or function which modifies current value.
                                     *                  Supported FillStyle types: {@link SolidFill}, {@link PalettedFill}, {@link emptyFill}
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of series.
                                     * @returns FillStyle.
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set wireframe style of Surface Grid.
                                     *
                                     * Wireframe consists of thin lines drawn around the borders of each surface CELL.
                                     * They are generally enabled to improve the perception of surface shape.
                                     *
                                     * Wireframe style is defined as {@link LineStyle}.
                                     *
                                     * ```ts
                                     *  // Example 1, enable wireframe.
                                     *  heatmapSeries.setWireframeStyle(new SolidLine({
                                     *      thickness: 1,
                                     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                                     *  }))
                                     * ```
                                     *
                                     * ```ts
                                     *  // Example 2, disable wireframe.
                                     *  heatmapSeries.setWireframeStyle(emptyLine)
                                     * ```
                                     *
                                     * At this time, only solid wireframe rendering is supported.
                                     * In future, this could be extended to coloring wireframe based on some dynamic properties (X, Y, Z, Intensity) similarly as surface fill.
                                     *
                                     * **Related functionality:**
                                     *
                                     * - Color shading style can affect the general coloring of 3D shapes | {@link setColorShadingStyle}.
                                     *
                                     * @param value - LineStyle object or function which modifies current value.
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get surface grid wireframe style.
                                     * @returns LineStyle object.
                                     * @public
                                     */
                                    getWireframeStyle(): LineStyle;
                                    /**
                                     * Set surface intensity interpolation mode.
                                     *
                                     * **This only affects surface grid with INTENSITY based dynamic coloring**, see {@link setFillStyle} for more information.
                                     *
                                     * This feature is enabled by default (`'bilinear'`).
                                     *
                                     * `'disabled'` or `undefined`: Interpolation disabled; draw data exactly as it is.
                                     *
                                     * `'bilinear'`: Each PIXEL is colored based on an Bi-linearly interpolated intensity value based on the 4 closest real intensity values.
                                     *
                                     * @param interpolationMode - Surface intensity interpolation mode selection.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setIntensityInterpolation(interpolationMode: IntensityInterpolationMode | undefined): this;
                                    /**
                                     * Get surface intensity interpolation mode.
                                     * @public
                                     */
                                    getIntensityInterpolation(): IntensityInterpolationMode;
                                    /**
                                     * Clear all values added into the series.
                                     *
                                     * ```ts
                                     *  // Example syntax,
                                     *  surfaceScrollingGridSeries.clear()
                                     * ```
                                     *
                                     * This only affects Y and Intensity data. Other than any styles, etc. this will make the series behave as if it was just created.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    clear(): this;
                                    /**
                                     * Append values to the Surface Scrolling Grid Series.
                                     *
                                     * The series type can contain between 1 and 2 different data sets (Y values and Intensity values).
                                     * This same method is used for managing both types of data;
                                     *
                                     * When `addValues` is called, the parameter is wrapped in an object `{ }`, and one of (or both) `yValues` and `intensityValues` can be supplied.
                                     *
                                     * ```ts
                                     *  // Example syntax,
                                     *  surfaceScrollingGridSeries.addValues({
                                     *      yValues: ...
                                     *      intensityValues ...
                                     *  })
                                     * ```
                                     *
                                     * The type of `yValues` and `intensityValues` is a *number matrix*. At first level, it is a list of samples to add.
                                     *
                                     * ```ts
                                     *  yValues: [
                                     *      // Sample 1,
                                     *      // Sample 2
                                     *  ]
                                     * ```
                                     *
                                     * If both `yValues` and `intensityValues` are specified, then their length should be exactly same!
                                     *
                                     * Order of sample data is selected when the series is created;
                                     *
                                     * `scrollDimension: 'columns'` -\>
                                     *
                                     * ```typescript
                                     *  yValues: [
                                     *      [
                                     *          0, // column = 0, row = 0
                                     *          0, // column = 0, row = 1
                                     *          0, // column = 0, row = n
                                     *      ],
                                     *      [
                                     *          0, // column = 1, row = 0
                                     *          0, // column = 1, row = 1
                                     *          0, // column = 1, row = n
                                     *      ],
                                     *  ]
                                     * ```
                                     *
                                     * `scrollDimension: 'rows'` -\>
                                     *
                                     * ```typescript
                                     *  yValues: [
                                     *      [
                                     *          0, // row = 0, column = 0
                                     *          0, // row = 0, column = 1
                                     *          0, // row = 0, column = n
                                     *      ],
                                     *      [
                                     *          0, // row = 1, column = 0
                                     *          0, // row = 1, column = 1
                                     *          0, // row = 1, column = n
                                     *      ],
                                     *  ]
                                     * ```
                                     *
                                     * Example usage:
                                     *
                                     * ```typescript
                                     *  // Create X-scrolling surface series.
                                     *  const scrollingSurfaceSeries = Chart3D.addSurfaceScrollingGridSeries({
                                     *      scrollDimension: 'columns',
                                     *      rows: 5,
                                     *      columns: 50,
                                     *  })
                                     *
                                     *  // Push two Y columns into the series.
                                     *  scrollingSurfaceSeries.addValues({
                                     *      yValues: [
                                     *          [0, 0, 0, 0, 0],
                                     *          [0, 10, 0, 20, 0]
                                     *      ]
                                     *  })
                                     * ```
                                     *
                                     * `addValues` can trigger warnings when used controversially (for example, data overflow).
                                     * In production applications, these can be controlled with {@link LightningChartOptions.warnings}.
                                     *
                                     * @param arg - Object with `yValues` and/or `intensityValues` matrixes to append on top of previously added data.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    addValues(arg: {
                                        yValues?: number[][];
                                        intensityValues?: number[][];
                                    }): this;
                                    /**
                                     * Set culling of this Surface grid series.
                                     *
                                     * Culling means skipping drawing of specific geometry parts, based on its orientation.
                                     *
                                     * `'disabled'` -\> full geometry is drawn.
                                     *
                                     * `'cull-back'` -\> the behind of geometry is **not** drawn.
                                     *
                                     * `'cull-front'` -\> the front of geometry is **not** drawn.
                                     *
                                     * Surface series default cull mode is `'disabled'` to show both sides of the surface.
                                     *
                                     * @param mode - `CullMode3D` or `false` | `true` to disable/enable culling respectively.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setCullMode(mode: CullMode3D | boolean): this;
                                    /**
                                     * Get cull mode for this Surface grid series.
                                     *
                                     * Culling means skipping drawing of specific geometry parts, based on its orientation.
                                     *
                                     * `'disabled'` -\> full geometry is drawn.
                                     *
                                     * `'cull-back'` -\> the behind of geometry is **not** drawn.
                                     *
                                     * `'cull-front'` -\> the front of geometry is **not** drawn.
                                     *
                                     * Surface series default cull mode is `'disabled'` to show both sides of the surface.
                                     * @returns Active cull mode.
                                     * @public
                                     */
                                    getCullMode(): CullMode3D;
                                }
                                /**
                                 * Interface for readonly configuration of {@link SurfaceScrollingGridSeries3D}.
                                 *
                                 * **Required properties:**
                                 * - {@link SurfaceScrollingGridSeries3DOptions.columns}: Amount of cells along X axis.
                                 * - {@link SurfaceScrollingGridSeries3DOptions.rows}: Amount of cells along Z axis.
                                 *
                                 * **Optional properties:**
                                 *
                                 * All or any of these can be omitted or set to `undefined`, in which case a default value is used.
                                 *
                                 * - {@link SurfaceScrollingGridSeries3DOptions.scrollDimension}: Specifies which dimension (columns or rows) is scrolling.
                                 * - {@link SurfaceScrollingGridSeries3DOptions.start}: Specifies location of first cell on X and Z axes.
                                 * - {@link SurfaceScrollingGridSeries3DOptions.step}: Specifies step between cells on X and Z axes.
                                 *
                                 * **Example usage:**
                                 *
                                 * ```typescript
                                 *  // Example 1, create surface grid series with minimum configuration.
                                 *  const surfaceGrid = Chart3D.addSurfaceScrollingGridSeries({
                                 *      columns: 100,
                                 *      rows: 50,
                                 *  })
                                 * ```
                                 *
                                 * See also {@link Chart3D.addSurfaceGridSeries}.
                                 * @public
                                 */
                                export declare interface SurfaceScrollingGridSeries3DOptions extends SeriesOptions {
                                    /**
                                     * Amount of cells along X axis.
                                     *
                                     * **Required!**
                                     *
                                     * If {@link SurfaceScrollingGridSeries3DOptions.scrollDimension} is `'columns'`, then this will specify the amount of cells to keep before the oldest sample is shifted out.
                                     *
                                     * Surface grid data amount is specified as `columns * rows`.
                                     *
                                     * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
                                     * billion (1 000 000 000) data points have been properly visualized.
                                     */
                                    columns: number;
                                    /**
                                     * Amount of cells along Z axis.
                                     *
                                     * **Required!**
                                     *
                                     * If {@link SurfaceScrollingGridSeries3DOptions.scrollDimension} is `'rows'`, then this will specify the amount of cells to keep before the oldest sample is shifted out.
                                     *
                                     * Surface grid data amount is specified as `columns * rows`.
                                     *
                                     * Larger data sets require more memory (RAM) to work. With nearly any setup, tens of millions data points can easily be reached and with good setups even
                                     * billion (1 000 000 000) data points have been properly visualized.
                                     */
                                    rows: number;
                                    /**
                                     * Select scrolling dimension, as well as how to interpret grid matrix values supplied by user.
                                     *
                                     * If `columns` is selected, then there will be no limit on how many *columns* can be pushed to the series, but *rows* amount will be static.
                                     *
                                     * If `rows` is selected, then there will be no limit on how many *rows* can be pushed to the series, but *columns* amount will be static.
                                     *
                                     * Data order:
                                     *
                                     * `'columns'` -\> Supply lists of "columns"
                                     *
                                     * ```typescript
                                     *  const intensityValues = [
                                     *      [
                                     *          0, // Intensity value column = 0, row = 0
                                     *          0, // Intensity value column = 0, row = 1
                                     *          0, // Intensity value column = 0, row = n
                                     *      ],
                                     *      [
                                     *          0, // Intensity value column = 1, row = 0
                                     *          0, // Intensity value column = 1, row = 1
                                     *          0, // Intensity value column = 1, row = n
                                     *      ],
                                     *  ]
                                     * ```
                                     *
                                     * `'rows'` -\> Supply lists of "rows"
                                     *
                                     * ```typescript
                                     *  const intensityValues = [
                                     *      [
                                     *          0, // Intensity value row = 0, column = 0
                                     *          0, // Intensity value row = 0, column = 1
                                     *          0, // Intensity value row = 0, column = n
                                     *      ],
                                     *      [
                                     *          0, // Intensity value row = 1, column = 0
                                     *          0, // Intensity value row = 1, column = 1
                                     *          0, // Intensity value row = 1, column = n
                                     *      ],
                                     *  ]
                                     * ```
                                     *
                                     * Optional, defaults to `'columns'`.
                                     */
                                    scrollDimension?: 'columns' | 'rows';
                                    /**
                                     * Specifies location of first cell on X and Z axes.
                                     *
                                     * Optional, defaults to `{ x: 0, z: 0 }`
                                     */
                                    start?: PointXZ;
                                    /**
                                     * Specifies step between cells on X and Z axes.
                                     *
                                     * Optional, defaults to `{ x: 1, y: 1 }`.
                                     */
                                    step?: PointXZ;
                                }
                                /**
                                 * Interface for object that can be switched on/off and that can have respective event-subscriptions
                                 * @public
                                 */
                                export declare interface Switchable {
                                    /**
                                     * Set state of switchable object.
                                     *
                                     * **NOTE: If *Switchable*.getLocked() == true, this method will not do anything.!**
                                     * @param isOn - State as boolean flag
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setOn(isOn: boolean): this;
                                    /**
                                     * @returns State as boolean flag
                                     * @public
                                     */
                                    getOn(): boolean;
                                    /**
                                     * Set whether *Switchable* is locked or not. When locked, *Switchable*.setOn() is disabled.
                                     * @param isLocked - state
                                     * @returns State as boolean flag
                                     * @public
                                     */
                                    setLocked(isLocked: boolean): this;
                                    /**
                                     * @returns State of isLocked boolean flag
                                     * @public
                                     */
                                    getLocked(): boolean;
                                    /**
                                     * Subscribe to Switch event
                                     * @returns Token of subscription
                                     * @public
                                     */
                                    onSwitch(listener: (obj: this, state: boolean) => void): Token;
                                    /**
                                     * Remove event listener from Switch event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offSwitch(token: Token): boolean;
                                }
                                /**
                                 * Convenience function for synchronizing the intervals of `n` amount of Axis.
                                 *
                                 * ```ts
                                 *  // Example, usage syntax.
                                 *  synchronizeAxisIntervals(
                                 *      chart1.getDefaultAxisX(),
                                 *      // Any number of Axis can be passed one after another.
                                 *      chart2.getDefaultAxisX()
                                 *  )
                                 * ```
                                 *
                                 * `synchronizeAxisIntervals` uses {@link Axis.onIntervalChange}, {@link Axis.onStoppedStateChanged} and {@link Axis.setInterval} methods internally for its logic.
                                 *
                                 * The return value can be used for removing the synchronization logic at any time.
                                 *
                                 * @param axes - List of Axis to synchronize. These can be Axis from {@link ChartXY}, {@link Chart3D} or {@link PolarChart}.
                                 * @returns Handle for removing created side effects.
                                 * @public
                                 */
                                export declare const synchronizeAxisIntervals: (...axes: (Axis | Axis3D | PolarAxisAmplitude)[]) => SynchronizeAxisIntervalsHandle;
                                /**
                                 * Handle returned by {@link synchronizeAxisIntervals} for removing created side effects.
                                 *
                                 * ```ts
                                 *  // Example usage.
                                 *  // Synchronize Axis intervals.
                                 *  const handle = synchronizeAxisIntervals(axis1, axis2)
                                 *
                                 *  // When you want to remove the synchronization logic, call handle.remove.
                                 *  handle.remove()
                                 * ```
                                 * @public
                                 */
                                export declare type SynchronizeAxisIntervalsHandle = {
                                    /**
                                     * Remove side effects created by {@link synchronizeAxisIntervals},
                                     * removing the synchronization logic.
                                     *
                                     * ```ts
                                     *  // Example syntax,
                                     *  SynchronizeAxisIntervalsHandle.remove()
                                     * ```
                                     * @public
                                     */
                                    remove: () => void;
                                };
                                /**
                                 * Class for user customizable building of 'TableContent'.
                                 * Basically the way users modify what cursors show (on level of a single series), is to
                                 * set a function that builds TableContent based on information given by the series.
                                 * Internal class
                                 * @public
                                 */
                                export declare abstract class TableContentBuilder {
                                    /**
                                     * Add a row to built content.
                                     *
                                     * ```ts
                                     *  // Basic example
                                     *  builder.addRow('Hello')
                                     * ```
                                     *
                                     * ```ts
                                     *  // Centered text
                                     *  builder.addRow('', 'Centered', '')
                                     *  builder.addRow('Long text long text')
                                     * ```
                                     *
                                     * ```ts
                                     *  // Individual label font / fill
                                     *  builder.addRow('Row 1')
                                     *  builder.addRow({ text: 'Row 2', font: { weight: 'bold' }, fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) }) })
                                     * ```
                                     *
                                     * For performance reasons it is recommended to avoid using `font` and/or `fillStyle` overrides to configure all text.
                                     * In that case it is better to use `ResultTable.setTextFont` or equivalent method to configure all text at once.
                                     *
                                     * @param cells - Any amount of cells row should contain. Undefined or '' marks a "gap", which will occupy any extra space of row.
                                     * @returns Object itself
                                     * @public
                                     */
                                    addRow(...cells: (string | {
                                        text: string;
                                        font?: Partial<FontProperties>;
                                        fillStyle?: FillStyle;
                                    } | undefined)[]): this;
                                }
                                /**
                                 * Interface for all properties of a *library color theme*.
                                 *
                                 * A collection of default implementations can be accessed by {@link Themes}.
                                 *
                                 * Color theme of components must be specified when it is created, and can't be changed afterwards (without destroying and recreating the component).
                                 *
                                 * ```ts
                                 *  // Example syntax, select Theme of component
                                 *  const chart = lightningChart().ChartXY({
                                 *      theme: Themes.light
                                 *  })
                                 * ```
                                 *
                                 * All charts within a Dashboard must always have the same theme. Thus, it is configured only when the Dashboard is created.
                                 *
                                 * ```ts
                                 *  // Example syntax, Dashboard theme
                                 *  const chart = lightningChart().Dashboard({
                                 *      theme: Themes.light,
                                 *      numberOfColumns: 1,
                                 *      numberOfRows: 3,
                                 *  })
                                 * ```
                                 *
                                 * For custom color themes, refer to Developer Documentation \> Themes section.
                                 * @public
                                 */
                                export declare interface Theme {
                                    /**
                                     * Properties of {@link Theme} that are optional, and officially only used in LightningChart JS Online Examples and projects.
                                     *
                                     * These are guaranteed to be included in all official Library Themes provided by LightningChart, but not required in custom Themes defined by users.
                                     *
                                     * If you want to use example theme properties in your application, then make sure to do these two things:
                                     *
                                     * 1) Use an official Theme supplied by LightningChart.
                                     * 2) If your project requires type safety, then add a sanity check that throws an error if the `Theme.examples` property is `undefined`, like this:
                                     *
                                     * ```ts
                                     *  // Example, ensure official LightningChart JS theme is in use.
                                     *  const theme = chart.getTheme()
                                     *  if (!theme.examples) {
                                     *      throw new Error(`LightningChart JS Theme.examples is undefined. You are probably using an unofficial theme and attempting to access example theme properties!`)
                                     *  }
                                     * ```
                                     */
                                    readonly examples?: ThemeExampleProperties;
                                    /**
                                     * Flag if Theme is dark or not.
                                     *
                                     * For user defined themes, it doesn't have large consequences. However, incorrect use can have a slight negative effect on text sharpness.
                                     * For a Theme with dominantly dark backgrounds, should set the value to `false`.
                                     */
                                    isDark: boolean;
                                    /**
                                     * Selection of Theme effect.
                                     * Either none (`undefined`) or a `GlowEffect`.
                                     *
                                     * For performance reasons only 1 configuration of a glow effect is allowed within an application at the moment.
                                     * This property has been marked as @beta to stay reactive to changes in user needs.
                                     * If users will need a better way to configure the drawing effects, then it can be refactored without a major release.
                                     *
                                     * @beta
                                     */
                                    effect: Effect | undefined;
                                    /**
                                     * Convenience flag for controlling whether theme effect should be shown in different Text components by default.
                                     *
                                     * `false` -\> Text components will have disabled theme effect by default.
                                     */
                                    effectsText: boolean;
                                    /**
                                     * Convenience flag for controlling whether theme effect should be shown in dashboard splitters by default.
                                     *
                                     * `false` -\> Dashboard splitters will have disabled theme effect by default.
                                     */
                                    effectsDashboardSplitters: boolean;
                                    lcjsBackgroundFillStyle: FillStyle | ((resourcesBaseUrl: string) => FillStyle);
                                    lcjsBackgroundStrokeStyle: LineStyle;
                                    /**
                                     * Color offset for chart components when highlighted.
                                     *
                                     * ```ts
                                     *  // Example, highlighted components shift towards red.
                                     *  highlightColorOffset: ColorRGBA(100, -50, -50, 0)
                                     * ```
                                     *
                                     * ```ts
                                     *  // Example, highlighted components are darkened.
                                     *  highlightColorOffset: ColorRGBA(-100, -100, -100, 0)
                                     * ```
                                     *
                                     * This property is marked as @beta meaning that it can be changed in minor version releases for the time being.
                                     *
                                     * @beta
                                     */
                                    highlightColorOffset: Color;
                                    /**
                                     * Override of {@link highlightColorOffset} for axis overlays (mouse interaction areas).
                                     *
                                     * This property is marked as @beta meaning that it can be changed in minor version releases for the time being.
                                     *
                                     * @beta
                                     */
                                    highlightColorOffsetAxisOverlay?: Color;
                                    dashboardSplitterStyle: LineStyle;
                                    chartXYBackgroundFillStyle: FillStyle;
                                    chartXYBackgroundStrokeStyle: LineStyle;
                                    chartXYTitleFont: FontSettings;
                                    chartXYTitleFillStyle: FillStyle;
                                    chartXYSeriesBackgroundFillStyle: FillStyle;
                                    chartXYSeriesBackgroundStrokeStyle: LineStyle;
                                    chartXYZoomingRectangleFillStyle: FillStyle;
                                    chartXYZoomingRectangleStrokeStyle: LineStyle;
                                    chartXYFittingRectangleFillStyle: FillStyle;
                                    chartXYFittingRectangleStrokeStyle: LineStyle;
                                    lineSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    pointLineSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    pointLineSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    pointSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    ellipseSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    ellipseSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    polygonSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    polygonSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    rectangleSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    rectangleSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    segmentSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    boxSeriesBodyFillStyle: FillStyle;
                                    boxSeriesBodyStrokeStyle: LineStyle;
                                    boxSeriesStrokeStyle: LineStyle;
                                    boxSeriesMedianStrokeStyle: LineStyle;
                                    ohlcCandleThicknessPixels: number;
                                    ohlcCandleBodyFillStylePositive: FillStyle;
                                    ohlcCandleBodyFillStyleNegative: FillStyle;
                                    ohlcCandleTailStrokeStylePositive: LineStyle;
                                    ohlcCandleTailStrokeStyleNegative: LineStyle;
                                    ohlcBarThicknessPixels: number;
                                    ohlcBarStrokeStylePositive: LineStyle;
                                    ohlcBarStrokeStyleNegative: LineStyle;
                                    heatmapGridSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    heatmapGridSeriesWireframeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    heatmapScrollingGridSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    heatmapScrollingGridSeriesWireframeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    areaRangeSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    areaRangeSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    areaRangeSeriesFillStyleInverted: ThemePropertyWithCallbackOption<FillStyle>;
                                    areaRangeSeriesStrokeStyleInverted: ThemePropertyWithCallbackOption<LineStyle>;
                                    areaSeriesBipolarHighFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    areaSeriesBipolarHighStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    areaSeriesBipolarLowFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    areaSeriesBipolarLowStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    areaSeriesPositiveFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    areaSeriesPositiveStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    areaSeriesNegativeFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    areaSeriesNegativeStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    xAxisTitleFont: FontSettings;
                                    xAxisTitleFillStyle: FillStyle;
                                    xAxisStrokeStyle: LineStyle;
                                    xAxisNibStyle: LineStyle;
                                    xAxisOverlayStyle: FillStyle;
                                    xAxisZoomingBandFillStyle: FillStyle;
                                    xAxisZoomingBandStrokeStyle: LineStyle;
                                    xAxisNumericTicks: NumericTickStrategy;
                                    xAxisDateTimeTicks: DateTimeTickStrategy;
                                    xAxisTimeTicks: TimeTickStrategy;
                                    yAxisTitleFont: FontSettings;
                                    yAxisTitleFillStyle: FillStyle;
                                    yAxisStrokeStyle: LineStyle;
                                    yAxisNibStyle: LineStyle;
                                    yAxisOverlayStyle: FillStyle;
                                    yAxisZoomingBandFillStyle: FillStyle;
                                    yAxisZoomingBandStrokeStyle: LineStyle;
                                    yAxisNumericTicks: NumericTickStrategy;
                                    yAxisDateTimeTicks: DateTimeTickStrategy;
                                    yAxisTimeTicks: TimeTickStrategy;
                                    bandFillStyle: FillStyle;
                                    bandStrokeStyle: LineStyle;
                                    constantLineStrokeStyle: LineStyle;
                                    barChartBackgroundFillStyle: FillStyle;
                                    barChartBackgroundStrokeStyle: LineStyle;
                                    barChartTitleFont: FontSettings;
                                    barChartTitleFillStyle: FillStyle;
                                    barChartSeriesBackgroundFillStyle: FillStyle;
                                    barChartSeriesBackgroundStrokeStyle: LineStyle;
                                    barChartBarFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    barChartBarStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    barChartValueAxisTitleFont: FontSettings;
                                    barChartValueAxisTitleFillStyle: FillStyle;
                                    barChartValueAxisStrokeStyle: LineStyle;
                                    barChartValueAxisTicks: NumericTickStrategy;
                                    barChartCategoryAxisTitleFont: FontSettings;
                                    barChartCategoryAxisTitleFillStyle: FillStyle;
                                    barChartCategoryAxisStrokeStyle: LineStyle;
                                    barChartCategoryLabels: BarChartCategoryLabels;
                                    barChartValueLabelsAfterBars: BarChartValueLabelsAfterBars;
                                    barChartValueLabelsInsideBars: BarChartValueLabelsInsideBars;
                                    chart3DBackgroundFillStyle: FillStyle;
                                    chart3DBackgroundStrokeStyle: LineStyle;
                                    chart3DTitleFont: FontSettings;
                                    chart3DTitleFillStyle: FillStyle;
                                    chart3DSeriesBackgroundFillStyle: FillStyle;
                                    chart3DSeriesBackgroundStrokeStyle: LineStyle;
                                    chart3DBoundingBoxStrokeStyle: LineStyle;
                                    xAxis3DTitleFont: FontSettings;
                                    xAxis3DTitleFillStyle: FillStyle;
                                    xAxis3DStrokeStyle: LineStyle;
                                    xAxis3DNumericTicks: NumericTickStrategy;
                                    xAxis3DDateTimeTicks: DateTimeTickStrategy;
                                    xAxis3DTimeTicks: TimeTickStrategy;
                                    yAxis3DTitleFont: FontSettings;
                                    yAxis3DTitleFillStyle: FillStyle;
                                    yAxis3DStrokeStyle: LineStyle;
                                    yAxis3DNumericTicks: NumericTickStrategy;
                                    yAxis3DDateTimeTicks: DateTimeTickStrategy;
                                    yAxis3DTimeTicks: TimeTickStrategy;
                                    zAxis3DTitleFont: FontSettings;
                                    zAxis3DTitleFillStyle: FillStyle;
                                    zAxis3DStrokeStyle: LineStyle;
                                    zAxis3DNumericTicks: NumericTickStrategy;
                                    zAxis3DDateTimeTicks: DateTimeTickStrategy;
                                    zAxis3DTimeTicks: TimeTickStrategy;
                                    lineSeries3DStrokeStyle: ThemePropertyWithCallbackOption<SolidLine>;
                                    pointLineSeries3DStrokeStyle: ThemePropertyWithCallbackOption<SolidLine>;
                                    pointLineSeries3DPointStyle: ThemePropertyWithCallbackOption<TriangulatedPoints3D>;
                                    pointSeries3DPointStyle: ThemePropertyWithCallbackOption<TriangulatedPoints3D>;
                                    pointCloudSeries3DPointStyle: ThemePropertyWithCallbackOption<PixelatedPoints3D>;
                                    surfaceGridSeries3DFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    surfaceGridSeries3DWireframeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    surfaceScrollingGridSeries3DFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    surfaceScrollingGridSeries3DWireframeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    boxSeries3DFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    polarChartBackgroundFillStyle: FillStyle;
                                    polarChartBackgroundStrokeStyle: LineStyle;
                                    polarChartTitleFont: FontSettings;
                                    polarChartTitleFillStyle: FillStyle;
                                    polarChartSeriesBackgroundFillStyle: FillStyle;
                                    polarChartSeriesBackgroundStrokeStyle: LineStyle;
                                    polarSectorFillStyle: FillStyle;
                                    polarSectorStrokeStyle: LineStyle;
                                    polarAmplitudeAxisTitleFont: FontSettings;
                                    polarAmplitudeAxisTitleFillStyle: FillStyle;
                                    polarAmplitudeAxisStrokeStyle: LineStyle;
                                    polarAmplitudeAxisNumericTicks: NumericTickStrategy;
                                    polarAmplitudeAxisDateTimeTicks: DateTimeTickStrategy;
                                    polarAmplitudeAxisTimeTicks: TimeTickStrategy;
                                    polarRadialAxisTitleFont: FontSettings;
                                    polarRadialAxisTitleFillStyle: FillStyle;
                                    polarRadialAxisStrokeStyle: LineStyle;
                                    polarRadialAxisTickStyle: TickStyle;
                                    polarLineSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    polarPointLineSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    polarPointLineSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    polarPointSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    polarPolygonSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    polarPolygonSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    polarAreaSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    polarAreaSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    polarHeatmapSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    mapChartBackgroundFillStyle: FillStyle;
                                    mapChartBackgroundStrokeStyle: LineStyle;
                                    mapChartTitleFont: FontSettings;
                                    mapChartTitleFillStyle: FillStyle;
                                    mapChartFillStyle: FillStyle;
                                    mapChartStrokeStyle: LineStyle;
                                    mapChartOutlierRegionFillStyle: FillStyle;
                                    mapChartOutlierRegionStrokeStyle: LineStyle;
                                    mapChartSeparateRegionFillStyle: FillStyle;
                                    mapChartSeparateRegionStrokeStyle: LineStyle;
                                    dataGridBackgroundFillStyle: FillStyle;
                                    dataGridBackgroundStrokeStyle: LineStyle;
                                    dataGridTitleFont: FontSettings;
                                    dataGridTitleFillStyle: FillStyle;
                                    dataGridTextFont: FontSettings;
                                    dataGridTextFillStyle: FillStyle;
                                    dataGridCellBackgroundFillStyle: FillStyle;
                                    dataGridBorderStrokeStyle: LineStyle;
                                    dataGridScrollBarBackgroundFillStyle: FillStyle;
                                    dataGridScrollBarBackgroundStrokeStyle: LineStyle;
                                    dataGridScrollBarFillStyle: FillStyle;
                                    dataGridScrollBarStrokeStyle: LineStyle;
                                    dataGridScrollBarButtonFillStyle: FillStyle;
                                    dataGridScrollBarButtonStrokeStyle: LineStyle;
                                    dataGridScrollBarButtonArrowFillStyle: FillStyle;
                                    dataGridScrollBarButtonArrowStrokeStyle: LineStyle;
                                    sparkLineChartStrokeStyle: LineStyle;
                                    sparkPointChartFillStyle: FillStyle;
                                    sparkBarChartFillStyle: FillStyle;
                                    sparkBarChartStrokeStyle: LineStyle;
                                    sparkAreaChartFillStyle: FillStyle;
                                    sparkAreaChartStrokeStyle: LineStyle;
                                    sparkPieChartFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    sparkPieChartStrokeStyle: LineStyle;
                                    sparkChartBandFillStyle: FillStyle;
                                    sparkChartBandStrokeStyle: LineStyle;
                                    sparkChartConstantLineStrokeStyle: LineStyle;
                                    spiderChartBackgroundFillStyle: FillStyle;
                                    spiderChartBackgroundStrokeStyle: LineStyle;
                                    spiderChartTitleFont: FontSettings;
                                    spiderChartTitleFillStyle: FillStyle;
                                    spiderChartSeriesBackgroundFillStyle: FillStyle;
                                    spiderChartSeriesBackgroundStrokeStyle: LineStyle;
                                    spiderChartWebStyle: LineStyle;
                                    spiderChartScaleLabelFillStyle: FillStyle;
                                    spiderChartScaleLabelFont: FontSettings;
                                    spiderChartAxisLabelFillStyle: FillStyle;
                                    spiderChartAxisLabelFont: FontSettings;
                                    spiderChartAxisStrokeStyle: LineStyle;
                                    spiderChartAxisNibStrokeStyle: LineStyle;
                                    spiderSeriesFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    spiderSeriesStrokeStyle: ThemePropertyWithCallbackOption<LineStyle>;
                                    spiderSeriesPointFillStyle: ThemePropertyWithCallbackOption<FillStyle>;
                                    pieChartBackgroundFillStyle: FillStyle;
                                    pieChartBackgroundStrokeStyle: LineStyle;
                                    pieChartTitleFont: FontSettings;
                                    pieChartTitleFillStyle: FillStyle;
                                    pieChartSliceFillStylePalette: Palette<FillStyle>;
                                    pieChartSliceStrokeStyle: LineStyle;
                                    pieChartSliceLabelFont: FontSettings;
                                    pieChartSliceLabelFillStyle: FillStyle;
                                    pieChartConnectorStrokeStyle: LineStyle;
                                    funnelChartBackgroundFillStyle: FillStyle;
                                    funnelChartBackgroundStrokeStyle: LineStyle;
                                    funnelChartTitleFont: FontSettings;
                                    funnelChartTitleFillStyle: FillStyle;
                                    funnelChartSliceFillStylePalette: Palette<FillStyle>;
                                    funnelChartSliceStrokeStyle: LineStyle;
                                    funnelChartSliceLabelFont: FontSettings;
                                    funnelChartSliceLabelFillStyle: FillStyle;
                                    funnelChartConnectorStrokeStyle: LineStyle;
                                    pyramidChartBackgroundFillStyle: FillStyle;
                                    pyramidChartBackgroundStrokeStyle: LineStyle;
                                    pyramidChartTitleFont: FontSettings;
                                    pyramidChartTitleFillStyle: FillStyle;
                                    pyramidChartSliceFillStylePalette: Palette<FillStyle>;
                                    pyramidChartSliceStrokeStyle: LineStyle;
                                    pyramidChartSliceLabelFont: FontSettings;
                                    pyramidChartSliceLabelFillStyle: FillStyle;
                                    pyramidChartConnectorStrokeStyle: LineStyle;
                                    gaugeChartBackgroundFillStyle: FillStyle;
                                    gaugeChartBackgroundStrokeStyle: LineStyle;
                                    gaugeChartTitleFont: FontSettings;
                                    gaugeChartTitleFillStyle: FillStyle;
                                    gaugeChartEmptyGaugeFillStyle: FillStyle;
                                    gaugeChartEmptyGaugeStrokeStyle: LineStyle;
                                    gaugeChartGaugeFillStyle: FillStyle;
                                    gaugeChartIntervalLabelsFillStyle: FillStyle;
                                    gaugeChartIntervalLabelsFont: FontSettings;
                                    gaugeChartValueLabelFillStyle: FillStyle;
                                    gaugeChartValueLabelFont: FontSettings;
                                    uiPanelBackgroundFillStyle: FillStyle;
                                    uiPanelBackgroundStrokeStyle: LineStyle;
                                    zoomBandChartDefocusOverlayFillStyle: FillStyle;
                                    zoomBandChartSplitterStrokeStyle: LineStyle;
                                    zoomBandChartKnobFillStyle: FillStyle | ((resourcesBaseUrl: string) => FillStyle);
                                    zoomBandChartKnobSize: {
                                        x: number;
                                        y: number;
                                    };
                                    onScreenMenuBackgroundColor: Color;
                                    uiButtonFillStyle: FillStyle;
                                    uiButtonFillStyleHidden: FillStyle;
                                    uiButtonStrokeStyle: LineStyle;
                                    uiButtonSize: number;
                                    uiBackgroundFillStyle: FillStyle;
                                    uiBackgroundStrokeStyle: LineStyle;
                                    uiTextFillStyle: FillStyle;
                                    uiTextFillStyleHidden: FillStyle;
                                    uiTextFont: FontSettings;
                                    legendTitleFillStyle: FillStyle;
                                    legendTitleFont: FontSettings;
                                    cursorTickMarkerXBackgroundFillStyle: FillStyle;
                                    cursorTickMarkerXBackgroundStrokeStyle: LineStyle;
                                    cursorTickMarkerXTextFillStyle: FillStyle;
                                    cursorTickMarkerXTextFont: FontSettings;
                                    cursorTickMarkerYBackgroundFillStyle: FillStyle;
                                    cursorTickMarkerYBackgroundStrokeStyle: LineStyle;
                                    cursorTickMarkerYTextFillStyle: FillStyle;
                                    cursorTickMarkerYTextFont: FontSettings;
                                    cursorPointMarkerFillStyle: FillStyle;
                                    cursorPointMarkerSize: Point;
                                    cursorPointMarkerShape: PointShape;
                                    cursorResultTableFillStyle: FillStyle;
                                    cursorResultTableStrokeStyle: LineStyle;
                                    cursorResultTableTextFillStyle: FillStyle;
                                    cursorResultTableTextFont: FontSettings;
                                    cursorGridStrokeStyleX: LineStyle;
                                    cursorGridStrokeStyleY: LineStyle;
                                    chartMarkerPointMarkerFillStyle: FillStyle;
                                    chartMarkerPointMarkerSize: Point;
                                    chartMarkerPointMarkerShape: PointShape;
                                    seriesMarkerPointMarkerFillStyle: FillStyle;
                                    seriesMarkerPointMarkerSize: Point;
                                    seriesMarkerPointMarkerShape: PointShape;
                                }
                                /**
                                 * Properties of {@link Theme} that are optional, and officially only used in LightningChart JS Online Examples and projects.
                                 *
                                 * These are guaranteed to be included in all official Library Themes provided by LightningChart, but not required in custom Themes defined by users.
                                 *
                                 * If you want to use example theme properties in your application, then make sure to do these two things:
                                 *
                                 * 1) Use an official Theme supplied by LightningChart.
                                 * 2) If your project requires type safety, then add a sanity check that throws an error if the `Theme.examples` property is `undefined`, like this:
                                 *
                                 * ```ts
                                 *  // Example, ensure official LightningChart JS theme is in use.
                                 *  const theme = chart.getTheme()
                                 *  if (!theme.examples) {
                                 *      throw new Error(`LightningChart JS Theme.examples is undefined. You are probably using an unofficial theme and attempting to access example theme properties!`)
                                 *  }
                                 * ```
                                 *
                                 * @public
                                 * @beta    Theme example properties are primarly intended to be used by official LCJS applications and examples.
                                 *          As such, users should be aware that they may change even in minor version releases.
                                 */
                                export declare interface ThemeExampleProperties {
                                    positiveTextFillStyle: FillStyle;
                                    negativeTextFillStyle: FillStyle;
                                    positiveFillStyle: FillStyle;
                                    negativeFillStyle: FillStyle;
                                    positiveAreaFillStyle: FillStyle;
                                    negativeAreaFillStyle: FillStyle;
                                    positiveBackgroundFillStyle: FillStyle;
                                    negativeBackgroundFillStyle: FillStyle;
                                    /**
                                     * @privateRemarks  http://localhost:8080/map-example-1.html
                                     */
                                    badGoodColorPalette: Color[];
                                    /**
                                     * @privateRemarks  http://localhost:8080/examples/1110-temperature-heatmap.html
                                     */
                                    coldHotColorPalette: Color[];
                                    /**
                                     * @privateRemarks  http://localhost:8080/xy-heatmapGrid.html
                                     */
                                    intensityColorPalette: Color[];
                                    /**
                                     * @privateRemarks  http://localhost:8080/impressive/dashboard.html
                                     */
                                    spectrogramColorPalette: Color[];
                                    bollingerFillStyle: FillStyle;
                                    bollingerBorderFillStyle: FillStyle;
                                    /**
                                     * @privateRemarks  0033-sweepingLineDashboard
                                     */
                                    highlightPointColor: Color;
                                    /**
                                     * @privateRemarks  1300-dataGridCrypto
                                     */
                                    highlightDataGridColor: Color;
                                    /**
                                     * @privateRemarks  0503-dashboardBusiness
                                     */
                                    unfocusedDataColor: Color;
                                    mainDataColor: Color;
                                    header1Font: FontSettings;
                                    header2Font: FontSettings;
                                    header3Font: FontSettings;
                                }
                                /**
                                 * Type definition for property of {@link Theme} that can either be a hard defined value, or a callback function which provides a different value based on how many times it is requested.
                                 *
                                 * Can be used for example to set different color for 2nd series, 3rd series, etc.
                                 *
                                 * ```ts
                                 *  // Example, hard defined value
                                 *  lineSeriesStrokeStyle: new SolidLine({ thickness: 2, fillStyle: ColorRGBA(255, 0, 0) })
                                 * ```
                                 *
                                 * ```ts
                                 *  // Example, different color for each series
                                 *  lineSeriesStrokeStyle: (index) => new SolidLine({ thickness: 2, fillStyle: ColorHSV(index * 90) })
                                 * ```
                                 *
                                 * @public
                                 */
                                export declare type ThemePropertyWithCallbackOption<T> = T | Palette<T>;
                                /**
                                 *
                                 * A collection of default *library color theme* implementations.
                                 *
                                 * Color theme of components must be specified when it is created, and can't be changed afterwards (without destroying and recreating the component):
                                 *
                                 * ```js
                                 *  // Example syntax, create ChartXY with specific color theme.
                                 *  const chart = lightningChart().ChartXY({
                                 *      theme: Themes.light,
                                 *  })
                                 * ```
                                 *
                                 * LCJS default theme is {@link Themes.darkGold}.
                                 * @public
                                 */
                                export declare interface Themes {
                                    /**
                                     * A built-in dark color Theme.
                                     *
                                     * **DarkGold Theme is the current default LightningChart JS color theme**.
                                     */
                                    darkGold: OfficialTheme;
                                    /**
                                     * A built-in light color Theme.
                                     */
                                    light: OfficialTheme;
                                    /**
                                     * A built-in light nature-inspired color Theme.
                                     */
                                    lightNature: OfficialTheme;
                                    /**
                                     * A built-in dark, turquoise color Theme.
                                     *
                                     * This theme is based on a background picture (`turquoiseHexagon.jpg`) that is distributed along-side LightningChart JS in its `resources` folder
                                     * (`node_modules/@arction/lcjs/dist/resources`). In order to use this Theme, you have to host the resources in a file server and inform LightningChart of the URL of this file server.
                                     *
                                     * For more information, see {@link LightningChartOptions.resourcesBaseUrl}.
                                     */
                                    turquoiseHexagon: OfficialTheme;
                                    /**
                                     * A built-in dark, violet color Theme.
                                     *
                                     * This theme is based on a background picture (`cyberSpace.jpg`) that is distributed along-side LightningChart JS in its `resources` folder
                                     * (`node_modules/@arction/lcjs/dist/resources`). In order to use this Theme, you have to host the resources in a file server and inform LightningChart of the URL of this file server.
                                     *
                                     * For more information, see {@link LightningChartOptions.resourcesBaseUrl}.
                                     */
                                    cyberSpace: OfficialTheme;
                                }
                                /**
                                 *
                                 * A collection of default *library color theme* implementations.
                                 *
                                 * Color theme of components must be specified when it is created, and can't be changed afterwards (without destroying and recreating the component):
                                 *
                                 * ```js
                                 *  // Example syntax, create ChartXY with specific color theme.
                                 *  const chart = lightningChart().ChartXY({
                                 *      theme: Themes.darkTurquoise,
                                 *  })
                                 * ```
                                 *
                                 * LCJS default theme is {@link Themes.darkGold}.
                                 * @public
                                 */
                                export declare const Themes: Themes;
                                /**
                                 * Implementation of 2D Axis Tick.
                                 * @public
                                 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                 */
                                export declare class Tick extends _AbstractAxisTick {
                                }
                                /**
                                 * @public
                                 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                 */
                                declare class _Tick3D extends _AbstractAxisTick {
                                }
                                /**
                                 * Implementation specific values necessary for tick plotting.
                                 * @public
                                 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                 */
                                declare interface _Tick3DPlottingVariables extends _AbstractTickPlottingVariables {
                                    /**
                                     *
                                     */
                                    wuSize: Point3D;
                                    /**
                                     *
                                     */
                                    start: Point3D;
                                    /**
                                     *
                                     */
                                    end: Point3D;
                                    /**
                                     *
                                     */
                                    tickDirection3D: Point3D;
                                    /**
                                     *
                                     */
                                    tickDirection2D: Point;
                                    /**
                                     *
                                     */
                                    gridlinePositionA: Point3D;
                                    /**
                                     *
                                     */
                                    gridlinePositionB: Point3D;
                                    /**
                                     *
                                     */
                                    gridlinePositionC: Point3D;
                                }
                                /**
                                 * Interface for *TickMarker*, a part of {@link CustomTick} that represents the label and pointer attached to the Axis.
                                 *
                                 * Most styling of CustomTicks can be managed directly via {@link CustomTick} API, but for some rare cases
                                 * its *TickMarker* has to be mutated. TickMarker is accessed via {@link CustomTick.setMarker} method, using a callback function:
                                 *
                                 * ```typescript
                                 *  CustomTick.setMarker((tickMarker) =>
                                 *      // ... mutate TickMarker.
                                 *  )
                                 *
                                 *  //
                                 * ```
                                 * @public
                                 */
                                export declare interface TickMarker extends UIPart, GettableText, StyleTextAPI, Pointable {
                                }
                                /**
                                 * Implementation specific values necessary for tick plotting.
                                 * @public
                                 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                 */
                                declare interface _TickPlottingVariables extends _AbstractTickPlottingVariables {
                                    startPosition: number;
                                    gridStrokeLen: number;
                                    /**
                                     * Height level of Grid Stroke Start
                                     */
                                    gridStrokeStart: pixel;
                                    /**
                                     * Height level of Tick Stroke Start
                                     */
                                    tickStart: number;
                                }
                                /**
                                 * Variables calculated for each tick when plotting.
                                 *
                                 * Label : tick line + grid line positioning is split into two distinct phases for rendering optimizations,
                                 * these values are calculated when positioning the label and carried over to the line positioning phase.
                                 * @public
                                 * @privateRemarks Ideally internal but not feasible; has to be public so it is included in typings but the actual name is still obfuscated in docs and types.
                                 */
                                declare interface _TickSpecificPlottingVariables {
                                    posTickEnd3D: Point3D;
                                    posTickStart3D: Point3D;
                                    tickPositionRelative: number;
                                }
                                /**
                                 * Type map of valid parameter combinations for Axis.setTickStrategy().
                                 * @public
                                 */
                                export declare type TickStrategyParameters = {
                                    type: 'Empty';
                                } | {
                                    type: 'Numeric';
                                    styler: ImmutableMutator<NumericTickStrategy>;
                                } | {
                                    type: 'DateTime';
                                    styler: ImmutableMutator<DateTimeTickStrategy>;
                                } | {
                                    type: 'Time';
                                    styler: ImmutableMutator<TimeTickStrategy>;
                                };
                                /**
                                 * @public
                                 */
                                export declare type TickStrategyStyler<A, T> = A extends {
                                    type: T;
                                    styler: any;
                                } ? A['styler'] : never;
                                /**
                                 * @public
                                 */
                                export declare type TickStrategyType = TickStrategyParameters['type'];
                                /**
                                 * Class which is used to style *Axis* *Ticks*.
                                 *
                                 * Instances of TickStyle are *immutable*, meaning that its setters don't modify the object,
                                 * but instead return a completely new modified object.
                                 *
                                 * When creating a new TickStyle object from scratch, parameters can be passed like follows:
                                 * - `new TickStyle({ labelFillStyle: new SolidFill({ color: ColorHEX('#F00'), tickLength: 8 })`
                                 * @public
                                 */
                                export declare class TickStyle extends TickStyleRecord {
                                    /**
                                     * Construct a new TickStyle object based on this one, but with modified gridstroke length.
                                     * @param length - Length of GridStroke, where 1 = full and 0 = zero.
                                     * @returns New TickStyle object
                                     * @public
                                     */
                                    setGridStrokeLength(length: number): this;
                                    /**
                                     * Get length of GridStroke.
                                     * @returns Length of GridStroke, where 1 = full and 0 = zero.
                                     * @public
                                     */
                                    getGridStrokeLength(): number;
                                    /**
                                     * Construct a new TickStyle object based on this one, but with modified GridStroke style.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Specified SolidLine
                                     * TickStyle.setGridStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                     * // Changed thickness
                                     * TickStyle.setGridStrokeStyle((solidLine) => solidLine.setThickness(5))
                                     * // Hidden
                                     * TickStyle.setGridStrokeStyle(emptyLine)
                                     * ```
                                     *
                                     * Supported line styles:
                                     * - {@link SolidLine}
                                     * - {@link DashedLine}
                                     * - {@link emptyLine}
                                     *
                                     * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
                                     * @returns New TickStyle object
                                     * @public
                                     */
                                    setGridStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get style of GridStrokes.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getGridStrokeStyle(): LineStyle;
                                    /**
                                     * Set length of Ticks.
                                     * @param length - Length of Ticks as pixels.
                                     * @returns New TickStyle object
                                     * @public
                                     */
                                    setTickLength(length: pixel): this;
                                    /**
                                     * Get length of Ticks.
                                     * @returns Length of Ticks as pixels
                                     * @public
                                     */
                                    getTickLength(): pixel;
                                    /**
                                     * Construct a new TickStyle object based on this one, but with modified Tick style.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Specified SolidLine
                                     * TickStyle.setGridStrokeStyle(new SolidLine({ thickness: 2, fillStyle: new SolidFill({ color: ColorHEX('#F00') }) }))
                                     * // Changed thickness
                                     * TickStyle.setGridStrokeStyle((solidLine) => solidLine.setThickness(5))
                                     * // Hidden
                                     * TickStyle.setGridStrokeStyle(emptyLine)
                                     * ```
                                     * @param value - Either a SolidLine object or a function, which will be used to create a new SolidLine based on current value.
                                     * @returns New TickStyle object
                                     * @public
                                     */
                                    setTickStyle(style: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get style of Ticks.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getTickStyle(): LineStyle;
                                    /**
                                     * Set padding after Tick as pixels.
                                     * @param padding - Padding after Tick as pixels.
                                     * @returns New TickStyle object with modified Tick padding
                                     * @public
                                     */
                                    setTickPadding(padding: pixel): this;
                                    /**
                                     * Get padding after Tick as pixels.
                                     * @returns Padding after Tick as pixels.
                                     * @public
                                     */
                                    getTickPadding(): pixel;
                                    /**
                                     * Set fill style of Labels.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Specified FillStyle
                                     * TickStyle.setLabelFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                     * // Changed transparency
                                     * TickStyle.setLabelFillStyle((solidFill) => solidFill.setA(80))
                                     * // Hidden
                                     * TickStyle.setLabelFillStyle(emptyFill)
                                     * ```
                                     * @param style - Either a VisibleFill object or a function, which will be used to create a new VisibleFill based on current value.
                                     * @returns New TickStyle object
                                     * @public
                                     */
                                    setLabelFillStyle(style: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Label.
                                     * @returns Fill style of Label as a VisibleFill object
                                     * @public
                                     */
                                    getLabelFillStyle(): FillStyle;
                                    /**
                                     * Construct a new TickStyle object based on this one, but with modified Label font.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Specified FontSettings
                                     * TickStyle.setLabelFont(new FontSettings({ size: 24, style: 'italic' }))
                                     * // Set to bold
                                     * TickStyle.setLabelFont((fontSettings) => fontSettings.setWeight('bold'))
                                     * ```
                                     * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
                                     * @returns New TickStyle object
                                     * @public
                                     */
                                    setLabelFont(font: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of Labels.
                                     * @returns FontSettings object
                                     * @public
                                     */
                                    getLabelFont(): FontSettings;
                                    /**
                                     * Set padding after label as pixels.
                                     * @param padding - Padding after label as pixels.
                                     * @returns New TickStyle object with modified Label padding
                                     * @public
                                     */
                                    setLabelPadding(padding: pixel): this;
                                    /**
                                     * Get padding after label as pixels.
                                     * @returns Padding after label as pixels.
                                     * @public
                                     */
                                    getLabelPadding(): pixel;
                                    /**
                                     * Set alignment of Label respective to tick line.
                                     *
                                     * **after**: -1
                                     *
                                     * **center**: 0
                                     *
                                     * **before**: +1
                                     * @param alignment - Label alignment [-1, 1].
                                     * @returns New TickStyle object with modified Label alignment
                                     * @public
                                     */
                                    setLabelAlignment(alignment: number): this;
                                    /**
                                     * Get horizontal alignment of Label respective to tick line.
                                     * @returns Horizontal alignment [-1, 1].
                                     * @public
                                     */
                                    getLabelAlignment(): number;
                                    /**
                                     * Set rotation of Label title.
                                     * @param value - Rotation in degrees
                                     * @returns Object itself
                                     * @public
                                     */
                                    setLabelRotation(rotation: number): this;
                                    /**
                                     * Get rotation of Label title.
                                     * @returns Rotation in degrees
                                     * @public
                                     */
                                    getLabelRotation(): number;
                                }
                                /**
                                 * Properties of a TickStyle.
                                 * @public
                                 */
                                export declare interface TickStyleProperties {
                                    type: 'tick-style';
                                    /**
                                     * Length of GridStroke, where 1 = full and 0 = zero.
                                     * @public
                                     */
                                    gridStrokeLength: number;
                                    /**
                                     * Style of GridStroke as a SolidLine object.
                                     * @public
                                     */
                                    gridStrokeStyle: LineStyle;
                                    /**
                                     * Length of Tick itself as pixels.
                                     * @public
                                     */
                                    tickLength: pixel;
                                    /**
                                     * Style of Tick itself as a SolidLine object.
                                     * @public
                                     */
                                    tickStyle: LineStyle;
                                    /**
                                     * Padding after Tick as pixels.
                                     * @public
                                     */
                                    tickPadding: pixel;
                                    /**
                                     * Font of Label as FontSettings.
                                     * @public
                                     */
                                    labelFont: FontSettings;
                                    /**
                                     * FillStyle of Label.
                                     * @public
                                     */
                                    labelFillStyle: FillStyle;
                                    /**
                                     * Padding after label as pixels.
                                     * @public
                                     */
                                    labelPadding: pixel;
                                    /**
                                     * Horizontal alignment of Label respective to tick line.
                                     *
                                     * **left**: -1
                                     *
                                     * **center**: 0
                                     *
                                     * **right**: +1
                                     * @public
                                     */
                                    labelAlignment: number;
                                    /**
                                     * Label rotation in degrees.
                                     * @public
                                     */
                                    labelRotation: number;
                                }
                                /**
                                 * Record contractor for TickStyle.
                                 * @public
                                 */
                                declare const TickStyleRecord: Record_2.Factory<TickStyleProperties>;
                                /**
                                 * Collection of formatting functions used with {@link TimeTickStrategy}.
                                 *
                                 * Can be referenced in user applications for convenience.
                                 * @public
                                 */
                                export declare const TimeFormattingFunctions: {
                                    /**
                                     * Display hours, minutes and seconds.
                                     *
                                     * `'00:00:00'`
                                     */
                                    hhmmss: (value: number) => string;
                                    /**
                                     * Display hours, minutes, seconds and milliseconds.
                                     *
                                     * `'00:00:00.000'`
                                     */
                                    hhmmssmmm: (value: number) => string;
                                    /**
                                     * Display hours, minutes, seconds, milliseconds and microseconds.
                                     *
                                     * `'00:00:00.000000'`
                                     */
                                    hhmmssmmmuuu: (value: number) => string;
                                    /**
                                     * Display hours, minutes, seconds, milliseconds, microseconds and nanoseconds.
                                     *
                                     * `'00:00:00.000000000'`
                                     */
                                    hhmmssmmmuuunnn: (value: number) => string;
                                };
                                /**
                                 * *Axis Tick Strategy* that is designed for depicting time ranges between hundreds of hours to individual nanoseconds.
                                 *
                                 * Axis values are interpreted as milliseconds, for example:
                                 * - `0` -\> `00:00:00`
                                 * - `1 000` -\> `00:00:01`
                                 * - `3 600 000` -\> `01:00:00`
                                 * - `1` -\> `00:00:00.001`
                                 * - `0.001` -\> `00:00:00.000001`
                                 *
                                 * Axis interval ranges supported by `TimeTickStrategy`:
                                 * - Minimum: 100 nanoseconds (`0.0001`).
                                 * - Maximum: 100 hours (`8 640 000 000`)
                                 *
                                 * **Note, that available axis interval ranges can be also limited by the type of Axis**, refer to {@link Axis} documentation for more information.
                                 *
                                 * Axis tick strategy is selected with {@link Axis.setTickStrategy} method:
                                 *
                                 * ```js
                                 *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks)
                                 * ```
                                 *
                                 * All configuration of automatically created ticks is done using the callback from `setTickStrategy`,
                                 * see example below for the idea:
                                 *
                                 * ```js
                                 *  // Specify TickStrategy and use callback to style automatic ticks.
                                 *  Axis.setTickStrategy(AxisTickStrategies.Time, (timeTicks) => timeTicks
                                 *      // All methods of `TimeTickStrategy` can be used here for styling ticks.
                                 *      .setMajorTickStyle((majorTicks) => majorTicks
                                 *          .setLabelFont((font) => font
                                 *              .setWeight('bold')
                                 *          )
                                 *      )
                                 *  )
                                 * ```
                                 *
                                 * All available strategies for automatic Axis ticks creation can be referenced via {@link AxisTickStrategies}.
                                 * @public
                                 */
                                export declare class TimeTickStrategy extends TimeTickStrategyRecord implements MutableAxisTickStrategy {
                                    /**
                                     * Construct a new *TimeTickStrategy* object based on this one, but with modified major tick style.
                                     *
                                     * Example usage:
                                     *
                                     * **Set font of major ticks**:
                                     * ```javascript
                                     * Axis.setTickStrategy(
                                     *     AxisTickStrategies.Time,
                                     *     ( tickStrategy: TimeTickStrategy ) => tickStrategy
                                     *         .setMajorTickStyle(( tickStyle ) => tickStyle
                                     *             .setLabelFont(( font ) => font
                                     *                 .setWeight( 'bold' )
                                     *             )
                                     *         )
                                     * )
                                     * ```
                                     * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
                                     * @returns New *TimeTickStrategy* object.
                                     * @public
                                     */
                                    setMajorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
                                    /**
                                     * Get major tick style of this *TimeTickStrategy* object.
                                     * @returns Major tick style.
                                     * @public
                                     */
                                    getMajorTickStyle(): TickStyle;
                                    /**
                                     * Construct a new *TimeTickStrategy* object based on this one, but with modified minor tick style.
                                     *
                                     * Example usage:
                                     *
                                     * **Disable minor ticks**:
                                     * ```javascript
                                     * Axis.setTickStrategy(
                                     *     AxisTickStrategies.Time,
                                     *     ( tickStrategy: TimeTickStrategy ) => tickStrategy
                                     *         .setMinorTickStyle( emptyTick )
                                     * )
                                     * ```
                                     *
                                     * **Set font of minor ticks**:
                                     * ```javascript
                                     * Axis.setTickStrategy(
                                     *     AxisTickStrategies.Time,
                                     *     ( tickStrategy: TimeTickStrategy ) => tickStrategy
                                     *         .setMinorTickStyle(( tickStyle: TickStyle ) => tickStyle
                                     *             .setLabelFont(( font ) => font
                                     *                 .setWeight( 'bold' )
                                     *             )
                                     *         )
                                     * )
                                     * ```
                                     * @param value - Either a *TickStyle* object or a function, which creates a new one based on the existing style.
                                     *                              Passing a function only works if the existing style is **not** *emptyTick*.
                                     * @returns New *TimeTickStrategy* object.
                                     * @public
                                     */
                                    setMinorTickStyle(value: TickStyle | ImmutableMutator<TickStyle>): this;
                                    /**
                                     * Get minor tick style of this *TimeTickStrategy* object.
                                     * @returns Minor tick style.
                                     * @public
                                     */
                                    getMinorTickStyle(): TickStyle;
                                    /**
                                     * Set cursor formatter for this `TimeTickStrategy` object.
                                     *
                                     * This will override the date time formatting used by:
                                     * - Default cursor result table formatters.
                                     * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
                                     * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
                                     *
                                     * ```ts
                                     *  // Example syntax, custom cursor formatting.
                                     *  Axis.setTickStrategy(AxisTickStrategies.Time, (ticks) => ticks
                                     *      .setCursorFormatter((value, range, locale) =>
                                     *          value.toFixed(3)
                                     *      )
                                     *  )
                                     * ```
                                     * @param formatter - `FormattingFunction` or `undefined` to use default time cursor formatting.
                                     * @returns New *TimeTickStrategy* object.
                                     * @public
                                     */
                                    setCursorFormatter(formatter: FormattingFunction | undefined): this;
                                    /**
                                     * Get cursor formatter of this `TimeTickStrategy` object.
                                     *
                                     * @returns `FormattingFunction` as set by user, or `undefined` to indicate that the default time cursor formatting is configured.
                                     * @public
                                     */
                                    getCursorFormatter(): FormattingFunction | undefined;
                                    /**
                                     * Construct a new *TimeTickStrategy* object based on this one, but with modified timeOrigin.
                                     *
                                     * If a **timeOrigin** is defined, data-points will instead be interpreted as **milliseconds** since **timeOrigin**.
                                     *
                                     * Example usage:
                                     *
                                     * **Application with 24 hour time origin offset**:
                                     * ```javascript
                                     * Axis.setTickStrategy(AxisTickStrategies.Time,
                                     *     (tickStrategy) => tickStrategy.setTimeOrigin(24 * 60 * 60 * 1000)
                                     * )
                                     * ```
                                     *
                                     * @param timeOrigin - Millisecond offset or `undefined` to disable time origin offsetting.
                                     * @returns New *TimeTickStrategy* object.
                                     * @public
                                     */
                                    setTimeOrigin(timeOrigin: number | undefined): this;
                                    /**
                                     *  Get the *timeOrigin* of this *TimeTickStrategy* object.
                                     * @returns Current time origin milliseconds or *undefined*.
                                     * @public
                                     */
                                    getTimeOrigin(): number | undefined;
                                    /**
                                     * Utility method for setting *formatting function* of all numeric tick levels (major, minor) as well as cursor.
                                     *
                                     * Each formatting target can be individually overridden with following methods:
                                     * - {@link setMajorFormattingFunction} | major ticks
                                     * - {@link setMinorFormattingFunction} | minor ticks
                                     * - {@link setCursorFormatter} | cursor result table and ticks
                                     * @param formattingFunction - Function that formats a tick value to text.
                                     * @returns New *TimeTickStrategy* object.
                                     * @public
                                     */
                                    setFormattingFunction(formattingFunction: FormattingFunction): this;
                                    /**
                                     * Get major ticks formatting function of this *TimeTickStrategy* object.
                                     * @returns Formatting Function.
                                     * @public
                                     */
                                    getMajorFormattingFunction(): FormattingFunction | undefined;
                                    /**
                                     * Set major ticks formatting function of this *TimeTickStrategy* object.
                                     * @param formattingFunction - Formatting function to use with this *TimeTickStrategy* object.
                                     * @returns New *TimeTickStrategy* object.
                                     * @public
                                     */
                                    setMajorFormattingFunction(formattingFunction: FormattingFunction): this;
                                    /**
                                     * Get minor ticks formatting function of this *TimeTickStrategy* object.
                                     * @returns Formatting Function.
                                     * @public
                                     */
                                    getMinorFormattingFunction(): FormattingFunction | undefined;
                                    /**
                                     * Set minor ticks formatting function of this *TimeTickStrategy* object.
                                     * @param formattingFunction - Formatting function to use with this *TimeTickStrategy* object.
                                     * @returns New *TimeTickStrategy* object.
                                     * @public
                                     */
                                    setMinorFormattingFunction(formattingFunction: FormattingFunction): this;
                                }
                                /**
                                 * @public
                                 */
                                declare interface TimeTickStrategyProperties {
                                    type: 'time-ticks';
                                    /**
                                     * Style of Major ticks.
                                     */
                                    readonly majorTickStyle: TickStyle;
                                    /**
                                     * Style of Minor ticks.
                                     *
                                     * To disable minor ticks, set to **emptyTick**.
                                     */
                                    readonly minorTickStyle: TickStyle;
                                    /**
                                     * Formatting function used for major ticks.
                                     *
                                     * Use FormattingFunctions to select available ones or define custom function.
                                     *
                                     * **undefined** will result in default selection.
                                     */
                                    readonly majorFormattingFunction?: FormattingFunction;
                                    /**
                                     * Formatting function used for minor ticks.
                                     *
                                     * Use FormattingFunctions to select available ones or define custom function.
                                     *
                                     * **undefined** will result in default selection.
                                     */
                                    readonly minorFormattingFunction?: FormattingFunction;
                                    /**
                                     * Cursor formatter.
                                     *
                                     * This controls the formatting used by:
                                     * - Default cursor result table formatters.
                                     * - Default cursor tick formatters along Axis which uses this `TickStrategy`.
                                     * - `Axis.formatValue` method of the Axis which uses this `TickStrategy`.
                                     *
                                     * `undefined` means to use default Time cursor formatting.
                                     *
                                     * ```ts
                                     *  // Example value, custom cursor formatter
                                     *  cursorFormatter: (value, range, locale) => value.toFixed(3)
                                     * ```
                                     */
                                    readonly cursorFormatter: FormattingFunction | undefined;
                                    /**
                                     * optional "Time origin"  value.
                                     * If a **timeOrigin** is defined, data-points will instead be interpreted as milliseconds since **timeOrigin**.
                                     */
                                    readonly timeOrigin: number | undefined;
                                }
                                /**
                                 * @public
                                 */
                                declare const TimeTickStrategyRecord: Record_2.Factory<TimeTickStrategyProperties>;
                                /**
                                 * Event handler for pointer event (touch)
                                 * @param obj - Object
                                 * @param event - Browser PointerEvent that triggered the event
                                 * @public
                                 */
                                export declare type TouchEventHandler<T> = (obj: T, event: ExtendedPointerEvent) => void;
                                /**
                                 * Function for translating a `XY` coordinate between different *coordinate systems*.
                                 *
                                 * A *coordinate system* can be selected by a *scale* property of *chart*, or by specifying a pair of `Axis`.
                                 *
                                 * ```ts
                                 *  // Example 1, translate from percentage location in chart, to pixel location in chart.
                                 *  const pixelLocation = translatePoint(
                                 *      // percentage location within chart, where [0,0] = bottom left, and [100,100] = top right.
                                 *      { x: 10, y: 10 },
                                 *      chart.uiScale,
                                 *      chart.pixelScale
                                 *  )
                                 * ```
                                 *
                                 * ```ts
                                 *  // Example 2, translate axis coordinate to pixel location in chart.
                                 *  const pixelLocation = translatePoint(
                                 *      // axis coordinate.
                                 *      { x: 116.9, y: 26.4 },
                                 *      {
                                 *          x: chart.getDefaultAxisX(),
                                 *          y: chart.getDefaultAxisY(),
                                 *      },
                                 *      chart.pixelScale
                                 *  )
                                 *
                                 *  // NOTE: Translation from chart pixel coordinates to *document* is done using `engineLocation2Client` method.
                                 *  const pixelLocationDocument = chart.engine.engineLocation2Client(pixelLocation.x, pixelLocation.y)
                                 *  // `pixelLocationDocument` can now be used for absolute positioning HTML elements, or other such things...
                                 *
                                 * ```
                                 *
                                 * **Available chart coordinate systems:**
                                 *
                                 * Every LCJS chart class has two available *coordinate systems*:
                                 *
                                 * 1. `uiScale` | Percentage based coordinate system, where [0,0] = bottom left, and [100,100] = top right.
                                 * 2. `pixelScale` | Pixel based coordinate system, where [0,0] = bottom left.
                                 *
                                 * With `ChartXY`, *axes* can be also used (see example usage above).
                                 *
                                 * @param value - `XY` coordinate.
                                 * @param originScale - Source *coordinate system*.
                                 * @param targetScale - Target *coordinate system*.
                                 * @returns Coordinate that corresponds `value` on target *coordinate system*.
                                 * @public
                                 * @deprecated  Deprecated since v4.2.0. Deprecated over {@link Control.translateCoordinate} and {@link ChartXY.translateCoordinate}
                                 */
                                export declare const translatePoint: <DataPoint extends Point>(value: DataPoint, originScale: ScaleXY | Vec2<Axis | ScaleXY>, targetScale: ScaleXY | Vec2<Axis | ScaleXY>) => DataPoint;
                                /**
                                 * Function that translates a coordinate between different 3D coordinate systems.
                                 *
                                 * ```js
                                 *  // Example, translate coordinate from Chart3D Axes to World Space.
                                 *  const coordWorld = translatePoint3D(
                                 *      // Coordinate on Axes.
                                 *      { x: 10, y: 5, z: 25 },
                                 *      // Source coordinate system.
                                 *      chart3D.coordsAxis,
                                 *      // Target coordinate system.
                                 *      chart3D.coordsWorld
                                 *  )
                                 * ```
                                 *
                                 * @param coordinate - Coordinate to translate.
                                 * @param originCoordinateSystem - Coordinate system of `coordinate`.
                                 * @param targetCoordinateSystem - Target coordinate system.
                                 * @returns `coordinate` translated to `targetCoordinateSystem`.
                                 * @public
                                 * @deprecated  This function is deprecated since v4.2.0. Deprecated over {@link Chart3D.translateCoordinate}
                                 */
                                export declare const translatePoint3D: <DataPoint extends Coord3D>(coordinate: DataPoint, originCoordinateSystem: CoordinateSystemDefinition3D, targetCoordinateSystem: CoordinateSystemDefinition3D) => DataPoint;
                                /**
                                 * A {@link SolidFill} singleton for a completely transparent fill.
                                 * Can be useful in at least following cases:
                                 *
                                 * 1) User wants to hide something but still have it interactable by mouse/touch
                                 *
                                 * 2) User wants to hide something that does not support {@link emptyFill}
                                 *
                                 * Otherwise, {@link emptyFill} should be preferred for better performance.
                                 * @public
                                 */
                                export declare const transparentFill: SolidFill;
                                /**
                                 * A {@link SolidLine} singleton for a completely transparent line.
                                 * Can be useful in at least following cases:
                                 *
                                 * 1) User wants to hide something but still have it interactable by mouse/touch
                                 *
                                 * 2) User wants to hide something that does not support {@link emptyFill}
                                 *
                                 * Otherwise, {@link emptyLine} should be preferred for better performance.
                                 * @public
                                 */
                                export declare const transparentLine: SolidLine;
                                /**
                                 * A style class used to specify style of 3D points rendering as triangulated shapes.
                                 *
                                 * Supports specifying shape as a **cube** or a **sphere**.
                                 * @public
                                 */
                                export declare class TriangulatedPoints3D extends TriangulatedPoints3DRecord {
                                    /**
                                     * When creating a new TriangulatedPoints3D object, any amount of its default parameters can be *overriden*, by supplying the
                                     * values to its constructor:
                                     * ```javascript
                                     *  new PointStyle3D.Triangulated({
                                     *      size: 10,
                                     *      fillStyle: new SolidFill({ color: ColorHex('#FFF') }),
                                     *  })
                                     * ```
                                     * @param props - Optional object containing any amount of parameters of TriangulatedPoints3D
                                     * @public
                                     */
                                    constructor(props?: Partial<TriangulatedPoints3DProperties>);
                                    /**
                                     * Construct a new TriangulatedPoints3D object based on this one, but with different size.
                                     *
                                     * Two size definitions are supported: `number` and `Coord3D`:
                                     *
                                     * `number`:
                                     *
                                     * Symmetric size as _normalized World Units_ (roughly equal to pixels).
                                     *
                                     * {@link Coord3D}:
                                     *
                                     * User supplies size on each Axis, X, Y and Z individually, as Axis coordinates.
                                     *
                                     * ```js
                                     *  // Example syntax, 3D point size in Axis dimensions.
                                     *  pointSeries3D.setPointStyle(new TriangulatedPoints3D({
                                     *      size: { x: 10, y: 5, z: 200 },
                                     *      shape: 'sphere',
                                     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                                     *  }))
                                     * ```
                                     *
                                     * @param size - Points size.
                                     * @returns New TriangulatedPoints3D object
                                     * @public
                                     */
                                    setSize(size: number | Coord3D): this;
                                    /**
                                     * Get size of points rendered with this style object.
                                     * @returns Point size.
                                     * @public
                                     */
                                    getSize(): number | Coord3D;
                                    /**
                                     * Construct a new TriangulatedPoints3D object based on this one, but with modified fill style.
                                     *
                                     * Example usage:
                                     *
                                     * | Desired result         | Argument                                      |
                                     * | :--------------------- | :-------------------------------------------- |
                                     * | Specified FillStyle    | new SolidFill(\{ color: ColorHex('#F00') \})    |
                                     *
                                     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                                     * @returns New TriangulatedPoints3D object
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of TriangulatedPoints3D.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Construct a new TriangulatedPoints3D object based on this one, but with modified wireframe style.
                                     *
                                     * ```js
                                     *  // Example syntax,
                                     *  pointSeries3D.setPointStyle((style) => style
                                     *      .setWireframeStyle(new SolidLine({
                                     *          thickness: 1,
                                     *          fillStyle: new SolidFill({ color: ColorRGBA(255, 215, 0, 25) })
                                     *      }))
                                     *  )
                                     * ```
                                     *
                                     * @param value - Either a LineStyle object or a function, which will be used to create a new LineStyle based on current value.
                                     * @returns New TriangulatedPoints3D object
                                     * @public
                                     */
                                    setWireframeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get wireframe style of TriangulatedPoints3D.
                                     * @returns LineStyle object
                                     * @public
                                     */
                                    getWireframeStyle(): LineStyle;
                                }
                                /**
                                 * Interface for all properties of a TriangulatedPoints3D.
                                 * @public
                                 */
                                export declare interface TriangulatedPoints3DProperties {
                                    type: 'triangulated-points-3d';
                                    /**
                                     * Shape of rendered points.
                                     */
                                    shape: 'cube' | 'sphere';
                                    /**
                                     * Points size.
                                     *
                                     * Supports two types `number` or `Coord3D`:
                                     *
                                     * `number`:
                                     *
                                     * Symmetric size as _normalized World Units_ (roughly equal to pixels).
                                     *
                                     * {@link Coord3D}:
                                     *
                                     * User supplies size on each Axis, X, Y and Z individually, as Axis coordinates.
                                     *
                                     * ```js
                                     *  // Example syntax, 3D point size in Axis dimensions.
                                     *  pointSeries3D.setPointStyle(new TriangulatedPoints3D({
                                     *      size: { x: 10, y: 5, z: 200 },
                                     *      shape: 'sphere',
                                     *      fillStyle: new SolidFill({ color: ColorRGBA(255, 0, 0) })
                                     *  }))
                                     * ```
                                     */
                                    size: number | Coord3D;
                                    /**
                                     * *FillStyle* for rendering the points.
                                     */
                                    fillStyle: FillStyle;
                                    /**
                                     * *LineStyle* for rendering geometry wireframe.
                                     */
                                    wireframeStyle: LineStyle;
                                }
                                /**
                                 * Record contractor for TriangulatedPoints3DProperties.
                                 * @public
                                 */
                                declare const TriangulatedPoints3DRecord: Record_2.Factory<TriangulatedPoints3DProperties>;
                                /**
                                 * Type union of all JavaScript typed arrays.
                                 *
                                 * Read more [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays)
                                 * @public
                                 */
                                export declare type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;
                                /**
                                 * Public interface of Background.
                                 * Type of UiElement that can be used as a Background of another element.
                                 * @public
                                 */
                                export declare interface UIBackground {
                                    /**
                                     * Set FillStyle of Background.
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * @returns Current Background FillStyle
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stroke style of Background.
                                     * @param value - LineStyle object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * @returns Current Background LineStyle
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                }
                                /**
                                 * Collection of available {@link UIBackgrounds} Can be used to customize the *background* of an *UIElement*.
                                 *
                                 * *Background* must be specified when the *UIElement* is created by method of its *builder*.
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Create TextBox with specified Background
                                 * Chart.addUIElement(UIElementBuilders.TextBox.setBackground(UIBackgrounds.Circle))
                                 * ```
                                 * @public
                                 */
                                export declare const UIBackgrounds: {
                                    /**
                                     * No background.
                                     */
                                    None: typeof UIEmptyBackground;
                                    /**
                                     * Rectangular background.
                                     */
                                    Rectangle: typeof UIRectangle;
                                    /**
                                     * Circular background.
                                     */
                                    Circle: typeof UICircle;
                                    /**
                                     * 45 degree rotated rectangle background.
                                     */
                                    Diamond: typeof UIDiamond;
                                    /**
                                     * Arrow-like background.
                                     *
                                     * The *Pointers* direction can be modified by, for example:
                                     *
                                     * *UIElement*.setBackground((pointer) =\> pointer.setDirection(**UIDirections.Up**))
                                     *
                                     * This will throw an *error* if used on an *UIElement* with any other *Background*!
                                     */
                                    Pointer: typeof UIPointer;
                                };
                                /**
                                 * Type requirement for Pictures of Buttons.
                                 * @public
                                 */
                                export declare interface UIButtonPicture extends Picture, Fittable {
                                }
                                /**
                                 * Collection of available *UIButtonPicture*s. Can be used to customize the shape of buttons and checkboxes of *UIElements*.
                                 *
                                 * *ButtonPicture* must be specified when the *UIElement* is created by method of its *builder*.
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Create ButtonBox with specified ButtonPicture
                                 * Chart.addUIElement(UIElementBuilders.ButtonBox.setPictureOff(UIButtonPictures.Circle))
                                 * // Create LegendBox with specified ButtonPicture
                                 * Chart.addUIElement(UIElementBuilders.HorizontalLegendBox.setEntry(
                                 * UIElementBuilders.TextBox.setPictureOff(UIButtonPictures.Circle)))
                                 * ```
                                 * @public
                                 */
                                export declare const UIButtonPictures: {
                                    /**
                                     * Rectangular picture.
                                     */
                                    Rectangle: typeof UIRectangle;
                                    /**
                                     * Circular picture.
                                     */
                                    Circle: typeof UICircle;
                                    /**
                                     * 45 degree rotated rectangle picture.
                                     */
                                    Diamond: typeof UIDiamond;
                                };
                                /**
                                 * Interface for 'CheckBox'.
                                 * @public
                                 */
                                export declare interface UICheckBox<BackgroundType extends UIBackground = UIBackground> extends UIPartWithBackground<BackgroundType>, CustomizableText, StylableButton, Switchable {
                                    /**
                                     * Set text fill style when check box is OFF
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setTextFillStyleHidden(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * @returns Current text fill style
                                     * @public
                                     */
                                    getTextFillStyleHidden(): FillStyle;
                                }
                                /**
                                 * Interface for 'CheckBox'-builder.
                                 * @public
                                 */
                                export declare interface UICheckBoxBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UICheckBox<BackgroundType>> {
                                    /**
                                     * Make new CheckBoxBuilder with different background.
                                     * @param newBackground - Constructor for desired Background. See {@link UIBackgrounds} for a collection of options.
                                     * @public
                                     */
                                    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UICheckBoxBuilder<NewBackgroundType>;
                                    /**
                                     * Set button shape.
                                     *
                                     * ```ts
                                     *  // Example
                                     *  setButtonShape(PointShape.Star)
                                     * ```
                                     *
                                     * See {@link PointShape} for all available options.
                                     *
                                     * @public
                                     */
                                    setButtonShape(shape: PointShape): UICheckBoxBuilder<BackgroundType>;
                                }
                                /**
                                 * Circular UI shape that can be used as Background and as Button picture.
                                 * @public
                                 */
                                export declare class UICircle extends BorderedPicture implements InternalBackground, UIButtonPicture {
                                    /**
                                     * Set fill style of Picture
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Picture
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stoke style of Picture
                                     * @param value - LineStyle object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of Picture
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Fit object to bounding box.
                                     * @param bounds - Bounds in pixels
                                     * @returns Object itself
                                     * @public
                                     */
                                    fitTo(bounds: Point): this;
                                }
                                /**
                                 * Interface for builder of UiColumn layout
                                 * @public
                                 */
                                export declare interface UIColumnBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UIElementColumn<BackgroundType>> {
                                    /**
                                     * Make new ColumnBuilder with different background
                                     * @public
                                     */
                                    setBackground<NewBackgroundType extends BackgroundType>(newBackground: BackgroundConstructor<NewBackgroundType>): UIColumnBuilder<NewBackgroundType>;
                                }
                                /**
                                 * 45 degrees rotated Rectangle background.
                                 * @public
                                 */
                                export declare class UIDiamond extends UIPolygon implements InternalBackground, UIButtonPicture {
                                    /**
                                     * Set fill style of Picture
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Picture
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stoke style of Picture
                                     * @param value - LineStyle object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of Picture
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Fit object to bounding box.
                                     * @param bounds - Bounds in pixels
                                     * @returns Object itself
                                     * @public
                                     */
                                    fitTo(bounds: Point): this;
                                }
                                /**
                                 * Enum for specifying a direction. Used for styling *Pointable* *UIElements*.
                                 * @public
                                 */
                                export declare enum UIDirections {
                                    Up = 0,
                                    Right = 1,
                                    Down = 2,
                                    Left = 3
                                }
                                /**
                                 * Enum for selecting behavior of dragging interactions of *UIElements*. Dragging can be done by both mouse and touch.
                                 *
                                 * Use with {@link UIElement.setDraggingMode}
                                 * @public
                                 */
                                export declare enum UIDraggingModes {
                                    /**
                                     * *UIElement* is not draggable.
                                     */
                                    notDraggable = 0,
                                    /**
                                     * *UIElement* is draggable.
                                     */
                                    draggable = 1,
                                    /**
                                     * *UIElement* is only draggable on horizontal plane.
                                     */
                                    onlyHorizontal = 2,
                                    /**
                                     * *UIElement* is only draggable on vertical plane.
                                     */
                                    onlyVertical = 3
                                }
                                /**
                                 * Interface for a stand-alone *UIElement*.
                                 *
                                 * Adds ability for:
                                 * - Setting position
                                 * - Specifying draggability
                                 * @public
                                 */
                                export declare interface UIElement extends UIObject, UIPart, Draggable, Plotable {
                                    /**
                                     * Sets the position of this UiElement relative to its origin
                                     * @param position - Position
                                     * @public
                                     */
                                    setPosition(position: Point): this;
                                    /**
                                     * Returns the position of this UiElement at given location relative to elements size.
                                     * @param relativePosition - Relative position vector (-1 to 1 which specifies position of origin, 0 is center of the object)
                                     * @param spaceOfInterest - Parameter to disregard parts of object when calculating the asked position. Defaults to Margin.
                                     * @returns Object itself for fluent itself
                                     * @public
                                     */
                                    getPosition(relativePosition?: Point, spaceOfInterest?: UISpace): Point;
                                    /**
                                     * Sets the position origin of this UiElement.
                                     * @param origin - Relative position vector (-1 to 1, where 0 is center of the object).
                                     *                  UIOrigins, enum-like object can be used for easy selection of common values
                                     * @public
                                     */
                                    setOrigin(origin: Point): this;
                                    /**
                                     * Returns the position origin of this UiElement.
                                     * @returns Relative position vector (-1 to 1, where 0 is center of the object).
                                     * @public
                                     */
                                    getOrigin(): Point;
                                    /**
                                     * Returns the size of the UiElements in pixels including any Margins or Paddings
                                     * @param spaceOfInterest - Parameter to disregard parts of object when calculating the position. Defaults to Margin,
                                     *                              which includes everything. Should only ever be necessary for sub-classes
                                     * @returns Object size in pixels
                                     * @public
                                     */
                                    getSize(spaceOfInterest?: UISpace): Point;
                                    /**
                                     * Set auto dispose behavior for this UI element.
                                     *
                                     * Can be used to set a condition, where the UI element is automatically *disposed*, removing it from view.
                                     *
                                     * ```ts
                                     *  // Example, remove UI element when it is larger than 20% of viewport.
                                     *  UIElement.setAutoDispose({
                                     *      type: 'max-width',
                                     *      maxWidth: 0.20,
                                     *  })
                                     * ```
                                     * @param autoDisposeMode - Auto dispose mode.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setAutoDispose(autoDisposeMode: AutoDisposeMode): this;
                                    /**
                                     * Get auto dispose behavior for this UI element.
                                     * @returns Auto dispose mode.
                                     * @public
                                     */
                                    getAutoDispose(): AutoDisposeMode;
                                }
                                /**
                                 * Interface for abstract UiElement builder
                                 * @public
                                 */
                                export declare interface UIElementBuilder<UIElementType extends UIPart = UIPart> {
                                    /**
                                     * Make new Builder with an additional styler.
                                     * @param styler - UiElementStyler for specific type
                                     * @returns New Builder
                                     * @public
                                     */
                                    addStyler(styler: UIElementStyler<UIElementType>): this;
                                }
                                /**
                                 * Collection of available *UIElement* *builders*. To build *UIElements* you must pass one of these to method: **addUIElement()**.
                                 * This method can be accessed through *Charts*, {@link Dashboard}, Etc.
                                 *
                                 * Example usage:
                                 *```javascript
                                 * // Create a TextBox on a ChartXY
                                 * ChartXY.addUIElement(UIElementBuilders.TextBox)
                                 * // Create a CheckBox on a Dashboard
                                 * Dashboard.addUIElement(UIElementBuilders.CheckBox)
                                 * ```
                                 * @public
                                 */
                                export declare const UIElementBuilders: {
                                    /**
                                     * *UIElement* that displays text over a *Background*.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Create a TextBox
                                     * Chart.addUIElement(UIElementBuilders.TextBox)
                                     * ```
                                     */
                                    TextBox: UITextBoxBuilder;
                                    /**
                                     * *UIElement* that displays a toggleable checkbox and text over a *Background*.
                                     *
                                     * By default, *Background* is empty. To show it you must specify it using method of the *builder*, **setBackground**
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Create a CheckBox
                                     * Chart.addUIElement(UIElementBuilders.CheckBox)
                                     * // Create a CheckBox with specified Background
                                     * Chart.addUIElement(UIElementBuilders.CheckBox.setBackground(UIBackgrounds.Circle))
                                     * // Create a CheckBox with specified ButtonPicture
                                     * Chart.addUIElement(UIElementBuilders.CheckBox.setPictureOff(UIButtonPictures.Diamond))
                                     * ```
                                     */
                                    CheckBox: UICheckBoxBuilder;
                                    /**
                                     * *UIElement* that displays a button and text over a *Background*.
                                     *
                                     * By default, *Background* is empty. To show it you must specify it using method of the *builder*, **setBackground**
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Create a ButtonBox
                                     * Chart.addUIElement(UIElementBuilders.ButtonBox)
                                     * // Create a ButtonBox with specified Background
                                     * Chart.addUIElement(UIElementBuilders.ButtonBox.setBackground(UIBackgrounds.Circle))
                                     * // Create a ButtonBox with specified ButtonPicture
                                     * Chart.addUIElement(UIElementBuilders.ButtonBox.setPictureOff(UIButtonPictures.Diamond))
                                     * ```
                                     */
                                    ButtonBox: UICheckBoxBuilder;
                                    /**
                                     * *UIElement builder* that is intended to be used with *custom axis ticks*.
                                     * See {@link Axis.addCustomTick} for example usage, and more information.
                                     *
                                     * *PointableTextBox* is a text label enclosed within a background shaped in the form of an *arrow*.
                                     */
                                    PointableTextBox: UIPointableTextBoxBuilder;
                                    /**
                                     * *UIElement builder* that is intended to be used with *custom axis ticks*.
                                     * See {@link Axis.addCustomTick} for example usage, and more information.
                                     *
                                     * *AxisTick* is a text label connected to a *tick line* - fundamentally equal to a *default axis tick* shape.
                                     */
                                    AxisTickMajor: UITickBuilder;
                                    /**
                                     * *UIElement builder* that is intended to be used with *custom axis ticks*.
                                     * See {@link Axis.addCustomTick} for example usage, and more information.
                                     *
                                     * *AxisTick* is a text label connected to a *tick line* - fundamentally equal to a *default minor axis tick* shape.
                                     */
                                    AxisTickMinor: UITickBuilder;
                                    /**
                                     * *UIElement builder* that can be used to build a {@link UILUTRange} component.
                                     * which displays a color lookup table range with labels.
                                     *
                                     * ```js
                                     *  // Example usage,
                                     *  const lutRange = chart.addUIElement(UIElementBuilders.LUTRange)
                                     *      .setLUT(myLut)
                                     * ```
                                     */
                                    LUTRange: UILUTRangeBuilder;
                                };
                                /**
                                 * UI Layout for positioning UIElements in a column.
                                 * @public
                                 */
                                export declare class UIElementColumn<BackgroundClass extends UIBackground = UIBackground> extends UIElementLine<BackgroundClass> {
                                    /**
                                     * Add gap to Column.
                                     * Gap can have fixed height and it also has custom logic which makes it occupy any extra space
                                     * caused by setting the minimum size for Line.
                                     * @param fixedSize - Optional fixed size to set gap
                                     * @returns Gap object
                                     * @public
                                     */
                                    addGap(fixedSize?: pixel, index?: number): UILayoutGap;
                                }
                                /**
                                 * Base class for positioning of UiElements in a line
                                 * @public
                                 */
                                export declare abstract class UIElementLine<BackgroundType extends UIBackground = UIBackground> extends UIElementWithBackground<BackgroundType> {
                                    /**
                                     * Returns list of UiElements inside Line
                                     * @public
                                     */
                                    getMembers(): Array<UIPart>;
                                    /**
                                     * Get amount of members in group.
                                     * @returns Number
                                     * @public
                                     */
                                    getMemberCount(): number;
                                    /**
                                     * Set minimum size Layout should occupy (in direction of layout).
                                     * If set, Layout will distribute any extra space to UiLayoutGaps among its members.
                                     * @param minSize - Min size Layout should occupy (in direction of layout) or undefined to disable feature
                                     * @returns Object itself
                                     * @public
                                     */
                                    setMinimumSize(minSize: pixel | undefined): this;
                                    /**
                                     * Get minimum size Layout should occupy (in direction of layout).
                                     * If set, Layout will distribute any extra space to UiLayoutGaps among its members.
                                     * @returns Min size Layout should occupy (in direction of layout) or undefined to disable feature
                                     * @public
                                     */
                                    getMinimumSize(): pixel | undefined;
                                    /**
                                     * Add any UiElement using a builder
                                     * @param builder - Builder for any UiElement
                                     * @param index - Index position or \< 0 to push
                                     * @returns Created UiElement
                                     * @public
                                     */
                                    addElement<UiElementType extends UIPart>(builder: UIElementBuilder<UiElementType>, index?: number): UiElementType;
                                    /**
                                     * Add gap to line.
                                     * Gap can have fixed size and it also has custom logic which makes it occupy any extra space
                                     * caused by setting the minimum size for Line.
                                     * @param fixedSize - Optional fixed size to set gap
                                     * @param index - Index position or \< 0 to push
                                     * @returns Object itself
                                     * @public
                                     */
                                    abstract addGap(fixedSize?: pixel, index?: number): UILayoutGap;
                                    /**
                                     * **Permanently** destroy the component.
                                     *
                                     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                     * **to the component and its children** in application code.
                                     * ```javascript
                                     * let chart = ...ChartXY()
                                     * let axisX = chart.getDefaultAxisX()
                                     * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                     * chart.dispose()
                                     * chart = undefined
                                     * axisX = undefined
                                     * ```
                                     * @returns  Object itself for fluent interface
                                     * @public
                                     */
                                    dispose(): this;
                                    /**
                                     * Set element visibility.
                                     *
                                     * @param state - `true` when element should be visible and `false` when element should be hidden.
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setVisible(state: boolean): this;
                                    /**
                                     * Set mouse interactions enabled.
                                     * This will set the states of all members inside the Layout, overriding any previous settings.
                                     * @param state - Mouse interactions enabled
                                     * @public
                                     */
                                    setMouseInteractions(state: boolean): this;
                                    /**
                                     * Get mouse interactions enabled.
                                     * @returns True if any member of Layout has mouse interactions enabled.
                                     * @public
                                     */
                                    getMouseInteractions(): boolean;
                                    /**
                                     * Set state of component highlighting.
                                     *
                                     * ```ts
                                     *  // Example usage
                                     *
                                     *  component.setHighlight(true)
                                     *
                                     *  component.setHighlight(0.5)
                                     * ```
                                     *
                                     * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setHighlight(highlight: boolean | number): this;
                                }
                                /**
                                 * UI Layout for positioning UIElements in a row.
                                 * @public
                                 */
                                export declare class UIElementRow<BackgroundClass extends UIBackground = UIBackground> extends UIElementLine<BackgroundClass> {
                                    /**
                                     * Add gap to Row.
                                     * Gap can have fixed width and it also has custom logic which makes it occupy any extra space
                                     * caused by setting the minimum size for Line.
                                     * @param fixedSize - Optional fixed size to set gap
                                     * @returns Object itself
                                     * @public
                                     */
                                    addGap(fixedSize?: pixel, index?: number): UILayoutGap;
                                }
                                /**
                                 * Type of function for styling a generic UIElement.
                                 * @public
                                 */
                                export declare type UIElementStyler<T = UIElement> = (object: T, theme: Theme) => unknown;
                                /**
                                 * Public interface for a UiElement with background.
                                 * @public
                                 */
                                export declare abstract class UIElementWithBackground<BackgroundType extends UIBackground = UIBackground> extends InternalUIElement implements UIPartWithBackground<UIBackground> {
                                    /**
                                     * Subscribe to highlight object event. This is called whenever an object is highlighted.
                                     * @param handler - Function that is called when event is triggered.
                                     * @param isHighlighted - The Highlight state.
                                     * @returns Token that can be used to unsubscribe from the event.
                                     * @public
                                     */
                                    onHighlight(handler: (obj: this, isHighlighted: boolean | number) => void): Token;
                                    /**
                                     * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
                                     * @param token - Token that was received when subscribing to the event.
                                     * @returns True if the unsubscription was successful.
                                     * @public
                                     */
                                    offHighlight(token: Token): boolean;
                                    /**
                                     * Method for mutating Background of object.
                                     *
                                     * Type of Background is generic, see {@link UIBackground} for minimum interface.
                                     * @param mutator - Mutator function for Background
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setBackground(mutator: Mutator<BackgroundType>): this;
                                    /**
                                     * Get Background of object.
                                     *
                                     * Type of Background is generic, see {@link UIBackground} for minimum interface.
                                     * @returns Background object
                                     * @public
                                     */
                                    getBackground(): BackgroundType;
                                    /**
                                     * **Permanently** destroy the component.
                                     *
                                     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                     * **to the component and its children** in application code.
                                     * ```javascript
                                     * let chart = ...ChartXY()
                                     * let axisX = chart.getDefaultAxisX()
                                     * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                     * chart.dispose()
                                     * chart = undefined
                                     * axisX = undefined
                                     * ```
                                     * @returns  Object itself for fluent interface
                                     * @public
                                     */
                                    dispose(): this;
                                    /**
                                     * Set element visibility.
                                     *
                                     * @param state - `true` when element should be visible and `false` when element should be hidden.
                                     * @returns Object itself.
                                     */
                                    setVisible(state: boolean): this;
                                    private _padding;
                                    /**
                                     * Set padding around object in pixels.
                                     * Padding is empty space between the UiElements content and Background
                                     * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
                                     *                      for each side. Any side can be omitted, only passed values will be overridden.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setPadding(padding: Partial<Margin> | number): this;
                                    /**
                                     * Get padding around object in pixels.
                                     * Padding is empty space between the UiElements content and Background
                                     * @returns Margin datastructure
                                     * @public
                                     */
                                    getPadding(): Margin;
                                    /**
                                     * Returns the size of the UiElements in pixels including any Margins or Paddings
                                     * @param spaceOfInterest - Parameter to disregard parts of object when calculating the position. Defaults to Margin,
                                     *                              which includes everything. Should only ever be necessary for sub-classes
                                     * @returns Object size in pixels
                                     * @public
                                     */
                                    getSize(spaceOfInterest?: UISpace): Point;
                                    /**
                                     * Returns the position of this UiElement at given location relative to elements size.
                                     * @param relativePosition - Relative position vector (-1 to 1 which specifies position of origin, 0 is center of the object)
                                     * @param spaceOfInterest - Parameter to disregard parts of object when calculating the asked position.
                                     * @returns Object itself for fluent itself
                                     * @public
                                     */
                                    getPosition(relativePosition?: Point, spaceOfInterest?: UISpace): Point;
                                    /**
                                     * Set mouse interactions enabled or disabled
                                     * @param state - Specifies state of mouse interactions
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setMouseInteractions(state: boolean): this;
                                    private _highlightAmount;
                                    /**
                                     * @returns 1 for highlighted state of object and 0 for basic
                                     * @public
                                     */
                                    getHighlight(): number;
                                    /**
                                     * Set highlighted state of the Object.
                                     * Implementations should also remember to highlight themselves here.
                                     * @param highlight - Highlight state of the object
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setHighlight(highlight: boolean | number): this;
                                }
                                /**
                                 * Empty background.
                                 *
                                 * Indicates that the *Background* can't and shouldn't be styled as it won't be rendered.
                                 * @public
                                 */
                                export declare class UIEmptyBackground extends EmptyUIElement implements InternalBackground {
                                    /**
                                     * Subscribe to highlight object event. This is called whenever an object is highlighted.
                                     * @param handler - Function that is called when event is triggered.
                                     * @param isHighlighted - The Highlight state.
                                     * @returns Token that can be used to unsubscribe from the event.
                                     * @public
                                     */
                                    onHighlight(handler: (obj: this, isHighlighted: boolean) => void): Token;
                                    /**
                                     * Unsubscribe from Highlight object event. This is called whenever an object is highlighted
                                     * @param token - Token that was received when subscribing to the event.
                                     * @returns True if the unsubscription was successful.
                                     * @public
                                     */
                                    offHighlight(token: Token): boolean;
                                    /**
                                     * Set state of component highlighting.
                                     *
                                     * ```ts
                                     *  // Example usage
                                     *
                                     *  component.setHighlight(true)
                                     *
                                     *  component.setHighlight(0.5)
                                     * ```
                                     *
                                     * @param highlight - Boolean or number between 0 and 1, where 1 is fully highlighted.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setHighlight(highlight: boolean | number): this;
                                    /**
                                     * Get state of component highlighting.
                                     *
                                     * @returns Number between 0 and 1, where 1 is fully highlighted.
                                     * @public
                                     */
                                    getHighlight(): number;
                                    /**
                                     * Set fill style object
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setFillStyle(): this;
                                    /**
                                     * @returns Current fill style object
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stroke style object
                                     * @param value - LineStyle object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setStrokeStyle(): this;
                                    /**
                                     * @returns Current stroke style object
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Set stroke thickness in pixels
                                     * @param thickness - Stroke thickness in pixels
                                     * @returns Icon itself for fluent interface
                                     * @public
                                     */
                                    setStrokeThickness(): this;
                                    /**
                                     * @returns Object stroke thickness
                                     * @public
                                     */
                                    getStrokeThickness(): number;
                                }
                                /**
                                 * Collection of *UIElementBuilder*s for *Layout*s. These allow positioning multiple *UIElements* relative to each other.
                                 * @public
                                 */
                                export declare const UILayoutBuilders: {
                                    /**
                                     * *UIElement* for column layout, added *UIElements* will be layed out after one another **vertically**. Has a *Background*.
                                     *
                                     * By default, *Background* is hidden (style = {@link emptyFill}). To show it you must give it a style with: **UIColumn.setFillStyle**
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Create a Column
                                     * Chart.addUIElement(UILayouts.Column)
                                     * // Create a Column with specified Background
                                     * Chart.addUIElement(UILayouts.Column.setBackground(UIBackgrounds.Circle))
                                     * ```
                                     */
                                    Column: UIColumnBuilder;
                                    /**
                                     * *UIElement* for row layout, added *UIElements* will be layed out after one another **horizontally**. Has a *Background*.
                                     *
                                     * By default, *Background* is hidden (style = {@link emptyFill}). To show it you must give it a style with: **UIRow.setFillStyle**
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Create a Row
                                     * Chart.addUIElement(UILayouts.Row)
                                     * // Create a Row with specified Background
                                     * Chart.addUIElement(*UILayouts.Row.setBackground(UIBackgrounds.Circle))
                                     * ```
                                     */
                                    Row: UIRowBuilder;
                                };
                                /**
                                 * UiElement class that marks a 'gap' in line-layouts.
                                 * Positioning logic will make it so these gaps occupy all extra space.
                                 * @public
                                 */
                                export declare class UILayoutGap extends EmptyUIElement {
                                    /**
                                     * Set size of gap.
                                     * @param size - Size of gap as Vec2 of pixels
                                     * @returns Object itself
                                     * @public
                                     */
                                    setSize(size: Point): this;
                                }
                                /**
                                 * Public interface for builder of LegendBox.
                                 * @public
                                 */
                                export declare interface UILegendBoxBuilder<BackgroundType extends InternalBackground = InternalBackground> extends UIElementBuilder<LegendBox<BackgroundType>> {
                                    /**
                                     * Make new LegendBoxBuilder with different background
                                     * @param newBackground - Constructor for Background
                                     * @returns New LegendBoxBuilder
                                     * @public
                                     */
                                    setBackground<NewBackgroundType extends BackgroundType>(newBackground: BackgroundConstructor<NewBackgroundType>): UILegendBoxBuilder<NewBackgroundType>;
                                    /**
                                     * Make new LegendBoxBuilder with different alignment of entries.
                                     *
                                     * Eq. "Horizontal" meaning that the LegendBox progresses in the X-direction,
                                     * and aligns its groups downwards.
                                     * @param alignment - Alignment for LegendBox
                                     * @returns New LegendBoxBuilder
                                     * @public
                                     */
                                    setAlignment(alignment: 'horizontal' | 'vertical'): UILegendBoxBuilder<BackgroundType>;
                                    /**
                                     * Get alignment of LegendBoxBuilder.
                                     *
                                     * Eq. "Horizontal" meaning that the LegendBox progresses in the X-direction,
                                     * and aligns its groups downwards.
                                     * @returns Alignment for LegendBox
                                     * @public
                                     */
                                    getAlignment(): 'horizontal' | 'vertical';
                                    /**
                                     * Make new LegendBoxBuilder with explicitly styled title.
                                     * @param value - Styler function for a LegendBox title.
                                     * @returns New LegendBoxBuilder
                                     * @public
                                     */
                                    styleTitle(value: Mutator<UITextBox>): UILegendBoxBuilder<BackgroundType>;
                                    /**
                                     * Make new LegendBoxBuilder with explicitly styled entries.
                                     * @param value - Styler function for a LegendBoxEntry.
                                     * @returns New LegendBoxBuilder
                                     * @public
                                     */
                                    styleEntries(value: Mutator<LegendBoxEntry>): UILegendBoxBuilder<BackgroundType>;
                                }
                                /**
                                 * Component that can be added to a {@link Dashboard}, with method {@link Dashboard.createLegendBoxPanel}.
                                 *
                                 * It is a convenience component for placing *legend box items* from multiple different *charts* into a single *row layout*.
                                 *
                                 * **Example usage:**
                                 *
                                 * ```typescript
                                 *  // Add a UILegendBoxPanel to a Dashboard.
                                 *  const legendBoxPanel = dashboard.createLegendBoxPanel({
                                 *      columnIndex: 0,
                                 *      rowIndex: 0,
                                 *      columnSpan: 1,
                                 *      rowSpan: 1,
                                 *  })
                                 *
                                 *  // Add charts to shared Legend.
                                 *  legendBoxPanel
                                 *      .add(myChart1)
                                 *      .add(myChart2)
                                 *
                                 *  // Internally created LegendBoxes can be modified via callback.
                                 *  legendBoxPanel.setLegendBoxes((legendBox, chart) => {
                                 *      // Check reference to only apply style to LegendBox matching a specific chart.
                                 *      if (chart !== myChart1) return
                                 *      // Now, only the LegendBox matching 'myChart1' will be affected.
                                 *      legendBox
                                 *          .setTitle('Custom legend title')
                                 *          .setTitleFont((font) => font.setWeight('bold'))
                                 *  })
                                 * ```
                                 *
                                 * **Frequently used methods:**
                                 * - {@link UILegendBoxPanel.add}
                                 * - {@link UILegendBoxPanel.setLegendBoxes}
                                 *
                                 * **Related APIs**:
                                 * - {@link LegendBox}
                                 * - {@link LegendBoxEntry}
                                 *
                                 * For more application specific LegendBox requirements, it is recommended to:
                                 * - Use {@link UIPanel} and manage UI layouts and checkboxes on user application side.
                                 * - Craft the *user interface* outside LCJS, with *HTML* for example.
                                 * @public
                                 */
                                export declare class UILegendBoxPanel extends UIPanel {
                                    /**
                                     * Attach a *Chart* or collection of *Charts* to the *legend box panel*.
                                     *
                                     * This appends a new *legend box* to the panel, which will contain *entries* for all the attachable components in the supplied *chart*.
                                     *
                                     * The supplied argument can be either a single *chart*, or a *dashboard*, in which case all
                                     * currently existing charts inside the dashboard will be attached.
                                     *
                                     * The created *legend boxes* can be styled afterwards using {@link UILegendBoxPanel.setLegendBoxes}.
                                     *
                                     * **Example usage**:
                                     *
                                     * ```typescript
                                     *  // Add charts to LegendBoxPanel.
                                     *  legendBoxPanel
                                     *      .add(myChart1)
                                     *      .add(myChart2)
                                     *
                                     *  // ... or add all charts inside a Dashboard with a single call.
                                     *  legendBoxPanel.add(dashboard)
                                     * ```
                                     *
                                     * @param value - Chart or Dashboard.
                                     * @param opts - Optional extra configuration arguments.
                                     * @returns Object itself.
                                     * @public
                                     */
                                    add(value: Chart | Dashboard, opts?: LegendBoxAddOptions): this;
                                    /**
                                     * Trigger a callback for each *legend box* inside the panel.
                                     * Each legend box is paired with a single *chart* that the user has attached to the *legend box panel*,
                                     * which can be used for applying modifications to any particular *legend boxes* only.
                                     *
                                     * **Example usage:**
                                     *
                                     * ```typescript
                                     *  // Style internally created LegendBoxes. NOTE: Must be called after the LegendBoxes are created, using LegendBoxPanel.add()
                                     *  LegendBoxPanel.setLegendBoxes((legendBox, chart) => {
                                     *      legendBox
                                     *          // Style LegendBox title.
                                     *          .setTitleFont((font) => font.setWeight('bold'))
                                     *          // Style LegendBox entries.
                                     *          .setEntries((entry) => entry
                                     *              .setTextFont((font) => font.setSize(12))
                                     *          )
                                     *  })
                                     *
                                     *  // Style can be applied to selected LegendBoxes only by checking reference to supplied chart.
                                     *  LegendBoxPanel.setLegendBoxes((legendBox, chart) => {
                                     *      // Only apply style to LegendBox matching one single chart.
                                     *      if (chart !== myChart1) return
                                     *
                                     *      // Style legendBox ...
                                     *  })
                                     * ```
                                     *
                                     * @param clbk - Function that is called for each existing *legend box*, and attached *chart*.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setLegendBoxes(clbk: (legendBox: LegendBox, chart: Chart) => void): this;
                                    /**
                                     * Get minimum size of UIPanel in pixels as set by user.
                                     * @returns Point minimum size in pixels or undefined
                                     */
                                    getMinimumSize(): Point | undefined;
                                }
                                /**
                                 * Interface for 'LUTCheckBox'.
                                 * @public
                                 */
                                export declare interface UILUTCheckBox<BackgroundType extends UIBackground = UIBackground> extends UICheckBox<BackgroundType> {
                                    /**
                                     * Set attached LUT (color look up table).
                                     * @param lut - LUT (color look up table).
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setLUT(lut: LUT): this;
                                    /**
                                     * Get attached LUT (color look up table).
                                     * @returns (color look up table).
                                     * @public
                                     */
                                    getLUT(): LUT | undefined;
                                    /**
                                     * Set length of LUT box as pixels.
                                     * @param lengthPixels - Length as pixels.
                                     * @public
                                     */
                                    setLUTLength(lengthPixels: number): this;
                                    /**
                                     * Get length of LUT box as pixels.
                                     * @returns Length as pixels.
                                     * @public
                                     */
                                    getLUTLength(): number;
                                    /**
                                     * Set thickness of LUT box as pixels.
                                     * @param thicknessPixels - Thickness as pixels.
                                     * @public
                                     */
                                    setLUTThickness(thicknessPixels: number): this;
                                    /**
                                     * Get thickness of LUT box as pixels.
                                     * @returns Thickness as pixels.
                                     * @public
                                     */
                                    getLUTThickness(): number;
                                    /**
                                     * Set displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
                                     * @param unit - String to display next to Look Up Values.
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setLookUpUnit(unit: string): this;
                                    /**
                                     * Get displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
                                     * @returns String to display next to Look Up Values.
                                     * @public
                                     */
                                    getLookUpUnit(unit: string): this;
                                    /**
                                     * Specify step value formatting of LUT Legend.
                                     *
                                     * **Example usage:**
                                     *
                                     * ```ts
                                     *  // Display one fraction.
                                     *  setStepValueFormatter((step, lut) => step.value.toFixed(1))
                                     * ```
                                     * @param formatter - Callback function that receives the {@link LUTStep} object created by user, and maps it into a string that is displayed in the label.
                                     * @public
                                     */
                                    setLUTStepValueFormatter(formatter: (step: LUTStep, lut: LUT) => string): this;
                                    /**
                                     * Set whether distances between LUT step values are displayed, or if the displayed LUT steps should be split equal distances apart.
                                     *
                                     * By default this is disabled.
                                     * @param enabled - enabled Boolean.
                                     * @returns              Object itself.
                                     */
                                    setLUTDisplayProportionalSteps(enabled: boolean): this;
                                    /**
                                     * Get whether distances between LUT step values are displayed, or if the displayed LUT steps should be split equal distances apart.
                                     *
                                     * By default this is disabled.
                                     * @returns              Boolean.
                                     */
                                    getLUTDisplayProportionalSteps(): boolean;
                                    /**
                                     * Set fill style of LUT color steps and unit.
                                     *
                                     * Note that this style is overridden by calls to `setTextFillStyle`, which affects all text of the component.
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setLUTTextFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * @returns Current fill style of LUT color steps and unit
                                     * @public
                                     */
                                    getLUTTextFillStyle(): FillStyle;
                                    /**
                                     * Set font of LUT color steps and unit text.
                                     *
                                     * Note that this style is overridden by calls to `setTextFont`, which affects all text of the component.
                                     * @param value - FontSettings or mutator function for existing settings
                                     * @returns Object itself
                                     * @public
                                     */
                                    setLUTTextFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of LUT color steps and unit text.
                                     * @returns FontSettings
                                     * @public
                                     */
                                    getLUTTextFont(): FontSettings;
                                }
                                /**
                                 * Interface for 'LUTCheckBox'-builder.
                                 * @public
                                 */
                                export declare interface UILUTCheckBoxBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UILUTCheckBox<BackgroundType>> {
                                    /**
                                     * Make new UILUTCheckBoxBuilder with different background.
                                     * @param newBackground - Constructor for desired Background. See {@link UIBackgrounds} for a collection of options.
                                     * @public
                                     */
                                    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UILUTCheckBoxBuilder<NewBackgroundType>;
                                    /**
                                     * Set button shape.
                                     *
                                     * ```ts
                                     *  // Example
                                     *  setButtonShape(PointShape.Star)
                                     * ```
                                     *
                                     * See {@link PointShape} for all available options.
                                     *
                                     * @public
                                     */
                                    setButtonShape(shape: PointShape): UILUTCheckBoxBuilder<BackgroundType>;
                                    /**
                                     * Make new UILUTCheckBoxBuilder with different alignment.
                                     * @param alignment - Alignment for UILUTCheckBox
                                     * @returns New UILUTCheckBoxBuilder
                                     * @public
                                     */
                                    setAlignment(alignment: 'horizontal' | 'vertical'): UILUTCheckBoxBuilder<BackgroundType>;
                                }
                                /**
                                 * Interface for `UILUTRange`, UI element which displays a color lookup table range with labels.
                                 * @public
                                 */
                                export declare interface UILUTRange<BackgroundType extends UIBackground = UIBackground> extends UIPartWithBackground<BackgroundType>, StyleTextAPI {
                                    /**
                                     * Set attached LUT (color look up table).
                                     * @param lut - LUT (color look up table).
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setLUT(lut: LUT): this;
                                    /**
                                     * Get attached LUT (color look up table).
                                     * @returns (color look up table).
                                     * @public
                                     */
                                    getLUT(): LUT | undefined;
                                    /**
                                     * Set length of LUT box as pixels.
                                     * @param lengthPixels - Length as pixels.
                                     * @public
                                     */
                                    setLUTLength(lengthPixels: number): this;
                                    /**
                                     * Get length of LUT box as pixels.
                                     * @returns Length as pixels.
                                     * @public
                                     */
                                    getLUTLength(): number;
                                    /**
                                     * Set thickness of LUT box as pixels.
                                     * @param thicknessPixels - Thickness as pixels.
                                     * @public
                                     */
                                    setLUTThickness(thicknessPixels: number): this;
                                    /**
                                     * Get thickness of LUT box as pixels.
                                     * @returns Thickness as pixels.
                                     * @public
                                     */
                                    getLUTThickness(): number;
                                    /**
                                     * Set displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
                                     * @param unit - String to display next to Look Up Values.
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setLookUpUnit(unit: string): this;
                                    /**
                                     * Get displayed unit of Look Up Values. For example, "mm/h" (millimetres per hour).
                                     * @returns String to display next to Look Up Values.
                                     * @public
                                     */
                                    getLookUpUnit(unit: string): string;
                                    /**
                                     * Specify step value formatting of LUT Legend.
                                     *
                                     * **Example usage:**
                                     *
                                     * ```ts
                                     *  // Display one fraction.
                                     *  setStepValueFormatter((step, lut) => step.value.toFixed(1))
                                     * ```
                                     * @param formatter - Callback function that receives the {@link LUTStep} object created by user, and maps it into a string that is displayed in the label.
                                     * @public
                                     */
                                    setLUTStepValueFormatter(formatter: (step: LUTStep, lut: LUT) => string): this;
                                }
                                /**
                                 * Interface for `UILUTRange` builder.
                                 * @public
                                 */
                                export declare interface UILUTRangeBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UILUTRange> {
                                    /**
                                     * Make new UILUTRangeBuilder with different background
                                     * @param newBackground - Constructor for desired Background. See {@link UIBackgrounds} for a collection of options.
                                     * @public
                                     */
                                    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UILUTRangeBuilder<NewBackgroundType>;
                                    /**
                                     * Make new UILUTRangeBuilder with different alignment.
                                     * @param alignment - Alignment for UILUTRange
                                     * @returns New UILUTRangeBuilder
                                     * @public
                                     */
                                    setAlignment(alignment: 'horizontal' | 'vertical'): UILUTRangeBuilder;
                                }
                                /**
                                 * Type definition for a mouse style setting. This tells how mouse should look when hovering over an UIElement.
                                 *
                                 * For a collection of mouse styles, see {@link MouseStyles}.
                                 * @public
                                 */
                                export declare type UIMouseStyle = string | DynamicUIMouseStyle<UIElement>;
                                /**
                                 * Base class for Mouse-interactable ui-objects.
                                 * @public
                                 */
                                export declare abstract class UIObject implements Interactable, Hideable, HideableEvents {
                                    /**
                                     * Subscribe to Mouse Enter event
                                     * @param listener - Function that will be called when mouse enters the bounds of UiObject.
                                     * @param obj - Always object itself.
                                     * @param event - MouseEvent that triggered the listener.
                                     * @returns Token-object that is a reference ID to the listener created.
                                     * @public
                                     */
                                    onMouseEnter(listener: MouseEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Leave event
                                     * @param listener - Function that will be called when mouse leaves the bounds of UiObject.
                                     * @param obj - Always object itself.
                                     * @param event - MouseEvent that triggered the listener.
                                     * @returns Token-object that is a reference ID to the listener created.
                                     * @public
                                     */
                                    onMouseLeave(listener: AbruptMouseEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Click event
                                     * @param listener - Function that will be called when mouse clicks the bounds of UiObject.
                                     * @param obj - Always object itself.
                                     * @param event - MouseEvent that triggered the listener.
                                     * @returns Token-object that is a reference ID to the listener created.
                                     * @public
                                     */
                                    onMouseClick(listener: MouseEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Double Click event
                                     * @public
                                     */
                                    onMouseDoubleClick(listener: MouseEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Down event
                                     * @public
                                     */
                                    onMouseDown(listener: MouseEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Up event
                                     * @public
                                     */
                                    onMouseUp(listener: MouseEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Move event
                                     * @param listener - Event handler function
                                     * @returns Token of subscription
                                     * @public
                                     */
                                    onMouseMove(listener: MouseEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Drag Start event
                                     * @public
                                     */
                                    onMouseDragStart(listener: MouseDragStartEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Drag event
                                     * @public
                                     */
                                    onMouseDrag(listener: MouseDragEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Drag Stop event
                                     * @public
                                     */
                                    onMouseDragStop(listener: MouseDragStopEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Mouse Wheel event
                                     * @param listener - Event handler function
                                     * @returns Token of subscription
                                     * @public
                                     */
                                    onMouseWheel(listener: MouseWheelEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Touch Start event
                                     * @param listener - Event handler function
                                     * @returns Token of subscription
                                     * @public
                                     */
                                    onTouchStart(listener: TouchEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Touch Move event
                                     * @param listener - Event handler function
                                     * @returns Token of subscription
                                     * @public
                                     */
                                    onTouchMove(listener: TouchEventHandler<this>): Token;
                                    /**
                                     * Subscribe to Touch End event
                                     * @param listener - Event handler function
                                     * @returns Token of subscription
                                     * @public
                                     */
                                    onTouchEnd(listener: TouchEventHandler<this>): Token;
                                    /**
                                     * Remove event listener from Mouse Enter Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseEnter(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Leave Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseLeave(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Click Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseClick(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Double Click Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseDoubleClick(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Down Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseDown(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Up Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseUp(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Move Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseMove(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Drag Start Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseDragStart(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Drag Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseDrag(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Drag Stop Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseDragStop(token: Token): boolean;
                                    /**
                                     * Remove event listener from Mouse Wheel Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offMouseWheel(token: Token): boolean;
                                    /**
                                     * Remove event listener from Touch Start Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offTouchStart(token: Token): boolean;
                                    /**
                                     * Remove event listener from Touch Move Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offTouchMove(token: Token): boolean;
                                    /**
                                     * Remove event listener from Touch End Event
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offTouchEnd(token: Token): boolean;
                                    /**
                                     * Set mouse interactions enabled.
                                     * Implementations should update the mouse-interactions of any Shapes they may contain here.
                                     * @param state -
                                     * @public
                                     */
                                    abstract setMouseInteractions(state: boolean): this;
                                    /**
                                     * @returns Mouse interactions state
                                     * @public
                                     */
                                    abstract getMouseInteractions(): boolean;
                                    /**
                                     * Get boolean flag for whether object is currently under mouse or not
                                     * @returns Boolean for is object under mouse currently
                                     * @public
                                     */
                                    getIsUnderMouse(): boolean;
                                    /**
                                     * Set element visibility.
                                     *
                                     * @param state - `true` when element should be visible and `false` when element should be hidden.
                                     * @returns Object itself.
                                     * @public
                                     */
                                    setVisible(state: boolean): this;
                                    /**
                                     * Get element visibility.
                                     *
                                     * @returns `true` when element is set to be visible and `false` otherwise.
                                     * @public
                                     */
                                    getVisible(): boolean;
                                    /**
                                     * Register new event listener to `visibleStateChanged` event.
                                     *
                                     * @param listener - Event listener for `visibleStateChanged`
                                     * @public
                                     */
                                    onVisibleStateChanged(listener: VisibleStateChangedHandler<this>): Token;
                                    /**
                                     * Remove event listener from `visibleStateChanged`
                                     * @public
                                     */
                                    offVisibleStateChanged(token: Token): boolean;
                                }
                                /**
                                 * Collection of fast-access *arguments* for {@link UIElement.setOrigin}
                                 * @public
                                 */
                                export declare const UIOrigins: {
                                    LeftBottom: Point;
                                    CenterBottom: Point;
                                    RightBottom: Point;
                                    LeftCenter: Point;
                                    Center: Point;
                                    RightCenter: Point;
                                    LeftTop: Point;
                                    CenterTop: Point;
                                    RightTop: Point;
                                };
                                /**
                                 * Class for a panel that can have UI elements added into it.
                                 * @public
                                 */
                                export declare class UIPanel extends Panel {
                                    /**
                                     * Set minimum size of UIPanel in pixels.
                                     * This will affect its resizability by dragging dashboard splitters.
                                     * @param minimumSize - Minimum size as Point pixels
                                     * @public
                                     */
                                    setMinimumSize(minimumSize: Point): this;
                                    /**
                                     * Get minimum size of UIPanel in pixels as set by user.
                                     * @returns Point minimum size in pixels or undefined
                                     * @public
                                     */
                                    getMinimumSize(): Point | undefined;
                                }
                                /**
                                 * Interface for abstract part of an *UIElement*, that does not manage its own location (for example, part of a *layout*).
                                 * @public
                                 */
                                export declare interface UIPart extends Interactable, Marginable, Disposable, DisposableEvents, ComponentWithEffects {
                                    /**
                                     * Set mouse style when hovering over UI object.
                                     * @param mouseStyle - Interface for defining how mouse should look when hovering over UI object
                                     * @returns Object itself
                                     * @public
                                     */
                                    setMouseStyle(mouseStyle: UIMouseStyle): this;
                                    /**
                                     * Get mouse style.
                                     * @returns Interface for defining how mouse should look when hovering over UI object
                                     * @public
                                     */
                                    getMouseStyle(): UIMouseStyle;
                                }
                                /**
                                 * Public interface for a UiElement that has background, but is not responsible for its own positioning.
                                 * @public
                                 */
                                export declare interface UIPartWithBackground<BackgroundType extends UIBackground> extends UIPart, StylableBackground<BackgroundType> {
                                }
                                /**
                                 * UI Shape that can be used as button picture
                                 * @public
                                 */
                                export declare class UIPoint extends Picture implements UIButtonPicture, PointMarker {
                                    /**
                                     * Set displayed shape.
                                     *
                                     * ```ts
                                     *  // Example
                                     *  setShape(PointShape.Star)
                                     * ```
                                     *
                                     * See {@link PointShape} for all available options.
                                     *
                                     * @public
                                     */
                                    setShape(shape: PointShape): this;
                                    /**
                                     * Get displayed shape.
                                     * @public
                                     */
                                    getShape(): PointShape;
                                    /**
                                     * Set rotation of point shape in degrees.
                                     * @param   rotationDeg - Rotation in degrees.
                                     * @returns     Object itself.
                                     * @public
                                     */
                                    setRotation(rotationDeg: number): this;
                                    /**
                                     * Get rotation of point shape in degrees.
                                     * @returns     Rotation as degrees
                                     * @public
                                     */
                                    getRotation(): number;
                                    /**
                                     * Set fill style of Picture
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Picture
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Fit object to bounding box.
                                     * @param bounds - Bounds in pixels
                                     * @returns Object itself
                                     * @public
                                     */
                                    fitTo: (size: Point) => this;
                                    /**
                                     * Set size of PointMarker
                                     * @param size - Size of PointMarker in pixels
                                     * @returns Object itself
                                     * @public
                                     */
                                    setSize: (size: Point) => this;
                                }
                                /**
                                 * Interface for 'PointableTextBox'.
                                 * @public
                                 */
                                export declare interface UIPointableTextBox<BackgroundType extends UIBackground = UIBackground> extends UITextBox<BackgroundType>, Pointable {
                                }
                                /**
                                 * Interface for 'PointableTextBox'-builder.
                                 * @public
                                 */
                                export declare interface UIPointableTextBoxBuilder<BackgroundType extends PointableBackground = PointableBackground> extends UIElementBuilder<UIPointableTextBox<BackgroundType>> {
                                    /**
                                     * Make new PointableTextBoxBuilder with different background.
                                     * @param newBackground - Constructor for desired PointableBackground. Currently only UIBackgrounds.Arrow is available.
                                     */
                                    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: PointableBackgroundConstructor<NewBackgroundType>): UIPointableTextBoxBuilder<NewBackgroundType>;
                                }
                                /**
                                 * Background that has a pointable 'arrow'
                                 * @public
                                 */
                                export declare class UIPointer extends UIPolygon implements InternalBackground {
                                    /**
                                     * Set fill style of Picture
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Picture
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stoke style of Picture
                                     * @param value - LineStyle object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of Picture
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Set direction.
                                     * @param direction - Enum Direction
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setDirection(direction: UIDirections): this;
                                    /**
                                     * Get direction.
                                     * @returns Enum Direction
                                     * @public
                                     */
                                    getDirection(): UIDirections;
                                    /**
                                     * Set length of Pointable head in pixels.
                                     * @param length - Head length in pixels
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setPointerLength(length: pixel): this;
                                    /**
                                     * Get length of Pointable head in pixels.
                                     * @returns Pixel length
                                     * @public
                                     */
                                    getPointerLength(): pixel;
                                    /**
                                     * Set angle of Pointable in degrees.
                                     * @param angle - Angle of pointer or undefined to match head & body size
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setPointerAngle(angle?: number): this;
                                    /**
                                     * Get angle of Pointable in degrees.
                                     * @returns Angle in degrees
                                     * @public
                                     */
                                    getPointerAngle(): pixel;
                                }
                                /**
                                 * Abstract background formed with a polygon shape
                                 * @public
                                 */
                                export declare abstract class UIPolygon extends BorderedPicture {
                                    /**
                                     * Set element visibility.
                                     *
                                     * @param state - `true` when element should be visible and `false` when element should be hidden.
                                     * @returns Object itself.
                                     */
                                    setVisible(state: boolean): this;
                                }
                                /**
                                 * Rectangular UI shape that can be used as Background or Button picture.
                                 * @public
                                 */
                                export declare class UIRectangle extends BorderedPicture implements InternalBackground, UIButtonPicture {
                                    /**
                                     * Set fill style of Picture
                                     * @param value - Fill style object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Picture
                                     * @public
                                     */
                                    getFillStyle(): FillStyle;
                                    /**
                                     * Set stoke style of Picture
                                     * @param value - LineStyle object or function which modifies it
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of Picture
                                     * @public
                                     */
                                    getStrokeStyle(): LineStyle;
                                    /**
                                     * Fit object to bounding box.
                                     * @param bounds - Bounds in pixels
                                     * @returns Object itself
                                     * @public
                                     */
                                    fitTo: (size: Point) => this;
                                    /**
                                     * Set size of PointMarker
                                     * @param size - Size of PointMarker in pixels
                                     * @returns Object itself
                                     * @public
                                     */
                                    setSize: (size: Point) => this;
                                }
                                /**
                                 * Interface for builder of UiRow layout
                                 * @public
                                 */
                                export declare interface UIRowBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UIElementRow<BackgroundType>> {
                                    /**
                                     * Make new RowBuilder with different background
                                     * @public
                                     */
                                    setBackground<NewBackgroundType extends BackgroundType>(newBackground: BackgroundConstructor<NewBackgroundType>): UIRowBuilder<NewBackgroundType>;
                                }
                                /**
                                 * Class which represents a grid of abstract UiElements.
                                 * Grid is formed from horizontal lines, 'rows', that can have individual member anchoring.
                                 * @public
                                 */
                                export declare class UIRowGrid<BackgroundClass extends UIBackground = UIBackground> extends UIElementColumn<BackgroundClass> {
                                    /**
                                     * Add new row to grid
                                     * @public
                                     */
                                    addRow(): UIElementRow;
                                    /**
                                     * Get row at specified index
                                     * @param index - Index to look for
                                     * @param ensure - ? If true, grid adds the row and any missing ones if it doesn't exist
                                     * @returns UiElementRow at given index
                                     * @public
                                     */
                                    getRow(index: number, ensure?: boolean): UIElementRow;
                                }
                                /**
                                 * Enum that is used to specify a relative area inside an UI element.
                                 *
                                 * Probably not needed in user applications.
                                 * @public
                                 */
                                export declare enum UISpace {
                                    /**
                                     * Smallest area, equal to the UiElements respective visual content
                                     */
                                    Content = 0,
                                    /**
                                     * Content + Padding, area that should be contained within Backgrounds border
                                     */
                                    PaddedContent = 1,
                                    /**
                                     * Content + Padding + Background padding
                                     */
                                    PaddedBackground = 2,
                                    /**
                                     * Content + Padding + Background padding + Margin
                                     */
                                    Everything = 3
                                }
                                /**
                                 * Interface for 'TextBox'.
                                 * @public
                                 */
                                export declare interface UITextBox<BackgroundType extends UIBackground = UIBackground> extends UIPartWithBackground<BackgroundType>, CustomizableText {
                                }
                                /**
                                 * Interface for 'TextBox'-builder.
                                 * @public
                                 */
                                export declare interface UITextBoxBuilder<BackgroundType extends UIBackground = UIBackground> extends UIElementBuilder<UITextBox<BackgroundType>> {
                                    /**
                                     * Make new TextBoxBuilder with different background
                                     * @param newBackground - Constructor for desired Background. See {@link UIBackgrounds} for a collection of options.
                                     * @public
                                     */
                                    setBackground<NewBackgroundType extends BackgroundType & InternalBackground>(newBackground: BackgroundConstructor<NewBackgroundType>): UITextBoxBuilder<NewBackgroundType>;
                                }
                                /**
                                 * *UIElement* that looks like an Axis tick (tick line + label) and can be used as an Axis CustomTick Marker,
                                 * by passing its *builder* as an argument to {@link Axis.addCustomTick}:
                                 *
                                 * ```typescript
                                 *  // Specify builder for CustomTick Marker.
                                 *  const customTick = Axis.addCustomTick(UIElementBuilders.AxisTickMajor)
                                 *
                                 *  // TickMarker can be accessed via mutator method of CustomTick.
                                 *  customTick.setMarker((marker: UITick) => marker
                                 *      // ... do stuff
                                 *  )
                                 * ```
                                 * @public
                                 */
                                export declare interface UITick extends UIPart, CustomizableText, Pointable {
                                    /**
                                     * Set tick line style.
                                     * @param value - LineStyle or function that modifies current LineStyle value.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setTickStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get tick line style.
                                     * @returns LineStyle.
                                     * @public
                                     */
                                    getTickStyle(): LineStyle;
                                }
                                /**
                                 * Interface for builder for {@link UITick}.
                                 * @public
                                 */
                                export declare type UITickBuilder = UIElementBuilder<UITick>;
                                /**
                                 * Enum for selecting visibility of parts of *Marker*s. Each part can be configured individually:
                                 *
                                 * Example usage:
                                 * ```javascript
                                 * // Hide part
                                 * SeriesMarkerXY.setTickMarkerYVisibility( UIVisibilityModes.never )
                                 * // Show part when pointed
                                 * ChartMarkerXY.setResultTableVisibility( UIVisibilityModes.whenHovered )
                                 * ```
                                 * @public
                                 */
                                export declare enum UIVisibilityModes {
                                    /**
                                     * Part is never visible
                                     */
                                    never = 0,
                                    /**
                                     * Part is always visible
                                     */
                                    always = 1,
                                    /**
                                     * Part is visible when Marker is hovered with mouse and not being dragged
                                     */
                                    whenHovered = 2,
                                    /**
                                     * Part is visible when Marker is being dragged with mouse
                                     */
                                    whenDragged = 3,
                                    /**
                                     * Part is visible when Marker is not being dragged with mouse
                                     */
                                    whenNotDragged = 4,
                                    /**
                                     * Part is visible when Marker is hovered with mouse or dragged
                                     */
                                    whenHoveredOrDragged = 5
                                }
                                /**
                                 * Special type of "Scale" used with 3D Axes. Basically equal to Scale,
                                 * except most of its functionality has been stripped, as there is no
                                 * concept of "pixels" in a 3D Scale.
                                 *
                                 * This class only serves as a container for FormattingRange values, and associated invalidation logic.
                                 *
                                 * @public
                                 */
                                declare class UnitScale extends Validator implements Validatable, FormattingRange {
                                    /**
                                     * Get min value on range
                                     * @returns Number
                                     * @public
                                     */
                                    getInnerStart(): number;
                                    /**
                                     * Get max value on range
                                     * @returns Number
                                     * @public
                                     */
                                    getInnerEnd(): number;
                                    /**
                                     * Get absolute range of Scale interval as
                                     *
                                     * ```javascript
                                     * Math.abs( this.getInnerEnd() - this.getInnerStart() )
                                     * ```
                                     * @returns Number
                                     * @public
                                     */
                                    getInnerInterval(): number;
                                }
                                /**
                                 * Type union for supported ways for users to define a Scale for positioning UI elements and Legend Boxes.
                                 * @public
                                 */
                                export declare type UserScaleDefinition = ScaleXY | Vec2<Axis | BarChartCategoryAxis | BarChartValueAxis | LinearScaleXY> | CoordinateSystemRelative;
                                /**
                                 * Interface defines methods for invalidation and validation of private state
                                 * @public
                                 */
                                declare interface Validatable {
                                }
                                /**
                                 * Class keep track of private state's validation status by invalid flag.
                                 * @public
                                 */
                                declare class Validator {
                                }
                                /**
                                 * Value change event listener.
                                 * @param slice - Slice
                                 * @param previous - Previous slice value
                                 * @param next - Next slice value
                                 * @public
                                 */
                                export declare type ValueChangeEventListener<S extends GaugeSlice> = (slice: S, previous: number, next: number) => void;
                                /**
                                 * Interface to define secondary miscellaneous properties of a LUT.
                                 * @public
                                 */
                                export declare interface ValuePaletteOptions {
                                    /**
                                     * Title of the LUT, which describes the visualization.
                                     *
                                     * Default value: Empty string.
                                     */
                                    title: string;
                                    /**
                                     * Units of the data-values in the LUT, which describes the data domain.
                                     *
                                     * Default value: Empty string.
                                     */
                                    units: string;
                                    /**
                                     * Interpolation behavior of the LUT, which describes the distribution of color for the data:
                                     * - True: LUT creates a ***gradient*** LUT using linear-interpolation (LERP) between colors,
                                     * which were defined in the collection of steps.
                                     * - False: LUT creates a ***uniform*** LUT using step-function for each color
                                     * to describe the range of values where this color is used.
                                     *
                                     * Default value: true.
                                     */
                                    interpolate: boolean;
                                    /**
                                     * Fallback color, which is used if LUT steps are defined as empty or defined incorrectly.
                                     *
                                     * Default value: Black.
                                     */
                                    color: Color;
                                }
                                /**
                                 * Datastructure with generic X and Y properties.
                                 * @public
                                 */
                                export declare interface Vec2<T> {
                                    readonly x: T;
                                    readonly y: T;
                                }
                                /**
                                 * Type definition of a generic 3-dimensional Vector datastructure.
                                 * @public
                                 */
                                export declare interface Vec3<T> {
                                    readonly x: T;
                                    readonly y: T;
                                    readonly z: T;
                                }
                                /**
                                 * Collection of math utilities for numeric Vec3s.
                                 * @public
                                 */
                                export declare const vec3Utils: {
                                    /**
                                     * Add a single value to all values of a 3-dimensional Vector.
                                     * @param v - 3-dimensional Vector to add to.
                                     * @param value - Value to add to all 3-dimensional Vector's values.
                                     * @returns Result as a new 3-dimensional Vector as 3D Point.
                                     * @public
                                     */
                                    add(v: Point3D, value: number): Point3D;
                                    /**
                                     * Add two or more 3-dimensional Vectors together.
                                     * @param v1 - First 3-dimensional Vector to add to.
                                     * @param v2 - One or multiple 3-dimensional Vectors to add.
                                     * @returns New 3-dimensional Vector as 3D Point.
                                     * @public
                                     */
                                    addVec(v1: Point3D, ...v2: Point3D[]): Point3D;
                                    /**
                                     * Subtract a single value from all values of a 3-dimensional Vector.
                                     * @param v - 3-dimensional Vector to subtract from.
                                     * @param value - Value to subtract from all 3-dimensional Vector's values.
                                     * @returns Result as a new 3-dimensional Vector as 3D Point.
                                     * @public
                                     */
                                    subtract(v: Point3D, value: number): Point3D;
                                    /**
                                     * Subtract one or more 3-dimensional Vector from another.
                                     * @param v1 - 3-dimensional Vector to subtract from.
                                     * @param v2 - One or multiple 3-dimensional Vectors to subtract.
                                     * @returns Result as a new 3-dimensional Vector as 3D Point.
                                     * @public
                                     */
                                    subtractVec(v1: Point3D, ...v2: Point3D[]): Point3D;
                                    /**
                                     * Multiply values of a 3-dimensional Vector by a single value.
                                     * @param v - 3-dimensional Vector to multiply.
                                     * @param multiplier - Number to multiply the 3-dimensional Vectors values with.
                                     * @returns Result as a new 3-dimensional Vector as 3D Point.
                                     * @public
                                     */
                                    multiply(v: Point3D, multiplier: number): Point3D;
                                    /**
                                     * Divide values of a 3-dimensional Vector by a single value.
                                     * @param v - 3-dimensional Vector to divide.
                                     * @param divisor - Number to divide the 3-dimensional Vectors values with.
                                     * @returns Result as a new 3-dimensional Vector as 3D Point.
                                     * @public
                                     */
                                    divide(v: Point3D, divisor: number): Point3D;
                                    /**
                                     * Multiply one 3-dimensional Vector with one or more 3-dimensional Vectors
                                     * in the order they were provided.
                                     * @param v1 - 3-dimensional Vector.
                                     * @param v2 - One or multiple 3-dimensional Vectors to multiply with.
                                     * @returns Result as a new 3-dimensional Vector as 3D Point.
                                     * @public
                                     */
                                    multiplyVec(v1: Point3D, ...v2: Point3D[]): Point3D;
                                    /**
                                     * Divide one 3-dimensional Vector with one or more 3-dimensional Vectors
                                     * in the order they were provided.
                                     * @param v1 - 3-dimensional Vector to divide.
                                     * @param v2 - One or multiple 3-dimensional Vector to divide with.
                                     * @returns Result as a new 3-dimensional Vector as 3D Point.
                                     * @public
                                     */
                                    divideVec(v1: Point3D, ...v2: Point3D[]): Point3D;
                                    /**
                                     * Get the length of a 3-dimensional Vector.
                                     * @param v - 3-dimensional Vector.
                                     * @returns Length of a 3-dimensional Vector.
                                     * @public
                                     */
                                    length(v: Point3D): number;
                                    /**
                                     * Get the normal of a 3-dimensional Vector.
                                     * @param v - 3-dimensional Vector.
                                     * @returns Normal as a 3-dimensional Vector.
                                     * @public
                                     */
                                    normalize(v: Point3D): Point3D;
                                    /**
                                     * Get the dot product of two 3-dimensional Vectors.
                                     * @param v1 - 3-dimensional Vector.
                                     * @param v2 - 3-dimensional Vector.
                                     * @public
                                     */
                                    dot(v1: Point3D, v2: Point3D): number;
                                    /**
                                     * Get the cross product of two 3-dimensional Vectors.
                                     * @param v1 - Vector to compare towards
                                     * @param v2 - Vector to compare with
                                     * @public
                                     */
                                    cross(v1: Point3D, v2: Point3D): Point3D;
                                    /**
                                     * @returns Radian angle between v1 and v2.
                                     * @public
                                     */
                                    angle(v1: Point3D, v2: Point3D): number;
                                    /**
                                     * Rotate vector around another arbitrary axis, by amount 'theta' in radians.
                                     * @param v - Vector to rotate
                                     * @param axis - Vector of arbitrary rotation axis
                                     * @param theta - Rotation amount in radians
                                     * @public
                                     */
                                    rotateAroundAxis(v: Point3D, axis: Point3D, theta: number): Point3D;
                                    /**
                                     * Linear interpolation between two vectors and an arbitrary amount as %.
                                     * amount = 0 -\> returns a
                                     * amount = 1 -\> returns b
                                     * @param a - Vector a for interpolation
                                     * @param b - Vector b for interpolation
                                     * @param amount - Interpolation amount
                                     * @public
                                     */
                                    lerp(a: Point3D, b: Point3D, amount: number): Point3D;
                                    /**
                                     * Check two vectors are equal.
                                     * @param a - Vector a
                                     * @param b - Vector b
                                     * @public
                                     */
                                    equals(a: Point3D, b: Point3D): boolean;
                                    /**
                                     * Get vector as absolute.
                                     * @param v - Vector to get absolute value of
                                     * @returns `{ x: Math.abs( v.x ), y: Math.abs( v.y ), z: Math.abs( v.z ) }`
                                     * @public
                                     */
                                    abs(v: Point3D): Point3D;
                                    /**
                                     * Sign of Vector.
                                     * @param v - Vector.
                                     * @returns `{ x: Math.sign( v.x ), y: Math.sign( v.y ), z: Math.sign( v.z ) }`
                                     * @public
                                     */
                                    sign(v: Point3D): Point3D;
                                };
                                /**
                                 * 1D Scale class that represents a plane of the viewport (e.g. Width or Height of monitor).
                                 *
                                 * Interfaces with dashboard resizing and adds concepts of
                                 * - Pixel margins
                                 * - Scale size (pixels) on viewport
                                 * @public
                                 */
                                declare abstract class ViewportScale1D extends Scale1D {
                                    /**
                                     * @param _cellIndex - Dashboard cell start location on Plane of Scale (X or Y).
                                     * @param _cellSpan - Dashboard cell size on Plane of Scale (X or Y).
                                     * @param _cellsAmount - Dashboard total cells amount on Plane of Scale (X or Y).
                                     * @param _observedAmount - ObservableValue for Dashboard cells amount on Plane of Scale (X or Y).
                                     */
                                    constructor(_cellIndex: number, _cellSpan: number, _cellsAmount: number, _observedAmount?: ObservableValue<number[]>);
                                    /**
                                     * Get active size of Scale in viewport as pixels scaled according to Dashboard division if any exists.
                                     * @public
                                     */
                                    getCellSize(): number;
                                }
                                /**
                                 * Abstract class that indicates some visible Filling.
                                 * Used only for instanceOf check at Engine
                                 * @public
                                 */
                                export declare abstract class VisibleFill extends VisibleFillRecord implements FillStyle {
                                }
                                /**
                                 * Record contractor for VisibleFillStyleProperties.
                                 * @public
                                 */
                                declare const VisibleFillRecord: Record_2.Factory<VisibleFillStyleProperties>;
                                /**
                                 * Interface for all properties of a visible FillStyle.
                                 * @public
                                 */
                                export declare interface VisibleFillStyleProperties {
                                    type: 'fillstyle';
                                    fillType: 'solid' | 'image' | 'radial-gradient' | 'linear-gradient' | 'individual' | 'palette';
                                    /**
                                     * For SolidFill: Color which is used to fill shape.
                                     *
                                     * For IndividualPointFill: Fallback Color for filling shape if individual Color was not given.
                                     *
                                     * For PalettedFill: Fallback Color for filling shape if palette was not given.
                                     */
                                    color: Color;
                                }
                                /**
                                 * Visibility state change event handler
                                 * @public
                                 */
                                declare type VisibleStateChangedHandler<T> = (obj: T, state: boolean) => void;
                                /**
                                 * MultidimensionalStrategy for X Dimension
                                 * @public
                                 */
                                export declare const xDimensionStrategy: MultidimensionalStrategy;
                                /**
                                 * Ordered tuple that contains values for:
                                 * - X
                                 * - Open
                                 * - High
                                 * - Low
                                 * - Close
                                 * @public
                                 */
                                export declare type XOHLC = [number, number, number, number, number];
                                /**
                                 * @public
                                 */
                                export declare interface XYZDataInput {
                                    /**
                                     * Append a single `XYZ` coordinate or list of coordinates into the *series*.
                                     *
                                     * ```ts
                                     *  // Example syntax
                                     *  LineSeries3D.add({ x: 0, y: 0, z: 0 })
                                     *
                                     *  LineSeries3D.add([
                                     *      { x: 0, y: 100, z: 50 },
                                     *      { x: 10, y: 50, z: 150 },
                                     *      { x: 20, y: 75, z: 100 },
                                     *  ])
                                     * ```
                                     *
                                     * @param points - Single XYZ coordinate or list of coordinates.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    add(data: Point3D | Point3D[]): this;
                                    /**
                                     * Clear all previously pushed data points from the *series*.
                                     *
                                     * ```ts
                                     *  // Example usage
                                     *  LineSeries.clear()
                                     * ```
                                     *
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    clear(): this;
                                    /**
                                     * Get amount of points that series currently has.
                                     * @returns Number of points
                                     * @public
                                     */
                                    getPointAmount(): number;
                                }
                                /**
                                 * MultidimensionalStrategy for X Dimension
                                 * @public
                                 */
                                export declare const yDimensionStrategy: MultidimensionalStrategy;
                                /**
                                 * Chart that is used to display a fully zoomed out view of 1 or more charts or series.
                                 * It also provides convenient built-in user interactions for interacting with the attached chart(s) that show the zoomed in view.
                                 *
                                 * By nature, ZoomBandChart does not host any original data. Rather, it is a duplicate of other data sets in order to simultaneously show both zoomed in view and fully zoomed out view.
                                 *
                                 * `ZoomBandChart` can be created in two different ways - to learn more about creation time configuration of `ZoomBandChart`, please refer to:
                                 * - {@link LightningChart.ZoomBandChart} (stand-alone chart).
                                 * - {@link Dashboard.createZoomBandChart} (zoom band chart inside *dashboard*).
                                 *
                                 * **ZoomBandChart features**
                                 *
                                 *  - Add series to ZoomBandChart with {@link add} method.
                                 *      - This method returns a handle to the duplicated series in ZBC, which can be used to change its style, etc.
                                 *  - Series can be removed from ZoomBandChart with {@link disposeSeries} method.
                                 *  - ZoomBandChart axes can be modified via {@link getDefaultAxisX} and {@link getDefaultAxisY} methods.
                                 *  - Display series along 1 shared value range {@link ZoomBandChartOptions.useSharedValueAxis}.
                                 *  - Change orientation {@link ZoomBandChartOptions.orientation}
                                 *  - Configure title {@link setTitle}.
                                 *
                                 * @public
                                 */
                                export declare class ZoomBandChart implements Control, DashboardPanel, ChartAPI, ChartWithStylableSeriesBackground {
                                    /**
                                     * Selector for "relative" _Coordinate System_.
                                     *
                                     * This coordinate system is relative to the bottom left corner of the Control (chart/dashboard/etc.), and is measured as pixels.
                                     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from bottom.
                                     *
                                     * This selector can be used for two purposes:
                                     *
                                     * **Positioning LCJS UI elements in pixels:**
                                     *
                                     * ```ts
                                     *  // Position UI element in pixels by supplying `Control.coordsRelative` as its positioning system.
                                     *  const textBox = Control.addUIElement(UIElementBuilders.TextBox, Control.coordsRelative)
                                     *      .setOrigin(UIOrigins.LeftBottom)
                                     *      .setPosition({ x: 100, y: 20 })
                                     * ```
                                     *
                                     * **Translations between coordinate systems:**
                                     *
                                     * Use with {@link translateCoordinate} method to translate coordinates from "relative" to another coordinate system.
                                     *
                                     * @public
                                     */
                                    readonly coordsRelative: CoordinateSystemRelative;
                                    /**
                                     * Selector for "client" _Coordinate System_.
                                     *
                                     * This references the coordinate system used in HTML.
                                     * It starts at top left of the web page and is measured in pixels.
                                     * For example, `{ x: 100, y: 20 }` corresponds to 100 pixels from left and 20 pixels from top.
                                     *
                                     * JavaScript events are tracked and HTML elements are positioned in the client coordinate system.
                                     *
                                     * This selector can be used for translating client coordinates to other coordinate systems and vice versa.
                                     * For example, in order to:
                                     * - Position LCJS UI elements in client coordinates
                                     * - Find client coordinate that matches a location along LCJS Axis or Chart.
                                     * - etc.
                                     *
                                     * See {@link translateCoordinate} for more detailed use case information and example usage.
                                     *
                                     * @public
                                     */
                                    readonly coordsClient: CoordinateSystemClient;
                                    /**
                                     * Public, safe interface of rendering engine.
                                     * @public
                                     */
                                    readonly engine: PublicEngine;
                                    /**
                                     * Add a series to the ZoomBandChart.
                                     *
                                     * This creates a duplicate of the supplied series that is displayed in the ZoomBandChart.
                                     * The method returns a reference to the duplicate in ZBC that is usually the same type as the attached series (exception being OHLCSeries which is returned as LineSeries).
                                     * This duplicate reference can be styled separately from the original series.
                                     *
                                     * The ZoomBandChart automatically matches the data from the original series.
                                     *
                                     * ```ts
                                     *  // Example usage
                                     *  const zbcSeries = ZoomBandChart.add(myLineSeries)
                                     *      .setStrokeStyle((stroke) => stroke.setThickness(2))
                                     * ```
                                     *
                                     * Series can be removed from ZoomBandChart with {@link disposeSeries} method.
                                     *
                                     * @param series - Series to attach.
                                     * @returns     Reference to duplicate series created in ZoomBandChart.
                                     * @public
                                     */
                                    add<SeriesType extends ZoomBandChartSupportedSeries>(series: SeriesType): SeriesType extends OHLCSeries ? LineSeries : SeriesType extends ZoomBandChartSupportedSeries ? SeriesType : never;
                                    /**
                                     * Remove series from being display in the ZoomBandChart.
                                     *
                                     * This method only needs to be called when you want to not display a series in the ZoomBandChart, but don't want to completely destroy it in the source chart.
                                     * You do not need to call this method if you are destroying the original series using the `dispose` method.
                                     *
                                     * @param series - Series object.
                                     * @returns Object itself.
                                     * @public
                                     */
                                    disposeSeries(series: ZoomBandChartSupportedSeries): this;
                                    /**
                                     * Set fill style of "defocus overlay". This is formed of 2 separate rectangles, 1 on left and another on right side of the visible data range.
                                     * By default its transparent dark to help user understand which part of data is visible.
                                     * @param   value -     FillStyle or function which modifies current fill style.
                                     * @returns     Object itself.
                                     * @public
                                     */
                                    setDefocusOverlayFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of "defocus overlay". This is formed of 2 separate rectangles, 1 on left and another on right side of the visible data range.
                                     * By default its transparent dark to help user understand which part of data is visible.
                                     * @returns     FillStyle
                                     * @public
                                     */
                                    getDefocusOverlayFillStyle(): FillStyle;
                                    /**
                                     * Set Zoom band chart splitter stroke style.
                                     * This separates the visible data set from full data set.
                                     * @param   value -     LineStyle or function which modifies current LineStyle.
                                     * @returns     Object itself.
                                     * @public
                                     */
                                    setSplitterStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get Zoom band chart splitter stroke style.
                                     * This separates the visible data set from full data set.
                                     * @returns     LineStyle
                                     * @public
                                     */
                                    getSplitterStrokeStyle(): LineStyle;
                                    /**
                                     * Set fill style of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                     * @param   value -     FillStyle or function which modifies current fill style.
                                     * @returns     Object itself.
                                     * @public
                                     */
                                    setKnobFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                     * @returns     FillStyle
                                     * @public
                                     */
                                    getKnobFillStyle(): FillStyle;
                                    /**
                                     * Set stroke style of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                     * @param   value -     LineStyle or function which modifies current LineStyle.
                                     * @returns     Object itself.
                                     * @public
                                     */
                                    setKnobStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                     * @returns     LineStyle
                                     * @public
                                     */
                                    getKnobStrokeStyle(): LineStyle;
                                    /**
                                     * Set size of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                     * @param   size - Size as pixels
                                     * @returns     Object itself.
                                     * @public
                                     */
                                    setKnobSize(size: Point): this;
                                    /**
                                     * Get size of zoom band chart knobs. These are just UX indicators to help users understand you can drag the ZBC area left/right.
                                     * @returns     Size as pixels.
                                     * @public
                                     */
                                    getKnobSize(): Point;
                                    /**
                                     * Get the X Axis of the ZoomBandChart.
                                     * @returns Axis
                                     * @public
                                     */
                                    getDefaultAxisX(): Axis;
                                    /**
                                     * Get the Y Axis of the ZoomBandChart.
                                     * @returns Axis
                                     * @public
                                     */
                                    getDefaultAxisY(): Axis;
                                    /**
                                     * Get size of control as pixels.
                                     *
                                     * For stand-alone component, the size will be equal to the size of its containing HTML \<div\> (`Control.engine.container`)
                                     *
                                     * For component inside Dashboard, the size will only include the component itself, so size can be less than the size of containing HTML \<div\>.
                                     *
                                     * @returns     Object with x and y properties `{ x: number, y: number }`, where both are pixel values.
                                     * @public
                                     */
                                    getSizePixels(): Point;
                                    /**
                                     * Subscribe to `resize` event.
                                     * This event is triggered whenever the area of *chart* changes (due to document or dashboard resizing).
                                     *
                                     * ```typescript
                                     *  // Example usage,
                                     *  ChartXY.onResize((chart, width, height, engineWidth, engineHeight) => {
                                     *      console.log('Chart resized', 'width', width, 'height', height, 'engineWidth', engineWidth, 'engineHeight', engineHeight)
                                     *  })
                                     * ```
                                     *
                                     * @param handler - Handler function for event
                                     * @param obj - Panel itself
                                     * @param width - Width of control in pixels
                                     * @param height - Height of control in pixels
                                     * @param engineWidth - Width of control rendering engine in pixels
                                     * @param engineHeight - Height of control rendering engine in pixels
                                     * @returns Token of subscription
                                     * @public
                                     */
                                    onResize(handler: (obj: this, width: number, height: number, engineWidth: number, engineHeight: number) => void): Token;
                                    /**
                                     * Remove event listener from resize event.
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offResize(token: Token): boolean;
                                    /**
                                     * Get minimum size of Panel.
                                     * Depending on the type of class this value might be automatically computed to fit different elements.
                                     * @returns Point minimum size or undefined if unimplemented
                                     * @public
                                     */
                                    getMinimumSize(): Point | undefined;
                                    /**
                                     * Set {@link FillStyle} of *series background* (area behind *series*).
                                     *
                                     * ```typescript
                                     *  // Example usage,
                                     *  ChartXY.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA( 60, 0, 0 ) }))
                                     * ```
                                     *
                                     * **Related API:**
                                     * - Use {@link SolidFill} to describe a solid fill color.
                                     * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
                                     *
                                     * **Transparent chart backgrounds:**
                                     *
                                     * LightningChart JS charts can be configured to be fully or partially transparent.
                                     *
                                     * ```ts
                                     *  // Example, partially transparent chart
                                     *
                                     *  // Engine background exists under all LCJS components. In case of Dashboard, there is only 1 shared engine background.
                                     *  chart.engine.setBackgroundFillStyle(emptyFill)
                                     *  // Chart background covers every 1 chart. In case of Dashboard, every chart has its own chart background.
                                     *  chart.setBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                                     *  // Some charts also have a separate series background.
                                     *  chart.setSeriesBackgroundFillStyle(new SolidFill({ color: ColorRGBA(0, 0, 0, 100) }))
                                     * ```
                                     *
                                     * @param value - `FillStyle` or function which mutates the active `FillStyle`.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setSeriesBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get FillStyle of Series background area (area behind series).
                                     * @returns FillStyle
                                     * @public
                                     */
                                    getSeriesBackgroundFillStyle(): FillStyle;
                                    /**
                                     * Set {@link LineStyle} of series background border stroke.
                                     *
                                     * ```typescript
                                     *  // Example usage,
                                     *  ChartXY.setSeriesBackgroundStrokeStyle(new SolidLine({
                                     *      thickness: 2,
                                     *      fillStyle: new SolidFill({ color: ColorRGBA( 0, 255, 0 ) })
                                     *  }))
                                     * ```
                                     *
                                     * **Related API:**
                                     * - Use {@link SolidLine} to describe a solid line style.
                                     * - Use {@link SolidFill} to describe a solid fill color.
                                     * - Use {@link ColorRGBA} to create a *color* from Red, Green, Blue (and optionally) Alpha values in range [0, 255].
                                     *
                                     * @param value - `LineStyle` or function which mutates the active `LineStyle`.
                                     * @returns Object itself
                                     * @public
                                     */
                                    setSeriesBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get Stroke style of Series background area (area behind series).
                                     * @returns LineStyle
                                     * @public
                                     */
                                    getSeriesBackgroundStrokeStyle(): LineStyle;
                                    /**
                                     * Set theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @param enabled - Theme effect enabled
                                     * @returns          Object itself.
                                     * @public
                                     */
                                    setSeriesBackgroundEffect(enabled: boolean): this;
                                    /**
                                     * Get theme effect enabled on component or disabled.
                                     *
                                     * A theme can specify an {@link Effect} to add extra visual oomph to chart applications, like Glow effects around data or other components.
                                     * Whether this effect is drawn above a particular component can be configured using the `setEffect` method.
                                     *
                                     * ```ts
                                     *  // Example, disable theme effect from a particular component.
                                     *  Component.setEffect(false)
                                     * ```
                                     *
                                     * For the most part, theme effects are **enabled** by default on most components.
                                     *
                                     * Theme effect is configured with {@link Theme.effect} property.
                                     *
                                     * @returns          Boolean that describes whether drawing the theme effect is enabled around the component or not.
                                     * @public
                                     */
                                    getSeriesBackgroundEffect(): boolean;
                                    /**
                                     * Returns the Theme currently being used.
                                     * @returns An object containing the Theme.
                                     * @public
                                     */
                                    getTheme(): Theme;
                                    /**
                                     * Set text of Chart title.
                                     * @param title - Chart title as a string.
                                     * @returns Object itself for fluent interface.
                                     * @public
                                     */
                                    setTitle(title: string): this;
                                    /**
                                     * Get text of Chart title.
                                     * @returns Chart title as a string.
                                     * @public
                                     */
                                    getTitle(): string;
                                    /**
                                     * Set fill style of Chart Title.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Create a new style
                                     * ZoomBandChart.setTitleFillStyle(new SolidFill({ color: ColorHEX('#F00') }))
                                     * // Change transparency
                                     * ZoomBandChart.setTitleFillStyle((solidFill) => solidFill.setA(80))
                                     * // Set hidden
                                     * ZoomBandChart.setTitleFillStyle(emptyFill)
                                     * ```
                                     * @param value - Either a FillStyle object or a function, which will be used to create a new FillStyle based on current value.
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setTitleFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fill style of Chart Title.
                                     * @returns FillStyle object
                                     * @public
                                     */
                                    getTitleFillStyle(): FillStyle;
                                    /**
                                     * Set font of Chart Title.
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Create a new FontSettings
                                     * ZoomBandChart.setTitleFont(new FontSettings({ size: 24, style: 'italic' }))
                                     * // Change existing settings
                                     * ZoomBandChart.setTitleFont((fontSettings) => fontSettings.setWeight('bold'))
                                     * ```
                                     * @param value - Either a FontSettings object or a function, which will be used to create a new FontSettings based on current value.
                                     * @returns Chart itself
                                     * @public
                                     */
                                    setTitleFont(value: FontSettings | ImmutableMutator<FontSettings>): this;
                                    /**
                                     * Get font of Chart title.
                                     * @returns FontSettings object
                                     * @public
                                     */
                                    getTitleFont(): FontSettings;
                                    /**
                                     * Specifies Margins after chart title.
                                     *
                                     * This does not have an effect if title is hidden (empty FillStyle).
                                     *
                                     * ```typescript
                                     *  // Example 1, specify complete margin for Title (four sides).
                                     *  ZoomBandChart.setTitleMargin({ left: 16, right: 16, top: 32, bottom: 8 })
                                     * ```
                                     *
                                     * ```typescript
                                     *  // Example 2, specify only single margin for Title.
                                     *  ZoomBandChart.setTitleMargin({ right: 64 })
                                     * ```
                                     * ```typescript
                                     *  // Example 2, specify margins for all sides with same value for Title.
                                     *  ZoomBandChart.setTitleMargin(40)
                                     * ```
                                     * @param marginPixels - Gap after the chart title in pixels.
                                     * @returns Chart itself for fluent interface
                                     * @public
                                     */
                                    setTitleMargin(marginPixels: Partial<Margin> | pixel): this;
                                    /**
                                     * @returns Padding after Chart title
                                     * @public
                                     */
                                    getTitleMargin(): Partial<Margin>;
                                    /**
                                     * Set padding around Chart in pixels.
                                     * @param padding - Number with pixel margins for all sides or datastructure with individual pixel paddings
                                     *                      for each side. Any side can be omitted, only passed values will be overridden.
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    setPadding(padding: Partial<Margin> | number): this;
                                    /**
                                     * Get padding around Chart in pixels.
                                     * @returns Padding datastructure
                                     * @public
                                     */
                                    getPadding(): Margin;
                                    /**
                                     * Set fillStyle of panel background.
                                     * @param value - FillStyle or function which modifies it
                                     * @returns Object itself
                                     * @public
                                     */
                                    setBackgroundFillStyle(value: FillStyle | ImmutableMutator<FillStyle>): this;
                                    /**
                                     * Get fillstyle of chart background.
                                     * @returns FillStyle
                                     * @public
                                     */
                                    getBackgroundFillStyle(): FillStyle;
                                    /**
                                     * Set stroke style of panel background.
                                     * @param value - LineStyle or function which modifies it
                                     * @returns Object itself
                                     * @public
                                     */
                                    setBackgroundStrokeStyle(value: LineStyle | ImmutableMutator<LineStyle>): this;
                                    /**
                                     * Get stroke style of chart background.
                                     * @returns LineStyle
                                     * @public
                                     */
                                    getBackgroundStrokeStyle(): LineStyle;
                                    /**
                                     * Translate a coordinate in HTML client coordinate system to relative coordinates within the component.
                                     *
                                     * ```ts
                                     *  const locationClient = { clientX: document.body.clientWidth * 0.2, clientY: document.body.clientHeight * 0.5 }
                                     *  const locationRelative = chart.translateCoordinate(locationClient, chart.coordsRelative)
                                     *  // locationRelative is in pixels relative to bottom left corner of the chart
                                     * ```
                                     *
                                     * Relative coordinates can be used for positioning LightningChart JS UI components:
                                     *
                                     * ```ts
                                     *  const textBox = chart.addUIElement(UIElementBuilders.TextBox, chart.coordsRelative)
                                     *      // Left bottom of TextBox is positioned 20 pixels right and 20 pixels up from charts bottom left corner
                                     *      .setOrigin(UIOrigins.LeftBottom)
                                     *      .setPosition({ x: 20, y: 20 })
                                     * ```
                                     *
                                     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                                     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                                     *
                                     * ```ts
                                     *  LineSeries.add(myData)
                                     *  requestAnimationFrame(() => {
                                     *      // translateCoordinate should now consider data added just now.
                                     *  })
                                     * ```
                                     *
                                     * @public
                                     */
                                    translateCoordinate<T extends CoordinateSystemRelative>(coordinate: CoordinateClient, targetCoordinateSystem: T): T extends CoordinateSystemRelative ? CoordinateXY : never;
                                    /**
                                     * Translate a coordinate from relative control coordinates to HTML client coordinate system.
                                     *
                                     * ```ts
                                     *  // 10 pixels left and 20 pixels up from controls bottom left corner
                                     *  const locationRelative = { x: 10, y: 20 }
                                     *  const locationClient = chart.translateCoordinate(locationRelative, chart.coordsRelative, chart.coordsClient)
                                     * ```
                                     *
                                     * Client coordinates can be used to absolute position HTML elements using CSS, for example.
                                     *
                                     * ```ts
                                     *  myHTMLElement.style.position = 'absolute'
                                     *  myHTMLElement.style.left = locationClient.clientX
                                     *  myHTMLElement.style.top = locationClient.clientY
                                     * ```
                                     *
                                     * NOTE: Currently coordinate translations can't be guaranteed to be in sync with latest updates to charts.
                                     * For example, if you change axis interval, or add data to a series, you need to wait for 1 frame to be displayed before `translateCoordinate` will behave as expected.
                                     *
                                     * ```ts
                                     *  LineSeries.add(myData)
                                     *  requestAnimationFrame(() => {
                                     *      // translateCoordinate should now consider data added just now.
                                     *  })
                                     * ```
                                     *
                                     * @public
                                     */
                                    translateCoordinate<T extends CoordinateSystemClient>(coordinate: CoordinateXY, srcCoordinateSystem: CoordinateSystemRelative, targetCoordinateSystem: T): T extends CoordinateSystemClient ? CoordinateClient : never;
                                    /**
                                     * Add a stand-alone *UIElement* using a *builder*.
                                     *
                                     * @typeParam UIElementType -   Type of *UIElement* that is specified by 'builder'-*parameter*.
                                     *
                                     * @param builder - *UIElementBuilder*. If omitted, *TextBoxBuilder* will be selected. Use {@link UIElementBuilders} for selection.
                                     * @param scale - Optional custom scale to position UIElement on. Defaults to whole component in percentages [0, 100].
                                     * @returns Object that fulfills *interfaces*:  *UIElementType* (typeparam) and *UIElement*
                                     * @public
                                     */
                                    addUIElement<UIElementType extends UIPart = UITextBox>(uiElementBuilder?: UIElementBuilder<UIElementType>, scale?: LinearScaleXY): UIElementType & UIElement;
                                    /**
                                     * Add a *legendbox*.
                                     *
                                     * *Legendbox* is a type of *UI element*, that floats inside the chart/component it is created inside. It can be freely moved around
                                     * with user interactions, as well as positioned in application code.
                                     *
                                     * The purpose of *legendbox* is to describe the *series* and other visual components of the *chart*, by displaying their names and colors.
                                     * Hovering over a *series'* *legendbox entry* will highlight that *series*, and clicking on the *entry* will toggle that *series'* visibility.
                                     *
                                     * **Legendbox alignment:**
                                     *
                                     * Alignment of legendbox can be selected by supplying one of the available {@link LegendBoxBuilders} to `addLegendBox`:
                                     *
                                     * ```typescript
                                     *  // Default (vertical) LegendBox.
                                     *  const legendBox = ChartXY.addLegendBox()
                                     *
                                     *  // Horizontal LegendBox.
                                     *  const horizontalLegendBox = ChartXY.addLegendBox(LegendBoxBuilders.HorizontalLegendBox)
                                     * ```
                                     *
                                     * **Custom Legendbox positioning:**
                                     *
                                     * By default LegendBoxes are placed on the right side, or bottom of the *chart* (depending on *alignment*).
                                     *
                                     * A custom location can be configured with {@link UIElement} API:
                                     * - {@link UIElement.setPosition}
                                     * - {@link UIElement.setOrigin}
                                     * - {@link UIElement.setMargin}
                                     *
                                     * *Position coordinate system* is specified when creating *legendbox*.
                                     *
                                     * 1) LegendBox with default positioning coordinate system.
                                     *
                                     * ```typescript
                                     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox )
                                     *      // Position = [0, 100] as percentages.
                                     *      .setPosition({ x: 50, y: 50 })
                                     * ```
                                     *
                                     * 2) Position in pixel coordinate system.
                                     *
                                     * ```typescript
                                     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, chart.coordsRelative )
                                     *      // Position = pixels.
                                     *      .setPosition({ x: 300, y: 100 })
                                     * ```
                                     *
                                     * 3) Position on Axes.
                                     *
                                     * ```typescript
                                     *  addLegendBox( LegendBoxBuilders.VerticalLegendBox, { x: chartXY.getDefaultAxisX(), y: chartXY.getDefaultAxisY() } )
                                     *      // Position = Axis values.
                                     *      .setPosition({ x: 5, y: 5 })
                                     * ```
                                     *
                                     * @param builder - *LegendBoxBuilder*. If omitted, *VerticalLegendBox* will be selected. Use {@link LegendBoxBuilders} for selection.
                                     * @param scale - Optional parameter for altering the coordinate system used for positioning the LegendBox. Defaults to whole Chart in percentages [0, 100].
                                     * @returns LegendBox
                                     * @public
                                     */
                                    addLegendBox(builder?: UILegendBoxBuilder, scale?: UserScaleDefinition): LegendBox;
                                    /**
                                     * Capture rendered state in an image file. Prompts the browser to download the created file.
                                     *
                                     * **NOTE: The download might be blocked by browser/plugins as harmful.**
                                     * To prevent this, only call the method in events tied to user-interactions.
                                     * From mouse-event handlers, for example.
                                     *
                                     * Has two optional parameters which directly reference JavaScript API HTMLCanvasElement.toDataURL.
                                     * For supported image formats, compression quality, Etc. refer to:
                                     *
                                     * https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL
                                     *
                                     * Example usage:
                                     *```javascript
                                     * // Download 'screenshot.png'
                                     * saveToFile('screenshot')
                                     * // Attempt download 'maybeNotSupported.bmp'
                                     * saveToFile('maybeNotSupported', 'image/bmp')
                                     * // Attempt download jpeg.file with specified compression quality
                                     * saveToFile('fileName', 'image/jpeg', 0.50)
                                     * ```
                                     *
                                     * @remarks              **If 'type' is not supported by browser, an Error will be thrown.**
                                     *
                                     * @param fileName - Name of prompted download file as string. **File extension shouldn't be included**
                                     *                          as it is automatically detected from 'type'-argument.
                                     * @param type - A DOMString indicating the image format. The default format type is image/png.
                                     * @param encoderOptions - A Number between 0 and 1 indicating the image quality to use for image formats
                                     *                          that use lossy compression such as image/jpeg and image/webp. If this argument is anything else,
                                     *                          the default value for image quality is used. The default value is 0.92.
                                     * @public
                                     */
                                    saveToFile(fileName: string, type?: string, encoderOptions?: number): this;
                                    /**
                                     * **Permanently** destroy the component.
                                     *
                                     * To fully allow Garbage-Collection to free the resources used by the component, make sure to remove **any references**
                                     * **to the component and its children** in application code.
                                     * ```javascript
                                     * let chart = ...ChartXY()
                                     * let axisX = chart.getDefaultAxisX()
                                     * // Dispose Chart, and remove all references so that they can be garbage-collected.
                                     * chart.dispose()
                                     * chart = undefined
                                     * axisX = undefined
                                     * ```
                                     * @returns Object itself for fluent interface
                                     * @public
                                     */
                                    dispose(): this;
                                    /**
                                     * Subscribe `onDispose` event.
                                     * This event is triggered whenever the Zoom BandChart is disposed.
                                     *
                                     * ```typescript
                                     *  // Example usage
                                     *
                                     * zoomBandChart.onDispose(() => {
                                     *   console.log('zoomBandChart was disposed')
                                     * })
                                     *
                                     * zoomBandChart.dispose()
                                     * ```
                                     *
                                     * @param clbk - Event handler function
                                     * @returns Token of subscription
                                     * @public
                                     */
                                    onDispose(clbk: (obj: this) => void): Token;
                                    /**
                                     * Remove event listener from dispose event.
                                     * @param token - Token of event listener which has to be removed
                                     * @returns True if the listener is successfully removed and false if it is not found
                                     * @public
                                     */
                                    offDispose(token: Token): boolean;
                                }
                                /**
                                 * Interface that can be used to define {@link ZoomBandChart} configurations, when inside a {@link Dashboard}, that can't be changed after creation.
                                 * @public
                                 */
                                export declare interface ZoomBandChartDashboardOptions extends DashboardCellOptions, ZoomBandChartOptions {
                                }
                                /**
                                 * Interface that can be used to define {@link ZoomBandChart} configurations that can't be changed after creation.
                                 * @public
                                 */
                                export declare interface ZoomBandChartOptions extends CommonChartOptions {
                                    /**
                                     * Select orientation of ZoomBandChart.
                                     *
                                     * `'x'` = primary axis is X axis (commonly used when X = Time axis).
                                     *
                                     * `'y'` = opposite mode, for example when Time axis is Y and chart is rotated 90 degrees.
                                     *
                                     * Defaults to `'x'`
                                     * @public
                                     */
                                    orientation?: 'x' | 'y';
                                    /**
                                     * `ZoomBandChart` can display series belonging to several different axes.
                                     * By default, every unique value axis will have its own scale in the zoom band chart.
                                     * By setting this flag to `true`, the zoom band chart will display all its series with 1 shared scale.
                                     *
                                     * For example, imagine an use case where you have 3 temperature (celsius) time series.
                                     * Each trend has the same Time (X) view, but different ranges of values (1: 0 - 10 celsius, 2: 40 - 60 celsius, 3: -10 - 0 celsius)
                                     * If you need to be able to compare the temperatures in the zoom band chart, then you would set this flag to `true`.
                                     *
                                     * Defaults to `false`
                                     * @public
                                     */
                                    useSharedValueAxis?: boolean;
                                    /**
                                     * Interface for specifying Axis configurations that can't be changed after creation of the Zoom Band Chart.
                                     *
                                     * Mainly intended to be able to use high precision axis in time series use cases.
                                     *
                                     * ```ts
                                     *  // Example usage
                                     *  const zoomBandChart = lightningChart().ZoomBandChart({
                                     *      defaultAxis: { type: 'linear-highPrecision' },
                                     *  })
                                     * ```
                                     */
                                    defaultAxis?: AxisOptions;
                                }
                                /**
                                 * Type union of Series supported by ZoomBandChart.
                                 * @public
                                 */
                                export declare type ZoomBandChartSupportedSeries = BasicSeries | AreaSeries | AreaRangeSeries | OHLCSeries | HeatmapGridSeriesIntensityValues;
                                export { }

}